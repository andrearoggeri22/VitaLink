name: üöÄ Deploy VitaLink to AWS

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - development
        - staging
        - production
      force_recreate:
        description: 'Force recreate stack (delete existing)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: vitalink
  STACK_NAME: VitaLink-Stack
  
jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: üìã Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: üîç Run linting
        run: |
          pip install flake8
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: üß™ Run tests
        run: |
          if [ -d "tests" ]; then
            python -m pytest tests/ -v --cov=app --cov-report=xml
          else
            echo "No tests directory found, skipping tests"
          fi

  build-and-deploy:
    name: üèóÔ∏è Build and Deploy
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üê≥ Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Crea repository ECR se non esiste
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY
          
          # Build dell'immagine Docker
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          
          # Push dell'immagine
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: üîç Validate CloudFormation template
        run: |
          aws cloudformation validate-template --template-body file://vitalink-infrastructure.yaml

      - name: üßπ Clean up existing stack (if requested)
        if: github.event.inputs.force_recreate == 'true'
        run: |
          echo "üóëÔ∏è Deleting existing stack..."
          if aws cloudformation describe-stacks --stack-name $STACK_NAME > /dev/null 2>&1; then
            aws cloudformation delete-stack --stack-name $STACK_NAME
            echo "‚è≥ Waiting for stack deletion..."
            aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME
            echo "‚úÖ Stack deleted successfully"
          else
            echo "‚ÑπÔ∏è No existing stack found"
          fi

      - name: üöÄ Deploy CloudFormation stack
        env:
          IMAGE_URI: ${{ steps.build-image.outputs.image }}
          ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}
        run: |
          echo "üöÄ Deploying VitaLink infrastructure..."
          
          # Controlla se lo stack esiste
          if aws cloudformation describe-stacks --stack-name $STACK_NAME > /dev/null 2>&1; then
            echo "üìù Stack exists, updating..."
            aws cloudformation update-stack \
              --stack-name $STACK_NAME \
              --template-body file://vitalink-infrastructure.yaml \
              --parameters \
                ParameterKey=ImageURI,ParameterValue=$IMAGE_URI \
                ParameterKey=DatabasePassword,ParameterValue="${{ secrets.DB_PASSWORD }}" \
                ParameterKey=Environment,ParameterValue=$ENVIRONMENT \
                ParameterKey=DesiredTaskCount,ParameterValue=1 \
              --capabilities CAPABILITY_NAMED_IAM || echo "No changes to deploy"
          else
            echo "üÜï Creating new stack..."
            aws cloudformation create-stack \
              --stack-name $STACK_NAME \
              --template-body file://vitalink-infrastructure.yaml \
              --parameters \
                ParameterKey=ImageURI,ParameterValue=$IMAGE_URI \
                ParameterKey=DatabasePassword,ParameterValue="${{ secrets.DB_PASSWORD }}" \
                ParameterKey=Environment,ParameterValue=$ENVIRONMENT \
                ParameterKey=DesiredTaskCount,ParameterValue=1 \
              --capabilities CAPABILITY_NAMED_IAM
          fi

      - name: ‚è≥ Wait for deployment completion
        run: |
          echo "‚è≥ Waiting for stack deployment to complete..."
          aws cloudformation wait stack-create-complete --stack-name $STACK_NAME || \
          aws cloudformation wait stack-update-complete --stack-name $STACK_NAME
          echo "‚úÖ Deployment completed!"

      - name: üìä Get deployment outputs
        id: get-outputs
        run: |
          echo "üìä Retrieving stack outputs..."
          OUTPUTS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].Outputs')
          
          APP_URL=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="VitaLinkURL") | .OutputValue')
          HEALTH_URL=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="HealthCheckURL") | .OutputValue')
          DB_ENDPOINT=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="DatabaseEndpoint") | .OutputValue')
          
          echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
          echo "health-url=$HEALTH_URL" >> $GITHUB_OUTPUT
          echo "db-endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
          
          echo "üåê Application URL: $APP_URL"
          echo "üè• Health Check URL: $HEALTH_URL"
          echo "üíæ Database Endpoint: $DB_ENDPOINT"

      - name: üè• Health check
        env:
          HEALTH_URL: ${{ steps.get-outputs.outputs.health-url }}
        run: |
          echo "üè• Performing health check..."
          
          # Attendi che l'applicazione sia pronta (max 5 minuti)
          for i in {1..15}; do
            echo "üîç Health check attempt $i/15..."
            
            if curl -f -s "$HEALTH_URL" > /dev/null; then
              echo "‚úÖ Application is healthy!"
              HEALTH_RESPONSE=$(curl -s "$HEALTH_URL")
              echo "üìã Health check response: $HEALTH_RESPONSE"
              exit 0
            else
              echo "‚è≥ Application not ready yet, waiting 20 seconds..."
              sleep 20
            fi
          done
          
          echo "‚ö†Ô∏è Health check failed after 5 minutes"
          echo "üîç Checking ECS service status..."
          aws ecs describe-services --cluster VitaLink-Cluster-production --services vitalink-service-production || true
          exit 1

      - name: üìù Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üéâ VitaLink Deployment Summary
          
          ## üìä Deployment Information
          - **Stack Name**: $STACK_NAME
          - **Environment**: ${{ github.event.inputs.environment || 'production' }}
          - **Image**: ${{ steps.build-image.outputs.image }}
          - **Commit**: ${{ github.sha }}
          
          ## üåê Application URLs
          - **Main Application**: ${{ steps.get-outputs.outputs.app-url }}
          - **Health Check**: ${{ steps.get-outputs.outputs.health-url }}
          
          ## üèóÔ∏è Infrastructure
          - **Database Endpoint**: ${{ steps.get-outputs.outputs.db-endpoint }}
          - **AWS Region**: ${{ env.AWS_REGION }}
          
          ## üìã Next Steps
          1. Visit the application URL to verify it's working
          2. Check the health endpoint for service status
          3. Monitor CloudWatch logs for any issues
          
          ---
          üöÄ **Deployment completed successfully!**
          EOF

  cleanup-on-failure:
    name: üßπ Cleanup on Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure() && github.event.inputs.force_recreate == 'true'
    
    steps:
      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üßπ Clean up failed deployment
        run: |
          echo "üßπ Cleaning up failed deployment..."
          if aws cloudformation describe-stacks --stack-name $STACK_NAME > /dev/null 2>&1; then
            STACK_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text)
            
            if [[ "$STACK_STATUS" == *"ROLLBACK"* ]] || [[ "$STACK_STATUS" == *"FAILED"* ]]; then
              echo "üóëÔ∏è Deleting failed stack..."
              aws cloudformation delete-stack --stack-name $STACK_NAME
              echo "‚è≥ Waiting for cleanup completion..."
              aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME
              echo "‚úÖ Cleanup completed"
            fi
          fi