name: üöÄ Deploy VitaLink (Staging)

on:
  push:
    branches: [ develop ]
  pull_request:
    branches: [ develop ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: vitalink
  STACK_NAME: VitaLink-Stack-Staging
  ENVIRONMENT: staging

jobs:
  test-and-deploy:
    name: üß™ Test and Deploy to Staging
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üìã Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: üß™ Run quick tests
        run: |
          # Esegui solo test veloci per staging
          if [ -d "tests" ]; then
            python -m pytest tests/ -v --tb=short
          else
            echo "‚ö†Ô∏è No tests found - skipping test phase"
          fi

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üê≥ Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build and push staging image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: staging-${{ github.sha }}
        run: |
          # Build dell'immagine per staging
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:staging-latest .
          
          # Push dell'immagine
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging-latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: üöÄ Deploy to staging
        env:
          IMAGE_URI: ${{ steps.build-image.outputs.image }}
        run: |
          echo "üöÄ Deploying to staging environment..."
          
          # Usa un template specifico per staging o parametri diversi
          if aws cloudformation describe-stacks --stack-name $STACK_NAME > /dev/null 2>&1; then
            echo "üìù Updating staging stack..."
            aws cloudformation update-stack \
              --stack-name $STACK_NAME \
              --template-body file://vitalink-infrastructure.yaml \
              --parameters \
                ParameterKey=ImageURI,ParameterValue=$IMAGE_URI \
                ParameterKey=DatabasePassword,ParameterValue="${{ secrets.DB_PASSWORD_STAGING }}" \
                ParameterKey=Environment,ParameterValue=$ENVIRONMENT \
                ParameterKey=DesiredTaskCount,ParameterValue=1 \
              --capabilities CAPABILITY_NAMED_IAM || echo "No changes to deploy"
          else
            echo "üÜï Creating staging stack..."
            aws cloudformation create-stack \
              --stack-name $STACK_NAME \
              --template-body file://vitalink-infrastructure.yaml \
              --parameters \
                ParameterKey=ImageURI,ParameterValue=$IMAGE_URI \
                ParameterKey=DatabasePassword,ParameterValue="${{ secrets.DB_PASSWORD_STAGING }}" \
                ParameterKey=Environment,ParameterValue=$ENVIRONMENT \
                ParameterKey=DesiredTaskCount,ParameterValue=1 \
              --capabilities CAPABILITY_NAMED_IAM
          fi

      - name: ‚è≥ Wait for deployment
        run: |
          echo "‚è≥ Waiting for staging deployment..."
          aws cloudformation wait stack-create-complete --stack-name $STACK_NAME || \
          aws cloudformation wait stack-update-complete --stack-name $STACK_NAME

      - name: üß™ Run staging tests
        run: |
          # Ottieni l'URL di staging
          STAGING_URL=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`VitaLinkURL`].OutputValue' --output text)
          
          echo "üß™ Running tests against staging: $STAGING_URL"
          
          # Test di base
          for i in {1..5}; do
            echo "üîç Testing staging deployment (attempt $i/5)..."
            if curl -f -s "$STAGING_URL/health" > /dev/null; then
              echo "‚úÖ Staging is healthy!"
              break
            else
              echo "‚è≥ Waiting for staging to be ready..."
              sleep 30
            fi
          done

      - name: üìù Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const stackName = '${{ env.STACK_NAME }}';
            const outputs = await exec.getExecOutput('aws', [
              'cloudformation', 'describe-stacks',
              '--stack-name', stackName,
              '--query', 'Stacks[0].Outputs'
            ]);
            
            const stackOutputs = JSON.parse(outputs.stdout);
            const stagingUrl = stackOutputs.find(o => o.OutputKey === 'VitaLinkURL')?.OutputValue;
            
            const comment = `## üöÄ Staging Deployment Complete!
            
            **Environment**: Staging
            **Stack**: ${stackName}
            **Commit**: ${{ github.sha }}
            
            ### üåê Staging URLs
            - **Application**: ${stagingUrl}
            - **Health Check**: ${stagingUrl}/health
            
            ### ‚úÖ Deployment Status
            - Build: ‚úÖ Success
            - Deploy: ‚úÖ Success  
            - Health Check: ‚úÖ Passed
            
            You can test your changes at the staging URL above!`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  cleanup-old-staging:
    name: üßπ Cleanup Old Staging Deployments
    runs-on: ubuntu-latest
    needs: test-and-deploy
    if: always() && needs.test-and-deploy.result == 'success'
    
    steps:
      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üßπ Clean up old ECR images
        run: |
          echo "üßπ Cleaning up old staging images..."
          
          # Mantieni solo le ultime 5 immagini di staging
          aws ecr list-images --repository-name $ECR_REPOSITORY \
            --filter tagStatus=TAGGED \
            --query 'imageIds[?starts_with(imageTag, `staging-`)]' > staging_images.json
          
          # Se ci sono pi√π di 5 immagini, elimina le pi√π vecchie
          IMAGE_COUNT=$(cat staging_images.json | jq length)
          
          if [ "$IMAGE_COUNT" -gt 5 ]; then
            echo "üóëÔ∏è Found $IMAGE_COUNT staging images, keeping only the latest 5"
            
            # Ordina per data e prendi le pi√π vecchie da eliminare
            aws ecr describe-images --repository-name $ECR_REPOSITORY \
              --image-ids file://staging_images.json \
              --query 'sort_by(imageDetails, &imagePushedAt)[0:-5].imageId' > images_to_delete.json
            
            if [ "$(cat images_to_delete.json | jq length)" -gt 0 ]; then
              aws ecr batch-delete-image \
                --repository-name $ECR_REPOSITORY \
                --image-ids file://images_to_delete.json
              echo "‚úÖ Cleaned up old staging images"
            fi
          else
            echo "‚ÑπÔ∏è Only $IMAGE_COUNT staging images found, no cleanup needed"
          fi