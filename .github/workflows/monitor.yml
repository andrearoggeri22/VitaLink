name: 📊 Monitor VitaLink Application

on:
  schedule:
    # Controlla ogni 15 minuti durante l'orario di lavoro
    - cron: '*/15 9-17 * * 1-5'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
        - development
        - staging
        - production

env:
  AWS_REGION: us-east-1
  STACK_NAME: VitaLink-Stack

jobs:
  health-check:
    name: 🏥 Application Health Check
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 📊 Get application URLs
        id: get-urls
        run: |
          if aws cloudformation describe-stacks --stack-name $STACK_NAME > /dev/null 2>&1; then
            OUTPUTS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].Outputs')
            
            APP_URL=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="VitaLinkURL") | .OutputValue')
            HEALTH_URL=$(echo $OUTPUTS | jq -r '.[] | select(.OutputKey=="HealthCheckURL") | .OutputValue')
            
            echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
            echo "health-url=$HEALTH_URL" >> $GITHUB_OUTPUT
            echo "stack-exists=true" >> $GITHUB_OUTPUT
            
            echo "🌐 Application URL: $APP_URL"
            echo "🏥 Health URL: $HEALTH_URL"
          else
            echo "stack-exists=false" >> $GITHUB_OUTPUT
            echo "⚠️ Stack $STACK_NAME not found"
          fi

      - name: 🏥 Check application health
        if: steps.get-urls.outputs.stack-exists == 'true'
        id: health-check
        run: |
          HEALTH_URL="${{ steps.get-urls.outputs.health-url }}"
          
          echo "🏥 Checking application health at: $HEALTH_URL"
          
          # Prova a fare il health check
          HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "✅ Application is healthy (HTTP $HTTP_CODE)"
            echo "health-status=healthy" >> $GITHUB_OUTPUT
            
            # Mostra la risposta del health check
            echo "📋 Health check response:"
            cat /tmp/health_response.json | jq . || cat /tmp/health_response.json
          else
            echo "❌ Application health check failed (HTTP $HTTP_CODE)"
            echo "health-status=unhealthy" >> $GITHUB_OUTPUT
            
            if [ -f /tmp/health_response.json ]; then
              echo "📋 Error response:"
              cat /tmp/health_response.json
            fi
          fi

      - name: 📈 Check application performance
        if: steps.get-urls.outputs.stack-exists == 'true' && steps.health-check.outputs.health-status == 'healthy'
        run: |
          APP_URL="${{ steps.get-urls.outputs.app-url }}"
          
          echo "📈 Testing application performance..."
          
          # Test di performance con curl
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$APP_URL" || echo "0")
          
          echo "⏱️ Response time: ${RESPONSE_TIME}s"
          
          # Considera lento se > 5 secondi
          if [ "$(echo "$RESPONSE_TIME > 5" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
            echo "⚠️ Application response time is slow (>${RESPONSE_TIME}s)"
          else
            echo "✅ Application response time is acceptable"
          fi

  infrastructure-check:
    name: 🏗️ Infrastructure Health Check
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 🚢 Check ECS service status
        run: |
          echo "🚢 Checking ECS service status..."
          
          CLUSTER_NAME="VitaLink-Cluster-production"
          SERVICE_NAME="vitalink-service-production"
          
          if aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" > /dev/null 2>&1; then
            SERVICE_INFO=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME")
            
            RUNNING_COUNT=$(echo $SERVICE_INFO | jq '.services[0].runningCount')
            DESIRED_COUNT=$(echo $SERVICE_INFO | jq '.services[0].desiredCount')
            SERVICE_STATUS=$(echo $SERVICE_INFO | jq -r '.services[0].status')
            
            echo "📊 Service Status: $SERVICE_STATUS"
            echo "📊 Running Tasks: $RUNNING_COUNT/$DESIRED_COUNT"
            
            if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ] && [ "$SERVICE_STATUS" = "ACTIVE" ]; then
              echo "✅ ECS service is healthy"
            else
              echo "⚠️ ECS service may have issues"
            fi
          else
            echo "❌ ECS service not found"
          fi

      - name: 💾 Check RDS status
        run: |
          echo "💾 Checking RDS database status..."
          
          DB_IDENTIFIER="vitalink-postgres-production"
          
          if aws rds describe-db-instances --db-instance-identifier "$DB_IDENTIFIER" > /dev/null 2>&1; then
            DB_INFO=$(aws rds describe-db-instances --db-instance-identifier "$DB_IDENTIFIER")
            
            DB_STATUS=$(echo $DB_INFO | jq -r '.DBInstances[0].DBInstanceStatus')
            BACKUP_RETENTION=$(echo $DB_INFO | jq '.DBInstances[0].BackupRetentionPeriod')
            
            echo "📊 Database Status: $DB_STATUS"
            echo "📊 Backup Retention: $BACKUP_RETENTION days"
            
            if [ "$DB_STATUS" = "available" ]; then
              echo "✅ RDS database is healthy"
            else
              echo "⚠️ RDS database status: $DB_STATUS"
            fi
          else
            echo "❌ RDS database not found"
          fi

      - name: 🔄 Check Load Balancer status
        run: |
          echo "🔄 Checking Application Load Balancer status..."
          
          # Trova l'ALB tramite tag
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `VitaLink`)].LoadBalancerArn' \
            --output text)
          
          if [ -n "$ALB_ARN" ]; then
            ALB_INFO=$(aws elbv2 describe-load-balancers --load-balancer-arns "$ALB_ARN")
            ALB_STATE=$(echo $ALB_INFO | jq -r '.LoadBalancers[0].State.Code')
            
            echo "📊 Load Balancer State: $ALB_STATE"
            
            if [ "$ALB_STATE" = "active" ]; then
              echo "✅ Load Balancer is healthy"
              
              # Controlla i target groups
              TARGET_GROUPS=$(aws elbv2 describe-target-groups \
                --load-balancer-arn "$ALB_ARN" \
                --query 'TargetGroups[0].TargetGroupArn' --output text)
              
              if [ -n "$TARGET_GROUPS" ]; then
                HEALTHY_TARGETS=$(aws elbv2 describe-target-health \
                  --target-group-arn "$TARGET_GROUPS" \
                  --query 'TargetHealthDescriptions[?TargetHealth.State==`healthy`] | length(@)')
                
                echo "📊 Healthy Targets: $HEALTHY_TARGETS"
              fi
            else
              echo "⚠️ Load Balancer state: $ALB_STATE"
            fi
          else
            echo "❌ Load Balancer not found"
          fi

  cost-monitoring:
    name: 💰 Cost Monitoring
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 💰 Check AWS costs
        run: |
          echo "💰 Checking AWS costs for VitaLink resources..."
          
          # Ottieni i costi degli ultimi 7 giorni
          START_DATE=$(date -d '7 days ago' '+%Y-%m-%d')
          END_DATE=$(date '+%Y-%m-%d')
          
          echo "📅 Checking costs from $START_DATE to $END_DATE"
          
          # Questo comando potrebbe non funzionare in AWS Education, ma proviamo
          aws ce get-cost-and-usage \
            --time-period Start=$START_DATE,End=$END_DATE \
            --granularity DAILY \
            --metrics BlendedCost \
            --group-by Type=DIMENSION,Key=SERVICE || echo "⚠️ Cost Explorer not available in AWS Education"

  monitoring-summary:
    name: 📊 Monitoring Summary
    runs-on: ubuntu-latest
    needs: [health-check, infrastructure-check, cost-monitoring]
    if: always()
    
    steps:
      - name: 📊 Generate monitoring report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 📊 VitaLink Monitoring Report
          
          ## 🏥 Application Health
          - **Health Check**: ${{ needs.health-check.result == 'success' && '✅ Healthy' || '❌ Issues Detected' }}
          - **Stack Status**: ${{ needs.health-check.outputs.stack-exists == 'true' && '✅ Active' || '⚠️ Not Found' }}
          
          ## 🏗️ Infrastructure Health
          - **Infrastructure Check**: ${{ needs.infrastructure-check.result == 'success' && '✅ Healthy' || '❌ Issues Detected' }}
          - **ECS Service**: Checked
          - **RDS Database**: Checked
          - **Load Balancer**: Checked
          
          ## 💰 Cost Monitoring
          - **Cost Check**: ${{ needs.cost-monitoring.result == 'success' && '✅ Completed' || '⚠️ Limited Access' }}
          
          ## 📅 Report Details
          - **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          - **Environment**: ${{ github.event.inputs.environment || 'production' }}
          - **Trigger**: ${{ github.event_name == 'schedule' && 'Scheduled' || 'Manual' }}
          
          ---
          ${{ needs.health-check.result == 'success' && needs.infrastructure-check.result == 'success' && '🎉 **All systems operational!**' || '⚠️ **Issues detected - check individual job details**' }}
          EOF

      - name: 📧 Notify on critical issues
        if: needs.health-check.result == 'failure'
        run: |
          echo "🚨 Critical issues detected!"
          echo "The application health check failed."
          echo "This would normally trigger alerts to the development team."
          # In una configurazione reale, qui potresti inviare notifiche via:
          # - Slack webhook
          # - Email via SES
          # - Teams webhook
          # - PagerDuty