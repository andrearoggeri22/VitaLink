{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"VitaLink Documentation","text":"<p>Welcome to the VitaLink documentation\u2014a comprehensive guide to my platform for managing health data.</p>"},{"location":"index.html#project-overview","title":"Project Overview","text":"<p>VitaLink is designed to make it easy for both doctors and patients to manage and monitor health information. With VitaLink, you can track vital signs, generate detailed reports, and connect with various health platforms\u2014all in one place.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Patient Management: Register and manage patient profiles with ease</li> <li>Vital Signs Monitoring: Track and visualize vital parameters over time</li> <li>Report Generation: Create personalized reports for patients</li> <li>Health Platform Integration: Connect with platforms like Fitbit and other health monitoring devices</li> <li>Secure Authentication: Robust authentication system to keep your data safe</li> </ul>"},{"location":"index.html#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Modules: Details about the main modules of the application</li> </ul>"},{"location":"index.html#get-started","title":"Get Started","text":"<p>To begin using VitaLink, check out the API and module documentation to understand how the system works and how you can integrate it into your applications.</p>"},{"location":"modules/api.html","title":"API","text":"<p>API Blueprint Module. This module defines the REST API endpoints for the VitaLink application. It provides routes for accessing and managing patient data, vital signs, notes, and observations through authenticated HTTP requests. The API is designed to be used by: 1. Frontend applications that need to fetch or update data 2. Mobile applications that interface with the VitaLink backend 3. External systems that need to integrate with VitaLink All endpoints require authentication using JWT tokens, which can be obtained via the auth module. Every request is validated to ensure the requesting doctor has proper permissions for the requested resources. The API follows RESTful principles with consistent error handling and status codes: - 200: Successful GET, PUT or DELETE - 201: Successful POST (resource created) - 400: Bad request (invalid data or parameters) - 401: Unauthorized (missing or invalid authentication) - 403: Forbidden (authenticated but lacking permission) - 404: Resource not found - 500: Server error API routes are organized by resource type (patients, notes, observations, etc.) and include proper audit logging for compliance and traceability.</p>"},{"location":"modules/api.html#app.api.api_bp","title":"<code>api_bp = Blueprint('api', __name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/api.html#app.api.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/api.html#app.api.get_patients","title":"<code>get_patients(doctor)</code>","text":"<p>Get all patients for the authenticated doctor. This endpoint returns a list of all patients associated with the authenticated doctor, providing basic patient information in a serialized format. Args:     doctor: Doctor object automatically provided by the doctor_required decorator Returns:     JSON response with an array of patient objects Response format:     {         \"patients\": [             {                 \"id\": 1,                 \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",                 \"first_name\": \"John\",                 \"last_name\": \"Doe\",                 ...             },             ...         ]     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients', methods=['GET'])\n@doctor_required\ndef get_patients(doctor):\n    \"\"\"\n    Get all patients for the authenticated doctor.\n    This endpoint returns a list of all patients associated with the\n    authenticated doctor, providing basic patient information in a\n    serialized format.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n    Returns:\n        JSON response with an array of patient objects\n    Response format:\n        {\n            \"patients\": [\n                {\n                    \"id\": 1,\n                    \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n                    \"first_name\": \"John\",\n                    \"last_name\": \"Doe\",\n                    ...\n                },\n                ...\n            ]\n        }\n    \"\"\"\n    patients = doctor.patients.all()\n    return jsonify({\n        \"patients\": [patient.to_dict() for patient in patients]\n    }), 200\n</code></pre>"},{"location":"modules/api.html#app.api.get_patient","title":"<code>get_patient(doctor, patient_uuid)</code>","text":"<p>Get a specific patient by UUID. This endpoint returns detailed information for a specific patient identified by UUID. It includes validation to ensure the doctor has access to the requested patient. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     patient_uuid (str): UUID of the patient to retrieve Returns:     JSON response with patient details or error message Status codes:     200: Patient found and returned successfully     400: Invalid UUID format     403: Doctor not authorized to access this patient     404: Patient not found Response format (success):     {         \"patient\": {             \"id\": 1,             \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",             \"first_name\": \"John\",             \"last_name\": \"Doe\",             ...         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients/&lt;string:patient_uuid&gt;', methods=['GET'])\n@doctor_required\ndef get_patient(doctor, patient_uuid):\n    \"\"\"\n    Get a specific patient by UUID.\n    This endpoint returns detailed information for a specific patient identified by UUID.\n    It includes validation to ensure the doctor has access to the requested patient.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        patient_uuid (str): UUID of the patient to retrieve\n    Returns:\n        JSON response with patient details or error message\n    Status codes:\n        200: Patient found and returned successfully\n        400: Invalid UUID format\n        403: Doctor not authorized to access this patient\n        404: Patient not found\n    Response format (success):\n        {\n            \"patient\": {\n                \"id\": 1,\n                \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                ...\n            }\n        }\n    \"\"\"\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    return jsonify({\n        \"patient\": patient.to_dict()\n    }), 200\n</code></pre>"},{"location":"modules/api.html#app.api.get_vitals","title":"<code>get_vitals(doctor, patient_uuid)</code>","text":"<p>Get vital signs for a specific patient from health platform. This endpoint retrieves vital sign data from the connected health platform (e.g., Fitbit) for a specific patient. It supports filtering by vital sign type and date range. The patient must have an active connection to a health platform. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     patient_uuid (str): UUID of the patient Query parameters:     type (str): Type of vital sign to retrieve (e.g., 'heart_rate', 'steps')     start_date (str, optional): Start date for data range in ISO format (YYYY-MM-DD)     end_date (str, optional): End date for data range in ISO format (YYYY-MM-DD) Returns:     JSON response with vital sign data or error message Status codes:     200: Data retrieved successfully     400: Invalid UUID format     403: Doctor not authorized to access this patient     404: Patient not found or no health platform connection     500: Error retrieving data from health platform Response format (success):     {         \"heart_rate\": [             {                 \"timestamp\": \"2023-05-01T14:30:00Z\",                 \"value\": 72,                 \"unit\": \"bpm\"             },             ...         ]     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients/&lt;string:patient_uuid&gt;/vitals', methods=['GET'])\n@doctor_required\ndef get_vitals(doctor, patient_uuid):\n    \"\"\"\n    Get vital signs for a specific patient from health platform.\n    This endpoint retrieves vital sign data from the connected health platform\n    (e.g., Fitbit) for a specific patient. It supports filtering by vital sign type\n    and date range. The patient must have an active connection to a health platform.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        patient_uuid (str): UUID of the patient\n    Query parameters:\n        type (str): Type of vital sign to retrieve (e.g., 'heart_rate', 'steps')\n        start_date (str, optional): Start date for data range in ISO format (YYYY-MM-DD)\n        end_date (str, optional): End date for data range in ISO format (YYYY-MM-DD)\n    Returns:\n        JSON response with vital sign data or error message\n    Status codes:\n        200: Data retrieved successfully\n        400: Invalid UUID format\n        403: Doctor not authorized to access this patient\n        404: Patient not found or no health platform connection\n        500: Error retrieving data from health platform\n    Response format (success):\n        {\n            \"heart_rate\": [\n                {\n                    \"timestamp\": \"2023-05-01T14:30:00Z\",\n                    \"value\": 72,\n                    \"unit\": \"bpm\"\n                },\n                ...\n            ]\n        }\n    \"\"\"\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n      # Check if patient has health platform connection\n    if not patient.platform_access_token:\n        return jsonify({\"error\": _(\"Patient does not have a health platform connection\")}), 404\n    # Get query parameters for filtering\n    type_param = request.args.get('type')\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    # Import health platform functionality\n    from .health_platforms import get_processed_fitbit_data\n    try:\n        # Get data from Fitbit\n        data = get_processed_fitbit_data(\n            patient,\n            type_param,\n            start_date=start_date,\n            end_date=end_date\n        )\n        if not data:\n            return jsonify({type_param: []}), 200\n        # Return data for the specific vital type\n        return jsonify({type_param: data}), 200\n    except Exception as e:\n        logger.error(f\"Error getting data from health platform: {str(e)}\")\n        return jsonify({'error': _('Failed to retrieve health platform data'), 'message': str(e)}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.get_notes","title":"<code>get_notes(doctor, patient_uuid)</code>","text":"<p>Get medical notes for a specific patient. This endpoint retrieves all medical notes associated with a specific patient. Notes are ordered by creation date (most recent first) and include information about the doctor who created them. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     patient_uuid (str): UUID of the patient whose notes should be retrieved Returns:     JSON response with an array of note objects or error message Status codes:     200: Notes retrieved successfully     400: Invalid UUID format     403: Doctor not authorized to access this patient     404: Patient not found Response format:     {         \"notes\": [             {                 \"id\": 1,                 \"content\": \"Patient reported improvement in symptoms\",                 \"doctor_id\": 2,                 \"doctor_name\": \"Dr. Jane Smith\",                 \"created_at\": \"2023-05-01T14:30:00Z\"             },             ...         ]     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients/&lt;string:patient_uuid&gt;/notes', methods=['GET'])\n@doctor_required\ndef get_notes(doctor, patient_uuid):\n    \"\"\"\n    Get medical notes for a specific patient.\n    This endpoint retrieves all medical notes associated with a specific patient.\n    Notes are ordered by creation date (most recent first) and include information\n    about the doctor who created them.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        patient_uuid (str): UUID of the patient whose notes should be retrieved\n    Returns:\n        JSON response with an array of note objects or error message\n    Status codes:\n        200: Notes retrieved successfully\n        400: Invalid UUID format\n        403: Doctor not authorized to access this patient\n        404: Patient not found\n    Response format:\n        {\n            \"notes\": [\n                {\n                    \"id\": 1,\n                    \"content\": \"Patient reported improvement in symptoms\",\n                    \"doctor_id\": 2,\n                    \"doctor_name\": \"Dr. Jane Smith\",\n                    \"created_at\": \"2023-05-01T14:30:00Z\"\n                },\n                ...\n            ]\n        }\n    \"\"\"\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\":_(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Get notes\n    notes = patient.get_notes()\n    return jsonify({\n        \"notes\": [note.to_dict() for note in notes]\n    }), 200\n</code></pre>"},{"location":"modules/api.html#app.api.add_note","title":"<code>add_note(doctor, patient_uuid)</code>","text":"<p>Add a new medical note for a patient. This endpoint allows doctors to create a new medical note for a specific patient. The note is associated with both the patient and the doctor who created it, and includes a timestamp of when it was created. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     patient_uuid (str): UUID of the patient to add a note for Request body:     content (str): Text content of the note Returns:     JSON response with the created note details or error message Status codes:     201: Note created successfully     400: Invalid UUID format, missing JSON request, or empty content     403: Doctor not authorized to access this patient     404: Patient not found     500: Database error Response format (success):     {         \"message\": \"Note added successfully\",         \"note\": {             \"id\": 123,             \"content\": \"Patient reported feeling better\",             \"doctor_id\": 45,             \"patient_id\": 67,             \"created_at\": \"2023-05-01T15:30:00Z\"         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients/&lt;string:patient_uuid&gt;/notes', methods=['POST'])\n@doctor_required\ndef add_note(doctor, patient_uuid):\n    \"\"\"\n    Add a new medical note for a patient.\n    This endpoint allows doctors to create a new medical note for a specific patient.\n    The note is associated with both the patient and the doctor who created it,\n    and includes a timestamp of when it was created.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        patient_uuid (str): UUID of the patient to add a note for\n    Request body:\n        content (str): Text content of the note\n    Returns:\n        JSON response with the created note details or error message\n    Status codes:\n        201: Note created successfully\n        400: Invalid UUID format, missing JSON request, or empty content\n        403: Doctor not authorized to access this patient\n        404: Patient not found\n        500: Database error\n    Response format (success):\n        {\n            \"message\": \"Note added successfully\",\n            \"note\": {\n                \"id\": 123,\n                \"content\": \"Patient reported feeling better\",\n                \"doctor_id\": 45,\n                \"patient_id\": 67,\n                \"created_at\": \"2023-05-01T15:30:00Z\"\n            }\n        }\n    \"\"\"\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Validate request data\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON in request\")}), 400\n    data = request.json\n    if 'content' not in data or not data['content']:\n        return jsonify({\"error\": _(\"Note content cannot be empty\")}), 400\n    content = data['content']\n    # Create new note\n    try:\n        note = Note(\n            patient_id=patient.id,\n            doctor_id=doctor.id,\n            content=content\n        )\n        db.session.add(note)\n        db.session.commit()\n        # Log the note creation\n        from .audit import log_note_creation\n        log_note_creation(doctor.id, note)\n        logger.info(f\"Note added for patient {patient_uuid} via API\")\n        return jsonify({\n            \"message\": _(\"Note added successfully\"),\n            \"note\": note.to_dict()\n        }), 201\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error adding note: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while adding the note\")}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.delete_note","title":"<code>delete_note(doctor, note_id)</code>","text":"<p>Delete a medical note by ID. This endpoint allows doctors to delete a medical note they have previously created. Multiple security checks are performed to ensure that only the doctor who created the note can delete it, and only for patients they are authorized to access. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     note_id (int): ID of the note to delete Returns:     JSON response with success message or error message Status codes:     200: Note deleted successfully     403: Not authorized to delete this note/access this patient     404: Note or patient not found     500: Database error Response format (success):     {         \"message\": \"Note deleted successfully\",         \"note\": {             \"id\": 123,             \"content\": \"Patient reported feeling better\",             \"doctor_id\": 45,             \"patient_id\": 67,             \"created_at\": \"2023-05-01T15:30:00Z\"         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/notes/&lt;int:note_id&gt;', methods=['DELETE'])\n@doctor_required\ndef delete_note(doctor, note_id):\n    \"\"\"\n    Delete a medical note by ID.\n    This endpoint allows doctors to delete a medical note they have previously created.\n    Multiple security checks are performed to ensure that only the doctor who created\n    the note can delete it, and only for patients they are authorized to access.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        note_id (int): ID of the note to delete\n    Returns:\n        JSON response with success message or error message\n    Status codes:\n        200: Note deleted successfully\n        403: Not authorized to delete this note/access this patient\n        404: Note or patient not found\n        500: Database error\n    Response format (success):\n        {\n            \"message\": \"Note deleted successfully\",\n            \"note\": {\n                \"id\": 123,\n                \"content\": \"Patient reported feeling better\",\n                \"doctor_id\": 45,\n                \"patient_id\": 67,\n                \"created_at\": \"2023-05-01T15:30:00Z\"\n            }\n        }\n    \"\"\"\n    # Find the note\n    note = Note.query.get(note_id)\n    if not note:\n        return jsonify({\"error\": _(\"Note not found\")}), 404\n    # Find the patient\n    patient = Patient.query.get(note.patient_id)\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Check if the doctor is the author of the note\n    if note.doctor_id != doctor.id:\n        return jsonify({\"error\": _(\"You can only delete notes you have created\")}), 403\n    # Delete the note\n    try:\n        # Log the note deletion\n        from .audit import log_note_delete\n        log_note_delete(doctor.id, note)\n        # Store note details for response\n        note_dict = note.to_dict()\n        patient_uuid = patient.uuid\n        db.session.delete(note)\n        db.session.commit()\n        logger.info(f\"Note {note_id} deleted for patient {patient_uuid} via API\")\n        return jsonify({\n            \"message\": _(\"Note deleted successfully\"),\n            \"note\": note_dict\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error deleting note: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while deleting the note\")}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.get_observations","title":"<code>get_observations(doctor, patient_id)</code>","text":"<p>Get vital sign observations for the specified patient. This endpoint retrieves doctor-created observations about a patient's vital signs for a specific time period. Observations can be filtered by date range and vital sign type. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     patient_id (int): ID of the patient to get observations for Query parameters:     start_date (str, optional): ISO formatted start date to filter observations     end_date (str, optional): ISO formatted end date to filter observations     vital_type (str, optional): Type of vital sign to filter by (e.g. 'heart_rate') Returns:     JSON response with an array of observation objects or error message Status codes:     200: Observations retrieved successfully     400: Invalid date format or vital sign type     403: Doctor not authorized to access this patient     404: Patient not found Response format:     [         {             \"id\": 1,             \"patient_id\": 42,             \"doctor_id\": 5,             \"vital_type\": \"heart_rate\",             \"content\": \"Heart rate has stabilized after medication change\",             \"start_date\": \"2023-05-01T00:00:00Z\",             \"end_date\": \"2023-05-07T23:59:59Z\",             \"created_at\": \"2023-05-08T10:15:30Z\"         },         ...     ]</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/observations/&lt;int:patient_id&gt;', methods=['GET'])\n@doctor_required\ndef get_observations(doctor, patient_id):\n    \"\"\"\n    Get vital sign observations for the specified patient.\n    This endpoint retrieves doctor-created observations about a patient's vital signs\n    for a specific time period. Observations can be filtered by date range and vital\n    sign type.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        patient_id (int): ID of the patient to get observations for\n    Query parameters:\n        start_date (str, optional): ISO formatted start date to filter observations\n        end_date (str, optional): ISO formatted end date to filter observations\n        vital_type (str, optional): Type of vital sign to filter by (e.g. 'heart_rate')\n    Returns:\n        JSON response with an array of observation objects or error message\n    Status codes:\n        200: Observations retrieved successfully\n        400: Invalid date format or vital sign type\n        403: Doctor not authorized to access this patient\n        404: Patient not found\n    Response format:\n        [\n            {\n                \"id\": 1,\n                \"patient_id\": 42,\n                \"doctor_id\": 5,\n                \"vital_type\": \"heart_rate\",\n                \"content\": \"Heart rate has stabilized after medication change\",\n                \"start_date\": \"2023-05-01T00:00:00Z\",\n                \"end_date\": \"2023-05-07T23:59:59Z\",\n                \"created_at\": \"2023-05-08T10:15:30Z\"\n            },\n            ...\n        ]\n    \"\"\"\n    # Find the patient\n    patient = Patient.query.get(patient_id)\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Get query parameters for filtering\n    start_date_str = request.args.get('start_date')\n    end_date_str = request.args.get('end_date')\n    vital_type = request.args.get('vital_type')\n    # Create query\n    query = VitalObservation.query.filter_by(patient_id=patient_id)\n    # Apply filters\n    if start_date_str:\n        try:\n            start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00'))\n            query = query.filter(VitalObservation.start_date &gt;= start_date)\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid start_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    if end_date_str:\n        try:\n            end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00'))\n            query = query.filter(VitalObservation.end_date &lt;= end_date)\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid end_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    if vital_type:\n        try:\n            vital_type_enum = VitalSignType(vital_type)\n            query = query.filter_by(vital_type=vital_type_enum)\n        except ValueError:\n            return jsonify({\n                \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                    \"types\": \", \".join(t.value for t in VitalSignType)\n                }\n            }), 400\n    # Execute query\n    observations = query.order_by(VitalObservation.created_at.desc()).all()\n    return jsonify([obs.to_dict() for obs in observations]), 200\n</code></pre>"},{"location":"modules/api.html#app.api.add_observation","title":"<code>add_observation(doctor)</code>","text":"<p>Add a new vital sign observation for a patient. This endpoint allows doctors to create a new observation about a patient's vital signs for a specific time period. Observations include interpretations and medical notes about trends in vital sign data. Args:     doctor: Doctor object automatically provided by the doctor_required decorator Request body:     patient_id (int): ID of the patient the observation is for     vital_type (str): Type of vital sign from VitalSignType enum (e.g., 'heart_rate')     content (str): Doctor's notes and interpretation of the vital sign data     start_date (str): ISO formatted start date of the observation period     end_date (str): ISO formatted end date of the observation period Returns:     JSON response with the created observation or error message Status codes:     201: Observation created successfully     400: Invalid request data (missing fields, invalid vital type, invalid dates)     403: Not authorized to create observation for this patient     404: Patient not found     500: Database error Response format (success):     {         \"message\": \"Observation added successfully\",         \"observation\": {             \"id\": 123,             \"patient_id\": 42,             \"doctor_id\": 5,             \"vital_type\": \"heart_rate\",             \"content\": \"Heart rate has stabilized after medication change\",             \"start_date\": \"2023-05-01T00:00:00Z\",             \"end_date\": \"2023-05-07T23:59:59Z\",             \"created_at\": \"2023-05-08T10:15:30Z\"         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/observations', methods=['POST'])\n@doctor_required\ndef add_observation(doctor):\n    \"\"\"\n    Add a new vital sign observation for a patient.\n    This endpoint allows doctors to create a new observation about a patient's vital signs\n    for a specific time period. Observations include interpretations and medical notes\n    about trends in vital sign data.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n    Request body:\n        patient_id (int): ID of the patient the observation is for\n        vital_type (str): Type of vital sign from VitalSignType enum (e.g., 'heart_rate')\n        content (str): Doctor's notes and interpretation of the vital sign data\n        start_date (str): ISO formatted start date of the observation period\n        end_date (str): ISO formatted end date of the observation period\n    Returns:\n        JSON response with the created observation or error message\n    Status codes:\n        201: Observation created successfully\n        400: Invalid request data (missing fields, invalid vital type, invalid dates)\n        403: Not authorized to create observation for this patient\n        404: Patient not found\n        500: Database error\n    Response format (success):\n        {\n            \"message\": \"Observation added successfully\",\n            \"observation\": {\n                \"id\": 123,\n                \"patient_id\": 42,\n                \"doctor_id\": 5,\n                \"vital_type\": \"heart_rate\",\n                \"content\": \"Heart rate has stabilized after medication change\",\n                \"start_date\": \"2023-05-01T00:00:00Z\",\n                \"end_date\": \"2023-05-07T23:59:59Z\",\n                \"created_at\": \"2023-05-08T10:15:30Z\"\n            }\n        }\n    \"\"\"\n    # Validate request data\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON in request\")}), 400\n    data = request.json\n    # Validate required fields\n    required_fields = ['patient_id', 'vital_type', 'content', 'start_date', 'end_date']\n    for field in required_fields:\n        if field not in data:\n            return jsonify({\"error\": _(\"Missing required field: %(field)s\") % {\"field\": field}}), 400\n    # Find the patient\n    patient_id = data['patient_id']\n    patient = Patient.query.get(patient_id)\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in doctor.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Validate vital type\n    try:\n        logger.debug(f\"Input vital_type: {data['vital_type']}\")\n        logger.debug(f\"Available VitalSignTypes: {[t.value for t in VitalSignType]}\")\n        vital_type = VitalSignType(data['vital_type'])\n    except ValueError as e:\n        logger.error(f\"Invalid vital sign type: {data['vital_type']}, error: {str(e)}\")\n        return jsonify({\n            \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                \"types\": \", \".join(t.value for t in VitalSignType)\n            }\n        }), 400\n    # Parse dates\n    try:\n        start_date = datetime.fromisoformat(data['start_date'].replace('Z', '+00:00'))\n    except ValueError:\n        return jsonify({\"error\": _(\"Invalid start_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    try:\n        end_date = datetime.fromisoformat(data['end_date'].replace('Z', '+00:00'))\n    except ValueError:\n        return jsonify({\"error\": _(\"Invalid end_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Validate that start date is before end date\n    if start_date &gt;= end_date:\n        return jsonify({\"error\": _(\"Start date must be before end date\")}), 400\n    # Create the observation\n    try:\n        observation = VitalObservation(\n            patient_id=patient_id,\n            doctor_id=doctor.id,\n            vital_type=vital_type,\n            content=data['content'],\n            start_date=start_date,\n            end_date=end_date\n        )\n        db.session.add(observation)\n        db.session.commit()\n        logger.info(f\"Observation added for patient {patient_id} by doctor {doctor.id}\")\n        return jsonify({\n            \"message\": _(\"Observation added successfully\"),\n            \"observation\": observation.to_dict()\n        }), 201\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error adding observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while adding the observation\")}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.update_observation","title":"<code>update_observation(doctor, observation_id)</code>","text":"<p>Update an existing vital sign observation. This endpoint allows doctors to modify their previously created observations. Only the doctor who created the observation can update it. Any fields provided in the request will be updated; omitted fields remain unchanged. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     observation_id (int): ID of the observation to update Request body:     vital_type (str, optional): New vital sign type     content (str, optional): Updated notes or interpretation     start_date (str, optional): New ISO formatted start date     end_date (str, optional): New ISO formatted end date Returns:     JSON response with the updated observation or error message Status codes:     200: Observation updated successfully     400: Invalid request data (invalid vital type, invalid dates)     403: Not authorized to modify this observation     404: Observation not found     500: Database error Response format (success):     {         \"message\": \"Observation updated successfully\",         \"observation\": {             \"id\": 123,             \"patient_id\": 42,             \"doctor_id\": 5,             \"vital_type\": \"heart_rate\",             \"content\": \"Updated interpretation of heart rate trends\",             \"start_date\": \"2023-05-01T00:00:00Z\",             \"end_date\": \"2023-05-07T23:59:59Z\",             \"created_at\": \"2023-05-08T10:15:30Z\",             \"updated_at\": \"2023-05-09T08:20:15Z\"         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/observations/&lt;int:observation_id&gt;', methods=['PUT'])\n@doctor_required\ndef update_observation(doctor, observation_id):\n    \"\"\"\n    Update an existing vital sign observation.\n    This endpoint allows doctors to modify their previously created observations.\n    Only the doctor who created the observation can update it. Any fields provided\n    in the request will be updated; omitted fields remain unchanged.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        observation_id (int): ID of the observation to update\n    Request body:\n        vital_type (str, optional): New vital sign type\n        content (str, optional): Updated notes or interpretation\n        start_date (str, optional): New ISO formatted start date\n        end_date (str, optional): New ISO formatted end date\n    Returns:\n        JSON response with the updated observation or error message\n    Status codes:\n        200: Observation updated successfully\n        400: Invalid request data (invalid vital type, invalid dates)\n        403: Not authorized to modify this observation\n        404: Observation not found\n        500: Database error\n    Response format (success):\n        {\n            \"message\": \"Observation updated successfully\",\n            \"observation\": {\n                \"id\": 123,\n                \"patient_id\": 42,\n                \"doctor_id\": 5,\n                \"vital_type\": \"heart_rate\",\n                \"content\": \"Updated interpretation of heart rate trends\",\n                \"start_date\": \"2023-05-01T00:00:00Z\",\n                \"end_date\": \"2023-05-07T23:59:59Z\",\n                \"created_at\": \"2023-05-08T10:15:30Z\",\n                \"updated_at\": \"2023-05-09T08:20:15Z\"\n            }\n        }\n    \"\"\"\n    # Find the observation\n    observation = VitalObservation.query.get(observation_id)\n    if not observation:\n        return jsonify({\"error\": _(\"Observation not found\")}), 404\n    # Check if the doctor is the creator of the observation\n    if observation.doctor_id != doctor.id:\n        return jsonify({\"error\": _(\"You are not authorized to modify this observation\")}), 403\n    # Validate request data\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON in request\")}), 400\n    data = request.json\n    # Update vital type if provided\n    if 'vital_type' in data:\n        try:\n            observation.vital_type = VitalSignType(data['vital_type'])\n        except ValueError:\n            return jsonify({\n                \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                    \"types\": \", \".join(t.value for t in VitalSignType)\n                }\n            }), 400\n    # Update content if provided\n    if 'content' in data:\n        observation.content = data['content']\n    # Update start date if provided\n    if 'start_date' in data:\n        try:\n            observation.start_date = datetime.fromisoformat(data['start_date'].replace('Z', '+00:00'))\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid start_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Update end date if provided\n    if 'end_date' in data:\n        try:\n            observation.end_date = datetime.fromisoformat(data['end_date'].replace('Z', '+00:00'))\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid end_date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Validate that start date is before end date\n    if observation.start_date &gt;= observation.end_date:\n        return jsonify({\"error\": _(\"Start date must be before end date\")}), 400\n    # Save changes\n    try:\n        observation.updated_at = datetime.utcnow()\n        db.session.commit()\n        logger.info(f\"Observation {observation_id} updated by doctor {doctor.id}\")\n        return jsonify({\n            \"message\": _(\"Observation updated successfully\"),\n            \"observation\": observation.to_dict()\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error updating observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while updating the observation\")}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.delete_observation","title":"<code>delete_observation(doctor, observation_id)</code>","text":"<p>Delete a vital sign observation. This endpoint allows doctors to delete their previously created observations. Only the doctor who created the observation can delete it. Args:     doctor: Doctor object automatically provided by the doctor_required decorator     observation_id (int): ID of the observation to delete Returns:     JSON response with success message or error message Status codes:     200: Observation deleted successfully     403: Not authorized to delete this observation     404: Observation not found     500: Database error Response format (success):     {         \"message\": \"Observation deleted successfully\"     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/observations/&lt;int:observation_id&gt;', methods=['DELETE'])\n@doctor_required\ndef delete_observation(doctor, observation_id):\n    \"\"\"\n    Delete a vital sign observation.\n    This endpoint allows doctors to delete their previously created observations.\n    Only the doctor who created the observation can delete it.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n        observation_id (int): ID of the observation to delete\n    Returns:\n        JSON response with success message or error message\n    Status codes:\n        200: Observation deleted successfully\n        403: Not authorized to delete this observation\n        404: Observation not found\n        500: Database error\n    Response format (success):\n        {\n            \"message\": \"Observation deleted successfully\"\n        }\n    \"\"\"\n    # Find the observation\n    observation = VitalObservation.query.get(observation_id)\n    if not observation:\n        return jsonify({\"error\": _(\"Observation not found\")}), 404\n    # Check if the doctor is the creator of the observation\n    if observation.doctor_id != doctor.id:\n        return jsonify({\"error\": _(\"You are not authorized to delete this observation\")}), 403\n    # Delete the observation\n    try:\n        db.session.delete(observation)\n        db.session.commit()\n        logger.info(f\"Observation {observation_id} deleted by doctor {doctor.id}\")\n        return jsonify({\n            \"message\": _(\"Observation deleted successfully\")\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error deleting observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while deleting the observation\")}), 500\n</code></pre>"},{"location":"modules/api.html#app.api.import_patient","title":"<code>import_patient(doctor)</code>","text":"<p>Import an existing patient by UUID. This endpoint allows doctors to associate themselves with existing patients in the system by providing the patient's UUID. This is useful for collaborative care where multiple doctors need access to the same patient's data. Args:     doctor: Doctor object automatically provided by the doctor_required decorator Request body:     patient_uuid (str): UUID of the patient to import Returns:     JSON response with success message and patient details or error message Status codes:     200: Patient imported successfully     400: Invalid UUID format or missing UUID     404: Patient not found     409: Patient already associated with this doctor     500: Database or server error Response format (success):     {         \"message\": \"Patient imported successfully\",         \"patient\": {             \"id\": 42,             \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",             \"first_name\": \"John\",             \"last_name\": \"Doe\",             ...         }     }</p> Source code in <code>app/api.py</code> <pre><code>@api_bp.route('/patients/import', methods=['POST'])\n@doctor_required\ndef import_patient(doctor):\n    \"\"\"\n    Import an existing patient by UUID.\n    This endpoint allows doctors to associate themselves with existing patients\n    in the system by providing the patient's UUID. This is useful for collaborative\n    care where multiple doctors need access to the same patient's data.\n    Args:\n        doctor: Doctor object automatically provided by the doctor_required decorator\n    Request body:\n        patient_uuid (str): UUID of the patient to import\n    Returns:\n        JSON response with success message and patient details or error message\n    Status codes:\n        200: Patient imported successfully\n        400: Invalid UUID format or missing UUID\n        404: Patient not found\n        409: Patient already associated with this doctor\n        500: Database or server error\n    Response format (success):\n        {\n            \"message\": \"Patient imported successfully\",\n            \"patient\": {\n                \"id\": 42,\n                \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                ...\n            }\n        }\n    \"\"\"\n    data = request.json\n    # Validate request data\n    if not data or 'patient_uuid' not in data:\n        return jsonify({\"error\": _(\"Patient UUID is required\")}), 400\n    patient_uuid = data['patient_uuid']\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is already associated with this patient\n    if patient in doctor.patients.all():\n        return jsonify({\"error\": _(\"Patient is already associated with your account\")}), 409\n    try:\n        # Add patient to doctor's patients\n        doctor_patient = DoctorPatient(doctor_id=doctor.id, patient_id=patient.id)\n        db.session.add(doctor_patient)\n        db.session.commit()\n        # Log the import action\n        log_patient_import(doctor.id, patient)\n        return jsonify({\n            \"message\": _(\"Patient imported successfully\"),\n            \"patient\": patient.to_dict()\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Database error importing patient: {str(e)}\")\n        return jsonify({\"error\": _(\"A database error occurred while importing the patient\")}), 500\n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Error importing patient: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while importing the patient\")}), 500\n</code></pre>"},{"location":"modules/app.html","title":"App","text":"<p>Flask Application Module. This module initializes and configures the Flask application and its extensions: - SQLAlchemy for database ORM - Flask-Migrate for database migrations - Flask-JWT-Extended for JSON web token authentication - Flask-Login for session-based authentication - Flask-Babel for internationalization It sets up logging, database connections, JWT authentication, user session management, localization, and registers all blueprints with the application.</p>"},{"location":"modules/app.html#app.app.logging_level","title":"<code>logging_level = os.environ.get('LOG_LEVEL', 'DEBUG').upper()</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.db","title":"<code>db = SQLAlchemy(model_class=Base)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.app","title":"<code>app = Flask(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.migrate","title":"<code>migrate = Migrate(app, db)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.jwt","title":"<code>jwt = JWTManager(app)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.login_manager","title":"<code>login_manager = LoginManager(app)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.babel","title":"<code>babel = Babel(app, locale_selector=get_locale)</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.cloud_env","title":"<code>cloud_env = os.environ.get('CLOUD_RUN_ENVIRONMENT', 'false').lower() == 'true'</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.env_type","title":"<code>env_type = 'Cloud Run' if cloud_env else 'Local'</code>  <code>module-attribute</code>","text":""},{"location":"modules/app.html#app.app.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>DeclarativeBase</code></p> Source code in <code>app/app.py</code> <pre><code>class Base(DeclarativeBase):\n    pass\n</code></pre>"},{"location":"modules/app.html#app.app.get_database_uri","title":"<code>get_database_uri()</code>","text":"<p>Configure the database connection URI based on the runtime environment. This function determines whether the application is running in a cloud environment or locally, and returns the appropriate database connection URI.  In cloud environments, it uses PostgreSQL with Unix socket connections. In local environments, it defaults to SQLite or uses the DATABASE_URL environment variable. Returns:     str: Database connection URI for SQLAlchemy Environment variables used:     CLOUD_RUN_ENVIRONMENT: \"true\" if running in cloud environment     DB_USER: Database username (cloud environment only)     DB_PASS: Database password (cloud environment only)     DB_NAME: Database name (cloud environment only)     INSTANCE_UNIX_SOCKET: Unix socket path (cloud environment only)     DATABASE_URL: Database connection string (local environment only)</p> Source code in <code>app/app.py</code> <pre><code>def get_database_uri():\n    \"\"\"\n    Configure the database connection URI based on the runtime environment.\n    This function determines whether the application is running in a cloud environment\n    or locally, and returns the appropriate database connection URI. \n    In cloud environments, it uses PostgreSQL with Unix socket connections.\n    In local environments, it defaults to SQLite or uses the DATABASE_URL environment variable.\n    Returns:\n        str: Database connection URI for SQLAlchemy\n    Environment variables used:\n        CLOUD_RUN_ENVIRONMENT: \"true\" if running in cloud environment\n        DB_USER: Database username (cloud environment only)\n        DB_PASS: Database password (cloud environment only)\n        DB_NAME: Database name (cloud environment only)\n        INSTANCE_UNIX_SOCKET: Unix socket path (cloud environment only)\n        DATABASE_URL: Database connection string (local environment only)\n    \"\"\"\n    is_cloud_environment = os.environ.get(\"CLOUD_RUN_ENVIRONMENT\", \"false\").lower() == \"true\"\n    logger.info(f\"Running in cloud environment: {is_cloud_environment}\")\n    if is_cloud_environment:\n        # Koyeb SQL with Unix socket connection\n        try:\n            db_user = os.environ[\"DB_USER\"]\n            db_pass = os.environ[\"DB_PASS\"]\n            db_name = os.environ[\"DB_NAME\"]\n            unix_socket_path = os.environ[\"INSTANCE_UNIX_SOCKET\"]\n            # PostgreSQL connection via Unix socket\n            db_uri = f\"postgresql://{db_user}:{db_pass}@{unix_socket_path}/{db_name}\"\n            logger.info(f\"Configured Koyeb SQL connection via Unix socket at {unix_socket_path}\")\n            return db_uri\n        except KeyError as e:\n            logger.error(f\"Missing required environment variable for Koyeb SQL: {e}\")\n            logger.error(\"Falling back to default connection string\")\n    # Default database connection (local environment)\n    db_uri = os.environ.get(\"DATABASE_URL\", \"sqlite:///healthcare.db\")\n    logger.info(f\"Using database connection: {db_uri}\")\n    return db_uri\n</code></pre>"},{"location":"modules/app.html#app.app.get_locale","title":"<code>get_locale()</code>","text":"<p>Determine which language to use for the current request. This function implements a language selection strategy for Flask-Babel: 1. First checks if user has explicitly set a language preference in their session 2. If no session preference exists, detects language from browser's Accept-Language header The function is used as the locale_selector for Flask-Babel to dynamically determine the appropriate language for each request. Returns:     str: Language code ('en', 'it', etc.) to use for the current request</p> Source code in <code>app/app.py</code> <pre><code>def get_locale():\n    \"\"\"\n    Determine which language to use for the current request.\n    This function implements a language selection strategy for Flask-Babel:\n    1. First checks if user has explicitly set a language preference in their session\n    2. If no session preference exists, detects language from browser's Accept-Language header\n    The function is used as the locale_selector for Flask-Babel to dynamically\n    determine the appropriate language for each request.\n    Returns:\n        str: Language code ('en', 'it', etc.) to use for the current request\n    \"\"\"\n    # First, check if user has explicitly set language in session\n    logger.debug(f\"get_locale called, session: {session}\")\n    if 'language' in session:\n        logger.debug(f\"Language from session: {session['language']}\")\n        return session['language']\n    # Otherwise, try to detect from browser settings\n    best_match = request.accept_languages.best_match(app.config['LANGUAGES'].keys())\n    logger.debug(f\"Best match from accept_languages: {best_match}\")\n    return best_match\n</code></pre>"},{"location":"modules/app.html#app.app.format_datetime","title":"<code>format_datetime(value, format='%Y-%m-%d %H:%M:%S')</code>","text":"<p>Format a datetime object to a readable string in UTC+2 timezone. This template filter is used in Jinja templates to format datetime objects consistently throughout the application. It handles timezone conversion from UTC to UTC+2 (Central European Time) and applies the specified format. Args:     value (datetime): The datetime object to format     format (str, optional): Format string using Python's strftime format codes.                             Defaults to '%Y-%m-%d %H:%M:%S'. Returns:     str: Formatted datetime string in UTC+2 timezone, or empty string if value is None Example usage in template:     {{ patient.created_at|format_datetime('%d %b %Y') }}</p> Source code in <code>app/app.py</code> <pre><code>@app.template_filter('format_datetime')\ndef format_datetime(value, format='%Y-%m-%d %H:%M:%S'):\n    \"\"\"\n    Format a datetime object to a readable string in UTC+2 timezone.\n    This template filter is used in Jinja templates to format datetime objects\n    consistently throughout the application. It handles timezone conversion\n    from UTC to UTC+2 (Central European Time) and applies the specified format.\n    Args:\n        value (datetime): The datetime object to format\n        format (str, optional): Format string using Python's strftime format codes.\n                                Defaults to '%Y-%m-%d %H:%M:%S'.\n    Returns:\n        str: Formatted datetime string in UTC+2 timezone, or empty string if value is None\n    Example usage in template:\n        {{ patient.created_at|format_datetime('%d %b %Y') }}\n    \"\"\"\n    if value is None:\n        return \"\"\n    # Define the UTC+2 timezone\n    utc_plus_2 = timezone(timedelta(hours=2))\n    # If the value has no timezone, assume it's UTC\n    if value.tzinfo is None:\n        value = value.replace(tzinfo=timezone.utc)\n    # Convert to UTC+2\n    value = value.astimezone(utc_plus_2)\n    return value.strftime(format)\n</code></pre>"},{"location":"modules/app.html#app.app.inject_globals","title":"<code>inject_globals()</code>","text":"<p>Inject global variables into all templates. This context processor makes certain variables available to all templates without having to explicitly pass them in each render_template call. This ensures consistency and reduces repetitive code in route handlers. Variables injected:     now (datetime): Current datetime, useful for displaying current time                    or calculating relative time differences in templates Returns:     dict: Dictionary of variables to inject into template context</p> Source code in <code>app/app.py</code> <pre><code>@app.context_processor\ndef inject_globals():\n    \"\"\"\n    Inject global variables into all templates.\n    This context processor makes certain variables available to all templates\n    without having to explicitly pass them in each render_template call.\n    This ensures consistency and reduces repetitive code in route handlers.\n    Variables injected:\n        now (datetime): Current datetime, useful for displaying current time\n                       or calculating relative time differences in templates\n    Returns:\n        dict: Dictionary of variables to inject into template context\n    \"\"\"\n    return {\n        'now': datetime.now()\n    }\n</code></pre>"},{"location":"modules/app.html#app.app.load_user","title":"<code>load_user(user_id)</code>","text":"<p>Load a user from the database for Flask-Login. This function is required by Flask-Login to load a user object from the database based on the user ID stored in the session. It's called automatically by Flask-Login when a page requires authentication. Args:     user_id (str): The ID of the user to load, as a string Returns:     Doctor: The Doctor object if found, or None if not found</p> Source code in <code>app/app.py</code> <pre><code>@login_manager.user_loader\ndef load_user(user_id):\n    \"\"\"\n    Load a user from the database for Flask-Login.\n    This function is required by Flask-Login to load a user object from the database\n    based on the user ID stored in the session. It's called automatically by\n    Flask-Login when a page requires authentication.\n    Args:\n        user_id (str): The ID of the user to load, as a string\n    Returns:\n        Doctor: The Doctor object if found, or None if not found\n    \"\"\"\n    return Doctor.query.get(int(user_id))\n</code></pre>"},{"location":"modules/app.html#app.app.health_check","title":"<code>health_check()</code>","text":"<p>Health check endpoint for monitoring system health. This endpoint is used by Cloud Run, Kubernetes, or other orchestration systems to determine if the application is healthy and ready to receive traffic. It performs a basic check by testing database connectivity. Returns:     tuple: JSON response with health status and HTTP status code         - 200 OK with system information if healthy         - 500 Internal Server Error with error details if unhealthy Response format (healthy):     {         \"status\": \"healthy\",         \"environment\": \"Cloud Run\" or \"Local\",         \"timestamp\": \"2023-05-01T12:34:56.789Z\",         \"version\": \"0.1.0\"     } Response format (unhealthy):     {         \"status\": \"unhealthy\",         \"error\": \"Error message\",         \"timestamp\": \"2023-05-01T12:34:56.789Z\"     }</p> Source code in <code>app/app.py</code> <pre><code>@app.route('/healthz', methods=['GET'])\ndef health_check():\n    \"\"\"\n    Health check endpoint for monitoring system health.\n    This endpoint is used by Cloud Run, Kubernetes, or other orchestration systems\n    to determine if the application is healthy and ready to receive traffic.\n    It performs a basic check by testing database connectivity.\n    Returns:\n        tuple: JSON response with health status and HTTP status code\n            - 200 OK with system information if healthy\n            - 500 Internal Server Error with error details if unhealthy\n    Response format (healthy):\n        {\n            \"status\": \"healthy\",\n            \"environment\": \"Cloud Run\" or \"Local\",\n            \"timestamp\": \"2023-05-01T12:34:56.789Z\",\n            \"version\": \"0.1.0\"\n        }\n    Response format (unhealthy):\n        {\n            \"status\": \"unhealthy\",\n            \"error\": \"Error message\",\n            \"timestamp\": \"2023-05-01T12:34:56.789Z\"\n        }\n    \"\"\"\n    try:\n        # Check database connection\n        with db.engine.connect() as conn:\n            conn.execute(text(\"SELECT 1\"))\n        # Basic system info\n        cloud_env = os.environ.get(\"CLOUD_RUN_ENVIRONMENT\", \"false\").lower() == \"true\"\n        env_type = \"Cloud Run\" if cloud_env else \"Local\"\n        return {\n            \"status\": \"healthy\",\n            \"environment\": env_type,\n            \"timestamp\": datetime.now().isoformat(),\n            \"version\": \"0.1.0\"\n        }, 200\n    except Exception as e:\n        logger.error(f\"Health check failed: {e}\")\n        return {\n            \"status\": \"unhealthy\",\n            \"error\": str(e),\n            \"timestamp\": datetime.now().isoformat()\n        }, 500\n</code></pre>"},{"location":"modules/audit.html","title":"Audit","text":"<p>Audit Logging Module. This module provides functionality for tracking and logging user actions in the system. It includes routes for viewing audit logs and utility functions for recording various types of actions (patient creation, updates, deletions, report generation, etc.). The audit system helps maintain a complete history of all changes made in the application, which is essential for healthcare applications that require high levels of data integrity and traceability.</p>"},{"location":"modules/audit.html#app.audit.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Logger instance for the audit module. This logger is used throughout the audit module to record application-level logs related to audit operations, particularly focusing on error conditions during audit logging operations.</p>"},{"location":"modules/audit.html#app.audit.audit_bp","title":"<code>audit_bp = Blueprint('audit', __name__)</code>  <code>module-attribute</code>","text":"<p>Flask Blueprint for audit-related routes. This Blueprint defines routes for viewing and accessing audit logs, providing functionality for tracking and monitoring user actions within the VitaLink application.</p>"},{"location":"modules/audit.html#app.audit.view_logs","title":"<code>view_logs()</code>","text":"<p>View all audit logs for the current doctor. This route handler renders a page displaying all audit logs associated with the currently logged-in doctor, ordered by timestamp (most recent first). The audit logs provide a comprehensive history of all actions performed by the doctor within the system. Decorators:     login_required: Ensures that only authenticated users can access this route     doctor_required: Ensures that only users with doctor role can access this route Returns:     Response: Rendered HTML page containing all audit logs for the current doctor</p> Source code in <code>app/audit.py</code> <pre><code>@audit_bp.route('/audit-logs')\n@login_required\n@doctor_required\ndef view_logs():\n    \"\"\"\n    View all audit logs for the current doctor.\n    This route handler renders a page displaying all audit logs associated with the currently\n    logged-in doctor, ordered by timestamp (most recent first). The audit logs provide\n    a comprehensive history of all actions performed by the doctor within the system.\n    Decorators:\n        login_required: Ensures that only authenticated users can access this route\n        doctor_required: Ensures that only users with doctor role can access this route\n    Returns:\n        Response: Rendered HTML page containing all audit logs for the current doctor\n    \"\"\"\n    # Get all audit logs for the current doctor, ordered by timestamp (most recent first)\n    logs = AuditLog.query.filter_by(doctor_id=current_user.id).order_by(\n        AuditLog.timestamp.desc()\n    ).all()\n    return render_template('audit_logs.html', logs=logs)\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_action","title":"<code>log_action(doctor_id, action_type, entity_type, entity_id, details=None, patient_id=None)</code>","text":"<p>Create a new audit log entry in the system. This is the core function of the audit system that records all actions performed within the VitaLink application. It captures who performed an action (doctor), what action was performed, which entity was affected, when it happened, and  additional contextual information. Args:     doctor_id (int): ID of the doctor who performed the action     action_type (ActionType): Type of action performed (CREATE, UPDATE, DELETE, VIEW, etc.)     entity_type (EntityType): Type of entity affected (PATIENT, NOTE, REPORT, etc.)     entity_id (int): ID of the entity affected by the action     details (dict, optional): Additional details about the action in dictionary format,                              useful for storing contextual information     patient_id (int, optional): ID of the patient related to the action (for easier querying)                                and for organizing logs by patient Returns:     AuditLog: The created audit log entry object or None if an error occurs during creation Note:     - The function automatically captures the IP address of the request if available     - If entity_id is None, it will use a temporary default value (0)     - Any exceptions during log creation are caught to prevent disruption to the main application flow</p> Source code in <code>app/audit.py</code> <pre><code>def log_action(doctor_id, action_type, entity_type, entity_id, details=None, patient_id=None):\n    \"\"\"\n    Create a new audit log entry in the system.\n    This is the core function of the audit system that records all actions performed\n    within the VitaLink application. It captures who performed an action (doctor),\n    what action was performed, which entity was affected, when it happened, and \n    additional contextual information.\n    Args:\n        doctor_id (int): ID of the doctor who performed the action\n        action_type (ActionType): Type of action performed (CREATE, UPDATE, DELETE, VIEW, etc.)\n        entity_type (EntityType): Type of entity affected (PATIENT, NOTE, REPORT, etc.)\n        entity_id (int): ID of the entity affected by the action\n        details (dict, optional): Additional details about the action in dictionary format,\n                                 useful for storing contextual information\n        patient_id (int, optional): ID of the patient related to the action (for easier querying)\n                                   and for organizing logs by patient\n    Returns:\n        AuditLog: The created audit log entry object or None if an error occurs during creation\n    Note:\n        - The function automatically captures the IP address of the request if available\n        - If entity_id is None, it will use a temporary default value (0)\n        - Any exceptions during log creation are caught to prevent disruption to the main application flow\n    \"\"\"\n    try:\n        # Check that entity_id is not None to avoid \"not-null constraint\" error\n        if entity_id is None:\n            # If ID is None, use a temporary default value\n            # In a production system, we should handle this differently\n            entity_id = 0\n            print(f\"WARNING: entity_id is None for {entity_type}. Using temporary ID 0.\")\n        ip_address = request.remote_addr if request else None\n        # Log the params for debugging\n        print(f\"DEBUG: log_action - doctor_id={doctor_id}, action_type={action_type}, entity_type={entity_type}, entity_id={entity_id}\")\n        audit_log = AuditLog(\n            doctor_id=doctor_id,\n            action_type=action_type,\n            entity_type=entity_type,\n            entity_id=entity_id,\n            details=details,\n            patient_id=patient_id,\n            ip_address=ip_address\n        )\n        db.session.add(audit_log)\n        db.session.commit()\n        return audit_log\n    except Exception as e:\n        # In case of error, perform rollback and log the error\n        db.session.rollback()\n        import traceback\n        print(f\"Error in log_action: {str(e)}\")\n        print(f\"Parameters: doctor_id={doctor_id}, action_type={action_type}, entity_type={entity_type}, entity_id={entity_id}\")\n        print(traceback.format_exc())\n        # Don't let the entire operation fail if logging fails\n        return None\n</code></pre>"},{"location":"modules/audit.html#app.audit.get_audit_logs","title":"<code>get_audit_logs()</code>","text":"<p>Get audit logs filtered by various parameters. This endpoint retrieves audit logs based on provided filter criteria and returns them either as HTML or JSON depending on the requested format. It provides a  comprehensive search and filtering system for audit trails. Supports filtering by:     - Date range (start_date, end_date)     - Doctor (doctor_id)     - Patient (patient_id)     - Action type (create, update, delete, etc.)     - Entity type (patient, note, report, etc.) Args (from request.args):     start_date (str, optional): Start date for filtering logs (format: YYYY-MM-DD)     end_date (str, optional): End date for filtering logs (format: YYYY-MM-DD)     doctor_id (str, optional): ID of doctor whose actions should be included     patient_id (str, optional): ID of patient whose records were affected     action_type (str, optional): Type of action to filter by     entity_type (str, optional): Type of entity to filter by     format (str, optional): Response format, either 'html' (default) or 'json' Returns:     Response: Either a rendered HTML template with filtered logs or a JSON response              containing the filtered logs, depending on the format parameter Decorators:     login_required: Ensures that only authenticated users can access this endpoint     doctor_required: Ensures that only users with doctor role can access this endpoint</p> Source code in <code>app/audit.py</code> <pre><code>@audit_bp.route('/logs', methods=['GET'])\n@login_required\n@doctor_required\ndef get_audit_logs():\n    \"\"\"\n    Get audit logs filtered by various parameters.\n    This endpoint retrieves audit logs based on provided filter criteria and returns\n    them either as HTML or JSON depending on the requested format. It provides a \n    comprehensive search and filtering system for audit trails.\n    Supports filtering by:\n        - Date range (start_date, end_date)\n        - Doctor (doctor_id)\n        - Patient (patient_id)\n        - Action type (create, update, delete, etc.)\n        - Entity type (patient, note, report, etc.)\n    Args (from request.args):\n        start_date (str, optional): Start date for filtering logs (format: YYYY-MM-DD)\n        end_date (str, optional): End date for filtering logs (format: YYYY-MM-DD)\n        doctor_id (str, optional): ID of doctor whose actions should be included\n        patient_id (str, optional): ID of patient whose records were affected\n        action_type (str, optional): Type of action to filter by\n        entity_type (str, optional): Type of entity to filter by\n        format (str, optional): Response format, either 'html' (default) or 'json'\n    Returns:\n        Response: Either a rendered HTML template with filtered logs or a JSON response\n                 containing the filtered logs, depending on the format parameter\n    Decorators:\n        login_required: Ensures that only authenticated users can access this endpoint\n        doctor_required: Ensures that only users with doctor role can access this endpoint\n    \"\"\"\n    # Get query parameters\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    doctor_id = request.args.get('doctor_id')\n    patient_id = request.args.get('patient_id')\n    action_type = request.args.get('action_type')\n    entity_type = request.args.get('entity_type')\n    format_type = request.args.get('format', 'html')  # Default to HTML\n    # Start building the query\n    query = AuditLog.query\n    # Apply filters\n    if start_date:\n        try:\n            start_date_obj = datetime.strptime(start_date, '%Y-%m-%d')\n            query = query.filter(AuditLog.timestamp &gt;= start_date_obj)\n        except ValueError:\n            pass\n    if end_date:\n        try:\n            end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')\n            # Add one day to include the whole end date\n            end_date_obj = end_date_obj + timedelta(days=1)\n            query = query.filter(AuditLog.timestamp &lt; end_date_obj)\n        except ValueError:\n            pass\n    if doctor_id:\n        query = query.filter_by(doctor_id=doctor_id)\n    if patient_id:\n        query = query.filter_by(patient_id=patient_id)\n    # Get list of patients and doctors for filter dropdowns\n    patients = Patient.query.join(\n        DoctorPatient, Patient.id == DoctorPatient.patient_id\n    ).filter(\n        DoctorPatient.doctor_id == current_user.id\n    ).all()\n    # For admin users, show all doctors. For regular doctors, only show themselves\n    doctors = [current_user]\n    if action_type:\n        # Ottieni i valori delle enum dal database\n        try:\n            existing_action_types = db.session.query(db.distinct(AuditLog.action_type)).all()\n            existing_action_types = [action_type[0].value.upper() for action_type in existing_action_types]\n            if action_type.upper() in existing_action_types:\n                # Mappa diretta dai valori delle stringhe agli enum\n                action_map = {\n                    'CREATE': ActionType.CREATE,\n                    'UPDATE': ActionType.UPDATE,\n                    'DELETE': ActionType.DELETE,\n                    'VIEW': ActionType.VIEW,\n                    'EXPORT': ActionType.EXPORT,\n                    'GENERATE_LINK': ActionType.GENERATE_LINK,\n                    'CONNECT': ActionType.CONNECT,\n                    'DISCONNECT': ActionType.DISCONNECT,\n                    'SYNC': ActionType.SYNC\n                }\n                # Filtro solo se esiste nel database\n                query = query.filter_by(action_type=action_map[action_type.upper()])\n            else:\n                # Se il valore non esiste, restituisci un insieme vuoto (nessun risultato)\n                # invece di generare un errore\n                return render_template(\n                    'audit_logs.html',\n                    logs=[],\n                    patients=patients,\n                    doctors=doctors,\n                    request=request,\n                    current_user=current_user,\n                    now=datetime.now()\n                )\n        except Exception as e:\n            # In caso di errore, restituisci un insieme vuoto\n            return render_template(\n                'audit_logs.html',\n                logs=[],\n                patients=patients,\n                doctors=doctors,\n                request=request,\n                current_user=current_user,\n                now=datetime.now(),\n                message=_(\"Error during action filtering: %(error)s\") % {\"error\": str(e)}\n            )\n    if entity_type:\n        # Ottieni i valori delle enum dal database\n        try:\n            existing_entity_types = db.session.query(db.distinct(AuditLog.entity_type)).all()\n            existing_entity_types = [entity_type[0].value.upper() for entity_type in existing_entity_types]\n            if entity_type.upper() in existing_entity_types:\n                # Mappa diretta dai valori delle stringhe agli enum\n                entity_map = {\n                    'PATIENT': EntityType.PATIENT,\n                    'NOTE': EntityType.NOTE,\n                    'REPORT': EntityType.REPORT,\n                    'HEALTH_PLATFORM': EntityType.HEALTH_PLATFORM,\n                    'HEALTH_LINK': EntityType.HEALTH_LINK,\n                    'OBSERVATION': EntityType.OBSERVATION,\n                    'VITAL_SIGN': EntityType.VITAL_SIGN\n                }\n                # Filtro solo se esiste nel database\n                query = query.filter_by(entity_type=entity_map[entity_type.upper()])\n            else:\n                # Se il valore non esiste, restituisci un insieme vuoto\n                return render_template(\n                    'audit_logs.html',\n                    logs=[],\n                    patients=patients,\n                    doctors=doctors,\n                    request=request,\n                    current_user=current_user,\n                    now=datetime.now()\n                )\n        except Exception as e:\n            # In case of error, return an empty set\n            return render_template(\n                'audit_logs.html',\n                logs=[],\n                patients=patients,\n                doctors=doctors,\n                request=request,\n                current_user=current_user,\n                now=datetime.now(),\n                message=_(\"Error during entity filtering: %(error)s\") % {\"error\": str(e)}\n            )\n    # Get results ordered by timestamp (most recent first)\n    logs = query.order_by(AuditLog.timestamp.desc()).all()\n    # If format is JSON, return JSON response\n    if format_type == 'json':\n        # Convert to dictionaries for JSON response\n        log_list = [log.to_dict() for log in logs]\n        return jsonify({\n            'status': 'success',\n            'count': len(log_list),\n            'logs': log_list\n        })\n    # Otherwise, render HTML template\n    # Get list of patients and doctors for filter dropdowns\n    patients = Patient.query.join(\n        DoctorPatient, Patient.id == DoctorPatient.patient_id\n    ).filter(\n        DoctorPatient.doctor_id == current_user.id\n    ).all()\n    # For admin users, show all doctors. For regular doctors, only show themselves\n    # Note: this is simplified as we don't have admin roles yet, but preparing for future\n    doctors = [current_user]\n    # In the future, if admin roles are implemented:\n    # if current_user.is_admin:\n    #     doctors = Doctor.query.all()\n    # Render the audit logs template\n    return render_template(\n        'audit_logs.html',\n        logs=[log.to_dict() for log in logs],  # log.to_dict() already includes doctor_name and patient_name\n        patients=patients,\n        doctors=doctors,\n        request=request,\n        current_user=current_user,\n        now=datetime.now()\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.get_audit_stats","title":"<code>get_audit_stats()</code>","text":"<p>Get comprehensive statistics derived from audit logs. This endpoint analyzes audit log data and generates various statistical insights that can be used for monitoring system usage, identifying patterns, and ensuring compliance with usage policies. Statistics generated include:     - Total number of actions by type (create, update, delete, etc.)     - Actions by entity type (patient, note, report, etc.)     - Top doctors by activity level     - Most accessed patients     - Activity timeline showing actions per day Args (from request.args):     days (int, optional): Number of days to include in the statistics (default: 30) Returns:     Response: JSON response containing the various statistics categories Decorators:     login_required: Ensures that only authenticated users can access this endpoint     doctor_required: Ensures that only users with doctor role can access this endpoint Note:     The timeline is limited to a maximum of 30 days regardless of the days parameter     to ensure reasonable response size and performance.</p> Source code in <code>app/audit.py</code> <pre><code>@audit_bp.route('/logs/stats', methods=['GET'])\n@login_required\n@doctor_required\ndef get_audit_stats():\n    \"\"\"\n    Get comprehensive statistics derived from audit logs.\n    This endpoint analyzes audit log data and generates various statistical insights\n    that can be used for monitoring system usage, identifying patterns, and ensuring\n    compliance with usage policies.\n    Statistics generated include:\n        - Total number of actions by type (create, update, delete, etc.)\n        - Actions by entity type (patient, note, report, etc.)\n        - Top doctors by activity level\n        - Most accessed patients\n        - Activity timeline showing actions per day\n    Args (from request.args):\n        days (int, optional): Number of days to include in the statistics (default: 30)\n    Returns:\n        Response: JSON response containing the various statistics categories\n    Decorators:\n        login_required: Ensures that only authenticated users can access this endpoint\n        doctor_required: Ensures that only users with doctor role can access this endpoint\n    Note:\n        The timeline is limited to a maximum of 30 days regardless of the days parameter\n        to ensure reasonable response size and performance.\n    \"\"\"\n    # Time period filter\n    days = request.args.get('days', default=30, type=int)\n    start_date = datetime.utcnow() - timedelta(days=days)\n    # Base query for the time period\n    base_query = AuditLog.query.filter(AuditLog.timestamp &gt;= start_date)\n      # Count actions by type\n    action_stats = []\n    # Get only the action types that exist in the database to avoid InvalidTextRepresentation errors\n    existing_action_types = db.session.query(db.distinct(AuditLog.action_type)).all()\n    existing_action_types = [action_type[0] for action_type in existing_action_types]\n    for action_type in existing_action_types:\n        count = base_query.filter_by(action_type=action_type).count()\n        if count &gt; 0:\n            # Se action_type \u00e8 gi\u00e0 una stringa, usarla direttamente\n            # altrimenti se \u00e8 un enum, accedere alla propriet\u00e0 value\n            action_type_value = action_type\n            if hasattr(action_type, 'value'):\n                action_type_value = action_type.value\n            action_stats.append({\n                'type': action_type_value,\n                'count': count\n            })\n    # Count actions by entity type\n    entity_stats = []\n    # Same approach for entity types\n    existing_entity_types = db.session.query(db.distinct(AuditLog.entity_type)).all()\n    existing_entity_types = [entity_type[0] for entity_type in existing_entity_types]\n    for entity_type in existing_entity_types:\n        count = base_query.filter_by(entity_type=entity_type).count()\n        if count &gt; 0:\n            # Se entity_type \u00e8 gi\u00e0 una stringa, usarla direttamente\n            # altrimenti se \u00e8 un enum, accedere alla propriet\u00e0 value\n            entity_type_value = entity_type\n            if hasattr(entity_type, 'value'):\n                entity_type_value = entity_type.value\n            entity_stats.append({\n                'type': entity_type_value,\n                'count': count\n            })\n    # Top doctors by activity\n    doctor_stats = db.session.query(\n        AuditLog.doctor_id,\n        Doctor.first_name,\n        Doctor.last_name,\n        db.func.count(AuditLog.id).label('action_count')\n    ).join(Doctor).filter(\n        AuditLog.timestamp &gt;= start_date\n    ).group_by(\n        AuditLog.doctor_id,\n        Doctor.first_name,\n        Doctor.last_name\n    ).order_by(\n        db.desc('action_count')\n    ).limit(5).all()\n    doctor_activity = [{\n        'doctor_id': doctor_id,\n        'name': f\"{first_name} {last_name}\",\n        'action_count': action_count\n    } for doctor_id, first_name, last_name, action_count in doctor_stats]\n    # Most accessed patients\n    patient_stats = db.session.query(\n        AuditLog.patient_id,\n        Patient.first_name,\n        Patient.last_name,\n        db.func.count(AuditLog.id).label('access_count')\n    ).join(Patient).filter(\n        AuditLog.timestamp &gt;= start_date,\n        AuditLog.patient_id != None  # Equivalent to \"is not None\"\n    ).group_by(\n        AuditLog.patient_id,\n        Patient.first_name,\n        Patient.last_name\n    ).order_by(\n        db.desc('access_count')\n    ).limit(5).all()\n    patient_activity = [{\n        'patient_id': patient_id,\n        'name': f\"{first_name} {last_name}\",\n        'access_count': access_count\n    } for patient_id, first_name, last_name, access_count in patient_stats]\n    # Activity timeline (actions per day)\n    timeline_days = min(days, 30)  # Limit to 30 days for timeline\n    timeline_start = datetime.utcnow() - timedelta(days=timeline_days)\n    # Generate date labels for the past N days\n    date_labels = [(timeline_start + timedelta(days=i)).strftime('%Y-%m-%d') \n                  for i in range(timeline_days + 1)]\n    # Initialize counts with zeros\n    date_counts = {date: 0 for date in date_labels}\n    # Query actions grouped by date\n    timeline_data = db.session.query(\n        db.func.date(AuditLog.timestamp).label('date'),\n        db.func.count(AuditLog.id).label('count')\n    ).filter(\n        AuditLog.timestamp &gt;= timeline_start\n    ).group_by(\n        'date'\n    ).all()\n      # Fill in the actual counts\n    for date_str, count in timeline_data:\n        # Se date_str \u00e8 gi\u00e0 una stringa, usarla direttamente\n        # altrimenti, se \u00e8 un oggetto datetime, formattarlo come stringa\n        if isinstance(date_str, str):\n            date_key = date_str\n        else:\n            date_key = date_str.strftime('%Y-%m-%d')\n        if date_key in date_counts:\n            date_counts[date_key] = count\n    # Format for chart display\n    timeline = {\n        'labels': date_labels,\n        'counts': [date_counts[date] for date in date_labels]\n    }\n    return jsonify({\n        'status': 'success',\n        'period_days': days,\n        'action_stats': action_stats,\n        'entity_stats': entity_stats,\n        'doctor_activity': doctor_activity,\n        'patient_activity': patient_activity,\n        'timeline': timeline\n    })\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_patient_creation","title":"<code>log_patient_creation(doctor_id, patient)</code>","text":"<p>Log the creation of a new patient record. This convenience function creates an audit log entry when a doctor creates a new patient record in the system. Args:     doctor_id (int): ID of the doctor who created the patient     patient (Patient): The Patient object that was created Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     This function uses log_action internally, setting appropriate action_type     and entity_type values for patient creation events.</p> Source code in <code>app/audit.py</code> <pre><code>def log_patient_creation(doctor_id, patient):\n    \"\"\"\n    Log the creation of a new patient record.\n    This convenience function creates an audit log entry when a doctor creates\n    a new patient record in the system.\n    Args:\n        doctor_id (int): ID of the doctor who created the patient\n        patient (Patient): The Patient object that was created\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        This function uses log_action internally, setting appropriate action_type\n        and entity_type values for patient creation events.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details=patient.to_dict(),\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_patient_update","title":"<code>log_patient_update(doctor_id, patient, old_data)</code>","text":"<p>Log the update of an existing patient record. This convenience function creates an audit log entry when a doctor updates information in a patient record, storing both the previous and new states. Args:     doctor_id (int): ID of the doctor who updated the patient record     patient (Patient): The Patient object with updated information     old_data (dict): Dictionary containing the patient's data before the update Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The details field of the audit log contains both 'old' and 'new' states     for comparison and historical tracking purposes.</p> Source code in <code>app/audit.py</code> <pre><code>def log_patient_update(doctor_id, patient, old_data):\n    \"\"\"\n    Log the update of an existing patient record.\n    This convenience function creates an audit log entry when a doctor updates\n    information in a patient record, storing both the previous and new states.\n    Args:\n        doctor_id (int): ID of the doctor who updated the patient record\n        patient (Patient): The Patient object with updated information\n        old_data (dict): Dictionary containing the patient's data before the update\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The details field of the audit log contains both 'old' and 'new' states\n        for comparison and historical tracking purposes.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.UPDATE,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details={\n            'old': old_data,\n            'new': patient.to_dict()\n        },\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_patient_delete","title":"<code>log_patient_delete(doctor_id, patient)</code>","text":"<p>Log the deletion of a patient record. This convenience function creates an audit log entry when a doctor deletes a patient record from the system, preserving the patient information for audit purposes even after deletion. Args:     doctor_id (int): ID of the doctor who deleted the patient record     patient (Patient): The Patient object being deleted Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The complete patient data is stored in the details field to maintain     a record of the deleted information for compliance and audit purposes.</p> Source code in <code>app/audit.py</code> <pre><code>def log_patient_delete(doctor_id, patient):\n    \"\"\"\n    Log the deletion of a patient record.\n    This convenience function creates an audit log entry when a doctor deletes\n    a patient record from the system, preserving the patient information for\n    audit purposes even after deletion.\n    Args:\n        doctor_id (int): ID of the doctor who deleted the patient record\n        patient (Patient): The Patient object being deleted\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The complete patient data is stored in the details field to maintain\n        a record of the deleted information for compliance and audit purposes.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.DELETE,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details=patient.to_dict(),\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_vital_creation","title":"<code>log_vital_creation(doctor_id, vital)</code>","text":"<p>Log the creation of a vital sign record. This convenience function creates an audit log entry when a doctor or system adds a new vital sign measurement to a patient's record. Args:     doctor_id (int): ID of the doctor who created the vital sign record     vital (VitalSign): The VitalSign object that was created Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The patient_id is automatically extracted from the vital sign object     to enable filtering audit logs by patient.</p> Source code in <code>app/audit.py</code> <pre><code>def log_vital_creation(doctor_id, vital):\n    \"\"\"\n    Log the creation of a vital sign record.\n    This convenience function creates an audit log entry when a doctor or system\n    adds a new vital sign measurement to a patient's record.\n    Args:\n        doctor_id (int): ID of the doctor who created the vital sign record\n        vital (VitalSign): The VitalSign object that was created\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The patient_id is automatically extracted from the vital sign object\n        to enable filtering audit logs by patient.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.VITAL_SIGN,\n        entity_id=vital.id,\n        details=vital.to_dict(),\n        patient_id=vital.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_note_creation","title":"<code>log_note_creation(doctor_id, note)</code>","text":"<p>Log the creation of a clinical note. This convenience function creates an audit log entry when a doctor adds a new clinical note to a patient's medical record. Args:     doctor_id (int): ID of the doctor who created the note     note (Note): The Note object that was created Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     Clinical notes are important medical record entries that may contain     observations, assessments, and treatment plans. Their creation is     tracked for medical and legal compliance purposes.</p> Source code in <code>app/audit.py</code> <pre><code>def log_note_creation(doctor_id, note):\n    \"\"\"\n    Log the creation of a clinical note.\n    This convenience function creates an audit log entry when a doctor adds\n    a new clinical note to a patient's medical record.\n    Args:\n        doctor_id (int): ID of the doctor who created the note\n        note (Note): The Note object that was created\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        Clinical notes are important medical record entries that may contain\n        observations, assessments, and treatment plans. Their creation is\n        tracked for medical and legal compliance purposes.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.NOTE,\n        entity_id=note.id,\n        details=note.to_dict(),\n        patient_id=note.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_report_generation","title":"<code>log_report_generation(doctor_id, patient_id, report_type, params=None)</code>","text":"<p>Log the generation of a medical report. This convenience function creates an audit log entry when a doctor generates a report from patient data, such as a vital signs summary, progress report, or other clinical document. Args:     doctor_id (int): ID of the doctor who generated the report     patient_id (int): ID of the patient the report is about     report_type (str): Type or name of the report being generated     params (dict, optional): Parameters used for report generation such as                            date ranges, included data types, etc. Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     Since reports don't have persistent IDs in the database, a placeholder     value of 0 is used for the entity_id.</p> Source code in <code>app/audit.py</code> <pre><code>def log_report_generation(doctor_id, patient_id, report_type, params=None):\n    \"\"\"\n    Log the generation of a medical report.\n    This convenience function creates an audit log entry when a doctor generates\n    a report from patient data, such as a vital signs summary, progress report,\n    or other clinical document.\n    Args:\n        doctor_id (int): ID of the doctor who generated the report\n        patient_id (int): ID of the patient the report is about\n        report_type (str): Type or name of the report being generated\n        params (dict, optional): Parameters used for report generation such as\n                               date ranges, included data types, etc.\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        Since reports don't have persistent IDs in the database, a placeholder\n        value of 0 is used for the entity_id.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.EXPORT,\n        entity_type=EntityType.REPORT,\n        entity_id=0,  # Reports don't have IDs, using 0 as placeholder\n        details={\n            'report_type': report_type,\n            'params': params or {}\n        },\n        patient_id=patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_patient_view","title":"<code>log_patient_view(doctor_id, patient_id)</code>","text":"<p>Log when a doctor views a patient's record. This convenience function creates an audit log entry when a doctor accesses or views a patient's medical record. This is important for privacy compliance and access tracking in healthcare systems. Args:     doctor_id (int): ID of the doctor who viewed the patient record     patient_id (int): ID of the patient whose record was viewed Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     Patient record viewing is tracked separately from other operations as     it's a common compliance requirement in healthcare systems to monitor     who has accessed patient information.</p> Source code in <code>app/audit.py</code> <pre><code>def log_patient_view(doctor_id, patient_id):\n    \"\"\"\n    Log when a doctor views a patient's record.\n    This convenience function creates an audit log entry when a doctor accesses\n    or views a patient's medical record. This is important for privacy compliance\n    and access tracking in healthcare systems.\n    Args:\n        doctor_id (int): ID of the doctor who viewed the patient record\n        patient_id (int): ID of the patient whose record was viewed\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        Patient record viewing is tracked separately from other operations as\n        it's a common compliance requirement in healthcare systems to monitor\n        who has accessed patient information.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.VIEW,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient_id,\n        patient_id=patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_health_link_creation","title":"<code>log_health_link_creation(doctor_id, link)</code>","text":"<p>Log the creation of a health platform connection link. This convenience function creates an audit log entry when a doctor generates a link that allows a patient to connect their external health platform  (like Fitbit, Apple Health, etc.) to the VitaLink system. Args:     doctor_id (int): ID of the doctor who generated the link     link (HealthPlatformLink): The HealthPlatformLink object that was created Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The details field includes information about the platform type and     link expiration date for tracking purposes.</p> Source code in <code>app/audit.py</code> <pre><code>def log_health_link_creation(doctor_id, link):\n    \"\"\"\n    Log the creation of a health platform connection link.\n    This convenience function creates an audit log entry when a doctor generates\n    a link that allows a patient to connect their external health platform \n    (like Fitbit, Apple Health, etc.) to the VitaLink system.\n    Args:\n        doctor_id (int): ID of the doctor who generated the link\n        link (HealthPlatformLink): The HealthPlatformLink object that was created\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The details field includes information about the platform type and\n        link expiration date for tracking purposes.\n    \"\"\"    # Gestione sia di enum HealthPlatform che di stringhe\n    if hasattr(link.platform, 'value'):\n        platform_value = link.platform.value\n    else:\n        platform_value = link.platform\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.GENERATE_LINK,\n        entity_type=EntityType.HEALTH_LINK,\n        entity_id=link.id,\n        details={\n            'platform': platform_value,\n            'expires_at': link.expires_at.isoformat() if link.expires_at else None\n        },\n        patient_id=link.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_platform_connection","title":"<code>log_platform_connection(doctor_id, patient, platform_name)</code>","text":"<p>Log when a patient connects an external health platform to VitaLink. This convenience function creates an audit log entry when a patient successfully connects their external health platform account (like Fitbit, Google Fit, etc.) to the VitaLink system, enabling data sharing. Args:     doctor_id (int): ID of the doctor who initiated or supervised the connection     patient (Patient): The Patient object whose account is being connected     platform_name (str): Name of the external health platform being connected Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     Since platforms don't have distinct IDs in the system, a placeholder     value of 0 is used for the entity_id.</p> Source code in <code>app/audit.py</code> <pre><code>def log_platform_connection(doctor_id, patient, platform_name):\n    \"\"\"\n    Log when a patient connects an external health platform to VitaLink.\n    This convenience function creates an audit log entry when a patient successfully\n    connects their external health platform account (like Fitbit, Google Fit, etc.)\n    to the VitaLink system, enabling data sharing.\n    Args:\n        doctor_id (int): ID of the doctor who initiated or supervised the connection\n        patient (Patient): The Patient object whose account is being connected\n        platform_name (str): Name of the external health platform being connected\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        Since platforms don't have distinct IDs in the system, a placeholder\n        value of 0 is used for the entity_id.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.CONNECT,\n        entity_type=EntityType.HEALTH_PLATFORM,\n        entity_id=0,  # Using 0 as placeholder since platform doesn't have an ID\n        details={\n            'platform': platform_name,\n            'connected_at': datetime.utcnow().isoformat()\n        },\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_platform_disconnection","title":"<code>log_platform_disconnection(doctor_id, patient, platform_name)</code>","text":"<p>Log when a patient disconnects an external health platform from VitaLink. This convenience function creates an audit log entry when a patient or doctor disconnects an external health platform account from the VitaLink system, stopping the data sharing between systems. Args:     doctor_id (int): ID of the doctor who initiated or supervised the disconnection     patient (Patient): The Patient object whose account is being disconnected     platform_name (str): Name of the external health platform being disconnected Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The disconnection timestamp is stored in the details field for future reference.</p> Source code in <code>app/audit.py</code> <pre><code>def log_platform_disconnection(doctor_id, patient, platform_name):\n    \"\"\"\n    Log when a patient disconnects an external health platform from VitaLink.\n    This convenience function creates an audit log entry when a patient or doctor\n    disconnects an external health platform account from the VitaLink system,\n    stopping the data sharing between systems.\n    Args:\n        doctor_id (int): ID of the doctor who initiated or supervised the disconnection\n        patient (Patient): The Patient object whose account is being disconnected\n        platform_name (str): Name of the external health platform being disconnected\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The disconnection timestamp is stored in the details field for future reference.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.DISCONNECT,\n        entity_type=EntityType.HEALTH_PLATFORM,\n        entity_id=0,  # Using 0 as placeholder since platform doesn't have an ID\n        details={\n            'platform': platform_name,\n            'disconnected_at': datetime.utcnow().isoformat()\n        },\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_data_sync","title":"<code>log_data_sync(doctor_id, patient, platform_name, data_type, result_summary)</code>","text":"<p>Log the synchronization of data from an external health platform. This convenience function creates an audit log entry when data is synchronized from an external health platform (like Fitbit, Apple Health, etc.) into the  VitaLink system. The log includes details about what was synchronized and the result. Args:     doctor_id (int): ID of the doctor who initiated the data synchronization     patient (Patient): The Patient object whose data is being synchronized     platform_name (str): Name of the external health platform being synchronized with     data_type (str): Type of data being synchronized (e.g., 'heart_rate', 'steps', etc.)     result_summary (dict): Summary of the synchronization results (e.g., number of records, success status) Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     This function includes specific error handling to prevent sync failures     from disrupting the application flow, as data synchronization is an     auxiliary function to the core medical record system.</p> Source code in <code>app/audit.py</code> <pre><code>def log_data_sync(doctor_id, patient, platform_name, data_type, result_summary):\n    \"\"\"\n    Log the synchronization of data from an external health platform.\n    This convenience function creates an audit log entry when data is synchronized\n    from an external health platform (like Fitbit, Apple Health, etc.) into the \n    VitaLink system. The log includes details about what was synchronized and the result.\n    Args:\n        doctor_id (int): ID of the doctor who initiated the data synchronization\n        patient (Patient): The Patient object whose data is being synchronized\n        platform_name (str): Name of the external health platform being synchronized with\n        data_type (str): Type of data being synchronized (e.g., 'heart_rate', 'steps', etc.)\n        result_summary (dict): Summary of the synchronization results (e.g., number of records, success status)\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        This function includes specific error handling to prevent sync failures\n        from disrupting the application flow, as data synchronization is an\n        auxiliary function to the core medical record system.\n    \"\"\"\n    try:\n        # Use ActionType.SYNC directly instead of trying to convert a string\n        return log_action(\n            doctor_id=doctor_id,\n            action_type=ActionType.SYNC,\n            entity_type=EntityType.HEALTH_PLATFORM,\n            entity_id=0,  # Using 0 as placeholder since sync doesn't have an ID\n            details={\n                'platform': platform_name,\n                'data_type': data_type,\n                'sync_at': datetime.utcnow().isoformat(),\n                'result': result_summary\n            },\n            patient_id=patient.id\n        )\n    except Exception as e:\n        logger.error(f\"Error logging data sync: {str(e)}\")\n        return None\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_observation_creation","title":"<code>log_observation_creation(doctor_id, observation)</code>","text":"<p>Log the creation of a clinical observation. This convenience function creates an audit log entry when a doctor adds a new clinical observation to a patient's record. Observations are structured medical assessments related to specific vital signs or health metrics. Args:     doctor_id (int): ID of the doctor who created the observation     observation (Observation): The Observation object that was created Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The details field includes a truncated version of the observation content     if it's lengthy, as well as the vital sign type and relevant dates.</p> Source code in <code>app/audit.py</code> <pre><code>def log_observation_creation(doctor_id, observation):\n    \"\"\"\n    Log the creation of a clinical observation.\n    This convenience function creates an audit log entry when a doctor adds\n    a new clinical observation to a patient's record. Observations are structured\n    medical assessments related to specific vital signs or health metrics.\n    Args:\n        doctor_id (int): ID of the doctor who created the observation\n        observation (Observation): The Observation object that was created\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The details field includes a truncated version of the observation content\n        if it's lengthy, as well as the vital sign type and relevant dates.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.OBSERVATION,\n        entity_id=observation.id,\n        details={\n            'vital_type': observation.vital_type.value,\n            'content': observation.content[:100] + ('...' if len(observation.content) &gt; 100 else ''),\n            'period': f\"{observation.start_date.isoformat()} to {observation.end_date.isoformat()}\",\n            'created_at': observation.created_at.isoformat() if observation.created_at else None,\n        },\n        patient_id=observation.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_observation_update","title":"<code>log_observation_update(doctor_id, observation, old_data=None)</code>","text":"<p>Log the update of an existing clinical observation. This convenience function creates an audit log entry when a doctor modifies an existing clinical observation in a patient's record. This tracks changes made to clinical assessments over time. Args:     doctor_id (int): ID of the doctor who updated the observation     observation (Observation): The updated Observation object     old_data (dict, optional): The previous state of the observation before updates Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     If old_data is provided, it is included in the details for comparison,     allowing for tracking of specific changes made to the observation.</p> Source code in <code>app/audit.py</code> <pre><code>def log_observation_update(doctor_id, observation, old_data=None):\n    \"\"\"\n    Log the update of an existing clinical observation.\n    This convenience function creates an audit log entry when a doctor modifies\n    an existing clinical observation in a patient's record. This tracks changes\n    made to clinical assessments over time.\n    Args:\n        doctor_id (int): ID of the doctor who updated the observation\n        observation (Observation): The updated Observation object\n        old_data (dict, optional): The previous state of the observation before updates\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        If old_data is provided, it is included in the details for comparison,\n        allowing for tracking of specific changes made to the observation.\n    \"\"\"\n    details = {\n        'vital_type': observation.vital_type.value,\n        'content': observation.content[:100] + ('...' if len(observation.content) &gt; 100 else ''),\n        'period': f\"{observation.start_date.isoformat()} to {observation.end_date.isoformat()}\",\n        'updated_at': observation.updated_at.isoformat() if observation.updated_at else None,\n    }\n    # Add previous state information if provided\n    if old_data:\n        details['previous'] = old_data\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.UPDATE,\n        entity_type=EntityType.OBSERVATION,\n        entity_id=observation.id,\n        details=details,\n        patient_id=observation.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_observation_delete","title":"<code>log_observation_delete(doctor_id, observation)</code>","text":"<p>Log the deletion of a clinical observation. This convenience function creates an audit log entry when a doctor deletes a clinical observation from a patient's record. This ensures that even deleted observations leave an audit trail for compliance purposes. Args:     doctor_id (int): ID of the doctor who deleted the observation     observation (Observation): The Observation object being deleted Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     Key information about the deleted observation is preserved in the     audit log details, including a truncated version of the content,      the vital type, and the time period it covered.</p> Source code in <code>app/audit.py</code> <pre><code>def log_observation_delete(doctor_id, observation):\n    \"\"\"\n    Log the deletion of a clinical observation.\n    This convenience function creates an audit log entry when a doctor deletes\n    a clinical observation from a patient's record. This ensures that even deleted\n    observations leave an audit trail for compliance purposes.\n    Args:\n        doctor_id (int): ID of the doctor who deleted the observation\n        observation (Observation): The Observation object being deleted\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        Key information about the deleted observation is preserved in the\n        audit log details, including a truncated version of the content, \n        the vital type, and the time period it covered.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.DELETE,\n        entity_type=EntityType.OBSERVATION,\n        entity_id=observation.id,\n        details={\n            'vital_type': observation.vital_type.value,\n            'content': observation.content[:100] + ('...' if len(observation.content) &gt; 100 else ''),\n            'period': f\"{observation.start_date.isoformat()} to {observation.end_date.isoformat()}\",\n            'deleted_at': datetime.utcnow().isoformat(),\n        },\n        patient_id=observation.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_note_delete","title":"<code>log_note_delete(doctor_id, note)</code>","text":"<p>Log the deletion of a clinical note. This convenience function creates an audit log entry when a doctor deletes a clinical note from a patient's record. This preserves a record of the deletion action for compliance and audit purposes. Args:     doctor_id (int): ID of the doctor who deleted the note     note (Note): The Note object being deleted Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     A truncated version of the note content is preserved in the audit log     details to maintain context about what was deleted, while the exact     deletion time is also recorded.</p> Source code in <code>app/audit.py</code> <pre><code>def log_note_delete(doctor_id, note):\n    \"\"\"\n    Log the deletion of a clinical note.\n    This convenience function creates an audit log entry when a doctor deletes\n    a clinical note from a patient's record. This preserves a record of the\n    deletion action for compliance and audit purposes.\n    Args:\n        doctor_id (int): ID of the doctor who deleted the note\n        note (Note): The Note object being deleted\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        A truncated version of the note content is preserved in the audit log\n        details to maintain context about what was deleted, while the exact\n        deletion time is also recorded.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.DELETE,\n        entity_type=EntityType.NOTE,\n        entity_id=note.id,\n        details={\n            'content': note.content[:100] + ('...' if len(note.content) &gt; 100 else ''),\n            'deleted_at': datetime.utcnow().isoformat(),\n        },\n        patient_id=note.patient_id\n    )\n</code></pre>"},{"location":"modules/audit.html#app.audit.log_patient_import","title":"<code>log_patient_import(doctor_id, patient)</code>","text":"<p>Log the import of a patient record from an external source. This convenience function creates an audit log entry when a doctor imports a patient record from another system or data source into VitaLink. Args:     doctor_id (int): ID of the doctor who performed the import     patient (Patient): The Patient object that was imported Returns:     AuditLog: The created audit log entry or None if an error occurs Note:     The details field captures key identifiers including the patient's UUID,     which is particularly important for tracking imported records that     originated from external systems.</p> Source code in <code>app/audit.py</code> <pre><code>def log_patient_import(doctor_id, patient):\n    \"\"\"\n    Log the import of a patient record from an external source.\n    This convenience function creates an audit log entry when a doctor imports\n    a patient record from another system or data source into VitaLink.\n    Args:\n        doctor_id (int): ID of the doctor who performed the import\n        patient (Patient): The Patient object that was imported\n    Returns:\n        AuditLog: The created audit log entry or None if an error occurs\n    Note:\n        The details field captures key identifiers including the patient's UUID,\n        which is particularly important for tracking imported records that\n        originated from external systems.\n    \"\"\"\n    return log_action(\n        doctor_id=doctor_id,\n        action_type=ActionType.IMPORT,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details={\n            'patient_uuid': patient.uuid,\n            'patient_name': f\"{patient.first_name} {patient.last_name}\",\n            'patient_dob': patient.date_of_birth.isoformat() if patient.date_of_birth else None,\n            'imported_at': datetime.utcnow().isoformat(),\n        },\n        patient_id=patient.id\n    )\n</code></pre>"},{"location":"modules/auth.html","title":"Auth","text":"<p>Authentication Module. This module handles all authentication related functionality including: - User registration and login - JWT token creation and validation for API authentication - Session-based authentication for web interface - Password management and validation - Security-related decorators for route protection It provides both web routes (for form-based authentication) and API endpoints for programmatic authentication via JWT tokens.</p>"},{"location":"modules/auth.html#app.auth.auth_bp","title":"<code>auth_bp = Blueprint('auth', __name__)</code>  <code>module-attribute</code>","text":"<p>Authentication Blueprint. This blueprint handles all authentication-related routes including: - User registration and login/logout flows - API authentication via JWT tokens - Protected route decorators</p>"},{"location":"modules/auth.html#app.auth.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Authentication module logger. Logger for authentication-related events such as login attempts, registrations, password changes, and authentication failures.</p>"},{"location":"modules/auth.html#app.auth.RegistrationForm","title":"<code>RegistrationForm</code>","text":"<p>               Bases: <code>FlaskForm</code></p> <p>Form for doctor registration. This form collects all necessary information to create a new doctor account, including personal information, contact details, and secure password. Fields:     email: Doctor's email address, used for login     first_name: Doctor's first name     last_name: Doctor's last name     specialty: Doctor's medical specialty     password: Account password     confirm_password: Password confirmation to prevent typos</p> Source code in <code>app/auth.py</code> <pre><code>class RegistrationForm(FlaskForm):\n    \"\"\"\n    Form for doctor registration.\n    This form collects all necessary information to create a new doctor account,\n    including personal information, contact details, and secure password.\n    Fields:\n        email: Doctor's email address, used for login\n        first_name: Doctor's first name\n        last_name: Doctor's last name\n        specialty: Doctor's medical specialty\n        password: Account password\n        confirm_password: Password confirmation to prevent typos\n    \"\"\"\n    email = EmailField(_('Email'), validators=[DataRequired(), Email()])\n    first_name = StringField(_('First Name'), validators=[DataRequired(), Length(min=2, max=100)])\n    last_name = StringField(_('Last Name'), validators=[DataRequired(), Length(min=2, max=100)])\n    specialty = StringField(_('Specialty'))\n    password = PasswordField(_('Password'), validators=[\n        DataRequired(),\n        Length(min=8, message=_(\"Password must be at least 8 characters long\"))\n    ])\n    # We remove the EqualTo validator since we verify manually in the controller\n    confirm_password = PasswordField(_('Confirm Password'), validators=[\n        DataRequired()\n    ])\n</code></pre>"},{"location":"modules/auth.html#app.auth.RegistrationForm.email","title":"<code>email = EmailField(_('Email'), validators=[DataRequired(), Email()])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.RegistrationForm.first_name","title":"<code>first_name = StringField(_('First Name'), validators=[DataRequired(), Length(min=2, max=100)])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.RegistrationForm.last_name","title":"<code>last_name = StringField(_('Last Name'), validators=[DataRequired(), Length(min=2, max=100)])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.RegistrationForm.specialty","title":"<code>specialty = StringField(_('Specialty'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.RegistrationForm.password","title":"<code>password = PasswordField(_('Password'), validators=[DataRequired(), Length(min=8, message=(_('Password must be at least 8 characters long')))])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.RegistrationForm.confirm_password","title":"<code>confirm_password = PasswordField(_('Confirm Password'), validators=[DataRequired()])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/auth.html#app.auth.register","title":"<code>register()</code>","text":"<p>Doctor registration endpoint. Handles both GET requests (displaying the registration form) and POST requests (processing form submission and creating new doctor account). Returns:     For GET: Rendered registration form template     For successful POST: Redirect to login page     For failed POST: Registration form with error messages</p> Source code in <code>app/auth.py</code> <pre><code>@auth_bp.route('/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"\n    Doctor registration endpoint.\n    Handles both GET requests (displaying the registration form) and\n    POST requests (processing form submission and creating new doctor account).\n    Returns:\n        For GET: Rendered registration form template\n        For successful POST: Redirect to login page\n        For failed POST: Registration form with error messages\n    \"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('views.dashboard'))\n    form = RegistrationForm()\n    if request.method == 'POST':\n        # Verify password match manually before form validation\n        if form.password.data != form.confirm_password.data:\n            logger.info(\"Password mismatch during registration\")\n            flash(_('Passwords do not match'), 'danger')\n            return render_template('register.html', form=form, now=datetime.now())\n        if form.validate_on_submit():\n            email = form.email.data\n            # Check if email already exists\n            existing_doctor = Doctor.query.filter_by(email=email).first()\n            if existing_doctor:\n                flash(_('An account with this Email already exists'), 'danger')\n                return render_template('register.html', form=form, now=datetime.now())\n              # Check password strength\n            is_strong, message = is_valid_password(form.password.data)\n            if not is_strong:\n                flash(message, 'danger')\n                return render_template('register.html', form=form, now=datetime.now())\n            # Create new doctor account\n            doctor = Doctor(\n                email=form.email.data,\n                first_name=form.first_name.data,\n                last_name=form.last_name.data,\n                specialty=form.specialty.data\n            )\n            doctor.set_password(form.password.data)\n            try:\n                db.session.add(doctor)\n                db.session.commit()\n                flash(_('Registration completed. Now you can access'), 'success')\n                logger.info(f\"New doctor registered: {email}\")\n                return redirect(url_for('auth.login'))\n            except Exception as e:\n                db.session.rollback()\n                logger.error(f\"Error during registration: {str(e)}\")\n                flash(_('An error occurred. Please try again'), 'danger')\n    return render_template('register.html', form=form, now=datetime.now())\n</code></pre>"},{"location":"modules/auth.html#app.auth.login","title":"<code>login()</code>","text":"<p>Doctor login endpoint. Handles both GET requests (displaying the login form) and POST requests (processing login attempts and establishing user session). The function performs email and password validation, and creates a Flask-Login session if authentication is successful. Returns:     For GET: Rendered login form template     For successful POST: Redirect to dashboard     For failed POST: Login form with error messages</p> Source code in <code>app/auth.py</code> <pre><code>@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"\n    Doctor login endpoint.\n    Handles both GET requests (displaying the login form) and\n    POST requests (processing login attempts and establishing user session).\n    The function performs email and password validation, and creates\n    a Flask-Login session if authentication is successful.\n    Returns:\n        For GET: Rendered login form template\n        For successful POST: Redirect to dashboard\n        For failed POST: Login form with error messages\n    \"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('views.dashboard'))\n    if request.method == 'POST':\n        email = request.form.get('email')\n        password = request.form.get('password')\n        if not email or not password:\n            flash(_('Please provide both email and password'), 'danger')\n            return render_template('login.html', now=datetime.now())\n        if not validate_email(email):\n            flash(_('Invalid email format'), 'danger')\n            return render_template('login.html', now=datetime.now())\n        doctor = Doctor.query.filter_by(email=email).first()\n        if doctor and doctor.check_password(password):\n            login_user(doctor)\n            logger.info(f\"Doctor {doctor.id} logged in successfully\")\n            return redirect(url_for('views.dashboard'))\n        else:\n            flash(_('Invalid email or password'), 'danger')\n    return render_template('login.html', now=datetime.now())\n</code></pre>"},{"location":"modules/auth.html#app.auth.logout","title":"<code>logout()</code>","text":"<p>Doctor logout endpoint. Terminates the user's authenticated session in the system. This function requires an active login session (enforced by @login_required), logs the logout event, and redirects the user back to the login page. Returns:     Response: Redirect to login page with success message</p> Source code in <code>app/auth.py</code> <pre><code>@auth_bp.route('/logout')\n@login_required\ndef logout():\n    \"\"\"\n    Doctor logout endpoint.\n    Terminates the user's authenticated session in the system.\n    This function requires an active login session (enforced by @login_required),\n    logs the logout event, and redirects the user back to the login page.\n    Returns:\n        Response: Redirect to login page with success message\n    \"\"\"\n    logger.info(f\"Doctor {current_user.id} logged out\")\n    logout_user()\n    flash(_('You have been disconnected'), 'success')\n    return redirect(url_for('auth.login'))\n</code></pre>"},{"location":"modules/auth.html#app.auth.api_login","title":"<code>api_login()</code>","text":"<p>API endpoint for doctor authentication. Validates doctor credentials and issues JWT tokens for API access. This endpoint expects a JSON payload with email and password fields. If authentication is successful, it returns both access and refresh tokens along with the doctor's information. Request Body:     email (str): Doctor's email address     password (str): Doctor's password Returns:     JSON: For successful authentication - tokens and doctor information           For failed authentication - error message with appropriate HTTP status Response Status Codes:     200: Success     400: Missing JSON payload or missing credentials     401: Invalid credentials</p> Source code in <code>app/auth.py</code> <pre><code>@auth_bp.route('/api/login', methods=['POST'])\ndef api_login():\n    \"\"\"\n    API endpoint for doctor authentication.\n    Validates doctor credentials and issues JWT tokens for API access.\n    This endpoint expects a JSON payload with email and password fields.\n    If authentication is successful, it returns both access and refresh tokens\n    along with the doctor's information.\n    Request Body:\n        email (str): Doctor's email address\n        password (str): Doctor's password\n    Returns:\n        JSON: For successful authentication - tokens and doctor information\n              For failed authentication - error message with appropriate HTTP status\n    Response Status Codes:\n        200: Success\n        400: Missing JSON payload or missing credentials\n        401: Invalid credentials\n    \"\"\"\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON in request\")}), 400\n    email = request.json.get('email', None)\n    password = request.json.get('password', None)\n    if not email or not password:\n        return jsonify({\"error\": _(\"Missing email or password\")}), 400\n    doctor = Doctor.query.filter_by(email=email).first()\n    if not doctor or not doctor.check_password(password):\n        return jsonify({\"error\": _(\"Invalid email or password\")}), 401\n      # Create access token and refresh token - Identity must be a string\n    access_token = create_access_token(identity=str(doctor.id))\n    refresh_token = create_refresh_token(identity=str(doctor.id))\n    logger.info(f\"API login successful for doctor {doctor.id}\")\n    return jsonify({\n        \"message\": _(\"Login successful\"),\n        \"doctor\": doctor.to_dict(),\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token\n    }), 200\n</code></pre>"},{"location":"modules/auth.html#app.auth.refresh_token","title":"<code>refresh_token()</code>","text":"<p>API endpoint for refreshing access tokens. This endpoint generates a new access token using a valid refresh token. The refresh token must be included in the Authorization header as a Bearer token. This mechanism enables extended API sessions without requiring frequent re-authentication with username and password. The @jwt_required(refresh=True) decorator ensures that only refresh tokens are accepted for this endpoint. Returns:     JSON: New access token on success Response Status Codes:     200: Success     401: Invalid or expired refresh token (handled by the JWT decorator)</p> Source code in <code>app/auth.py</code> <pre><code>@auth_bp.route('/api/refresh-token', methods=['POST'])\n@jwt_required(refresh=True)\ndef refresh_token():\n    \"\"\"\n    API endpoint for refreshing access tokens.\n    This endpoint generates a new access token using a valid refresh token.\n    The refresh token must be included in the Authorization header as a Bearer token.\n    This mechanism enables extended API sessions without requiring frequent\n    re-authentication with username and password.\n    The @jwt_required(refresh=True) decorator ensures that only refresh tokens\n    are accepted for this endpoint.\n    Returns:\n        JSON: New access token on success\n    Response Status Codes:\n        200: Success\n        401: Invalid or expired refresh token (handled by the JWT decorator)\n    \"\"\"\n    identity = get_jwt_identity()\n    access_token = create_access_token(identity=identity)\n    logger.info(f\"Token refreshed for doctor {identity}\")\n    return jsonify({\n        \"access_token\": access_token\n    }), 200\n</code></pre>"},{"location":"modules/auth.html#app.auth.api_doctor_required","title":"<code>api_doctor_required(f)</code>","text":"<p>Decorator for API routes that require doctor authentication. This decorator extracts the doctor ID from the JWT token, finds the corresponding doctor in the database, and passes the doctor object to the route handler. Args:     f: The function to decorate Returns:     decorated: The decorated function that includes authentication check Example usage:     @api_bp.route('/endpoint')     @api_doctor_required     def protected_route(doctor):         # doctor object is automatically provided         return jsonify({\"data\": doctor.to_dict()})</p> Source code in <code>app/auth.py</code> <pre><code>def api_doctor_required(f):\n    \"\"\"\n    Decorator for API routes that require doctor authentication.\n    This decorator extracts the doctor ID from the JWT token,\n    finds the corresponding doctor in the database, and passes\n    the doctor object to the route handler.\n    Args:\n        f: The function to decorate\n    Returns:\n        decorated: The decorated function that includes authentication check\n    Example usage:\n        @api_bp.route('/endpoint')\n        @api_doctor_required\n        def protected_route(doctor):\n            # doctor object is automatically provided\n            return jsonify({\"data\": doctor.to_dict()})\n    \"\"\"\n    @wraps(f)\n    @jwt_required()\n    def decorated(*args, **kwargs):\n        doctor_id = get_jwt_identity()\n        # Ensure that doctor_id is a string and convert to int if necessary\n        try:\n            if isinstance(doctor_id, str) and doctor_id.isdigit():\n                doctor_id = int(doctor_id)\n            doctor = Doctor.query.get(doctor_id)\n        except Exception:\n            return jsonify({\"error\": _(\"Invalid authentication token\")}), 401\n        if not doctor:\n            return jsonify({\"error\": _(\"Doctor not found\")}), 404\n        return f(doctor, *args, **kwargs)\n    return decorated\n</code></pre>"},{"location":"modules/auth.html#app.auth.doctor_required","title":"<code>doctor_required(f)</code>","text":"<p>Decorator for web routes that require doctor authentication. This decorator ensures that the current user is authenticated and is a valid doctor in the system. It relies on Flask-Login for session handling. Args:     f: The function to decorate Returns:     decorated: The decorated function that includes authentication check Example usage:     @views_bp.route('/dashboard')     @doctor_required     def dashboard():         # Only authenticated doctors can access this route         return render_template('dashboard.html')</p> Source code in <code>app/auth.py</code> <pre><code>def doctor_required(f):\n    \"\"\"\n    Decorator for web routes that require doctor authentication.\n    This decorator ensures that the current user is authenticated\n    and is a valid doctor in the system. It relies on Flask-Login\n    for session handling.\n    Args:\n        f: The function to decorate\n    Returns:\n        decorated: The decorated function that includes authentication check\n    Example usage:\n        @views_bp.route('/dashboard')\n        @doctor_required\n        def dashboard():\n            # Only authenticated doctors can access this route\n            return render_template('dashboard.html')\n    \"\"\"\n    @wraps(f)\n    @login_required\n    def decorated(*args, **kwargs):\n        # Flask-Login already ensures the user is authenticated\n        # We just need to check if the user is a doctor\n        if not hasattr(current_user, 'id'):\n            flash(_('Authentication required'), 'danger')\n            return redirect(url_for('auth.login'))\n        return f(*args, **kwargs)\n    return decorated\n</code></pre>"},{"location":"modules/compile_translations.html","title":"Compile Translations","text":"<p>Translation Compilation Module. This module provides functionality for compiling translation files (.po files) into binary message catalog files (.mo files) that can be used by the application's internationalization system. The module: 1. Finds all .po files in the translations directory 2. Compiles each .po file into a corresponding .mo file 3. Reports on the success or failure of each compilation 4. Provides summary statistics of the compilation process This script can be run directly to compile all translation files at once.</p>"},{"location":"modules/compile_translations.html#app.compile_translations.BASE_DIR","title":"<code>BASE_DIR = Path(__file__).resolve().parent / 'translations'</code>  <code>module-attribute</code>","text":""},{"location":"modules/compile_translations.html#app.compile_translations.compile_po_to_mo","title":"<code>compile_po_to_mo(po_path: Path) -&gt; bool</code>","text":"<p>Compile a PO translation file to a binary MO file. This function takes a path to a PO (Portable Object) translation file and compiles it to an MO (Machine Object) binary file that can be efficiently used by gettext at runtime. Args:     po_path (Path): Path object pointing to the .po file to compile Returns:     bool: True if compilation was successful, False otherwise Side effects:     - Creates or overwrites an .mo file with the same base name as the input file     - Prints status messages to standard output</p> Source code in <code>app/compile_translations.py</code> <pre><code>def compile_po_to_mo(po_path: Path) -&gt; bool:\n    \"\"\"\n    Compile a PO translation file to a binary MO file.\n    This function takes a path to a PO (Portable Object) translation file and\n    compiles it to an MO (Machine Object) binary file that can be efficiently\n    used by gettext at runtime.\n    Args:\n        po_path (Path): Path object pointing to the .po file to compile\n    Returns:\n        bool: True if compilation was successful, False otherwise\n    Side effects:\n        - Creates or overwrites an .mo file with the same base name as the input file\n        - Prints status messages to standard output\n    \"\"\"\n    try:\n        mo_path = po_path.with_suffix(\".mo\")\n        polib.pofile(po_path).save_as_mofile(mo_path)\n        print(f\"{po_path.relative_to(BASE_DIR)} \u2192 {mo_path.name}\")\n        return True\n    except Exception as exc:\n        print(f\"NO {po_path}: {exc}\")\n        return False\n</code></pre>"},{"location":"modules/compile_translations.html#app.compile_translations.main","title":"<code>main() -&gt; None</code>","text":"<p>Main function to compile all translation files. This function: 1. Finds all .po files in the translations directory structure 2. Compiles each one to a corresponding .mo file 3. Reports the number of successful and failed compilations The function searches for translation files in the standard directory structure: translations/[language]/LC_MESSAGES/[domain].po Returns:     None</p> Source code in <code>app/compile_translations.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Main function to compile all translation files.\n    This function:\n    1. Finds all .po files in the translations directory structure\n    2. Compiles each one to a corresponding .mo file\n    3. Reports the number of successful and failed compilations\n    The function searches for translation files in the standard directory structure:\n    translations/[language]/LC_MESSAGES/[domain].po\n    Returns:\n        None\n    \"\"\"\n    # first pattern: lingua/LC_MESSAGES/*.po (standard Flask)\n    pattern1 = \"*/LC_MESSAGES/*.po\"\n    po_files_1 = list(BASE_DIR.glob(pattern1))\n    # second pattern: */*/LC_MESSAGES/*.po (deep search)\n    pattern2 = \"*/*/LC_MESSAGES/*.po\"\n    po_files_2 = list(BASE_DIR.glob(pattern2))\n    # Combina i risultati\n    po_files = po_files_1 + [p for p in po_files_2 if p not in po_files_1]\n    if not po_files:\n        print(f\"No file .po found in {BASE_DIR}\")\n        print(f\"Search patterns: {pattern1} o {pattern2}\")\n        print(\"Available directories:\")\n        for item in BASE_DIR.iterdir():\n            if item.is_dir():\n                print(f\"  - {item}\")\n                for subitem in item.iterdir():\n                    print(f\"    - {subitem}\")\n    results = [compile_po_to_mo(po) for po in po_files]\n    print(\n        f\"\\nCompiled {sum(results)} / {len(results)} catalog(s)\"\n        f\" in {BASE_DIR.relative_to(Path.cwd())}\"\n    )\n</code></pre>"},{"location":"modules/email_utils.html","title":"Email Utils","text":"<p>Email Utility Module. This module provides functionality for sending emails through the Mailjet service. It includes functions to send emails with attachments, such as patient reports.</p>"},{"location":"modules/email_utils.html#app.email_utils.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/email_utils.html#app.email_utils.MJ_APIKEY","title":"<code>MJ_APIKEY = os.environ['MJ_APIKEY']</code>  <code>module-attribute</code>","text":""},{"location":"modules/email_utils.html#app.email_utils.MJ_APIKEY_SECRET","title":"<code>MJ_APIKEY_SECRET = os.environ['MJ_APIKEY_SECRET']</code>  <code>module-attribute</code>","text":""},{"location":"modules/email_utils.html#app.email_utils.send_report_email","title":"<code>send_report_email(doctor, patient, pdf_buffer, filename, language='it')</code>","text":"<p>Sends a PDF report to the patient via email using Mailjet. Args:     doctor (Doctor): Doctor object representing the physician who generated the report     patient (Patient): Patient object of the recipient     pdf_buffer (BytesIO): buffer containing the PDF report     filename (str): name of the PDF file     language (str, optional): language code for translations (it/en) Returns:     tuple: Tuple containing (success, message)         - success (bool): True if the email was sent successfully, otherwise False         - message (str): success or error message</p> Source code in <code>app/email_utils.py</code> <pre><code>def send_report_email(doctor, patient, pdf_buffer, filename, language='it'):\n    \"\"\"\n    Sends a PDF report to the patient via email using Mailjet.\n    Args:\n        doctor (Doctor): Doctor object representing the physician who generated the report\n        patient (Patient): Patient object of the recipient\n        pdf_buffer (BytesIO): buffer containing the PDF report\n        filename (str): name of the PDF file\n        language (str, optional): language code for translations (it/en)\n    Returns:\n        tuple: Tuple containing (success, message)\n            - success (bool): True if the email was sent successfully, otherwise False\n            - message (str): success or error message\n    \"\"\"\n    if not patient.email:\n        return False, _(\"The patient doesn't have an email address\")\n    try:\n        # Create the Mailjet client\n        mailjet = Client(auth=(MJ_APIKEY, MJ_APIKEY_SECRET), version='v3.1')\n        # Convert PDF to base64\n        pdf_content = pdf_buffer.getvalue()\n        encoded_pdf = base64.b64encode(pdf_content).decode('utf-8')\n        # Extract timestamp from filename\n        date_str = filename.split('_')[-2]  # Extract date from filename\n        # Prepare email subject\n        subject = _(\"Medical Report from {doctor_name} - {date}\").format(\n            doctor_name=f\"Dr. {doctor.first_name} {doctor.last_name}\",\n            date=date_str\n        )\n        # Prepare email content\n        text_content = _(\"\"\"\n                Dear {patient_name},\n                Attached you will find the medical report generated by {doctor_name}.\n                This is an automated message, please do not reply to this email.\n                Best regards,\n                VitaLink Team\n                        \"\"\").format(\n                            patient_name=f\"{patient.first_name} {patient.last_name}\",\n                            doctor_name=f\"Dr. {doctor.first_name} {doctor.last_name}\"\n                        )\n        html_content = _(\"\"\"\n            &lt;h3&gt;Dear {patient_name},&lt;/h3&gt;\n            &lt;p&gt;Attached you will find the medical report generated by {doctor_name}.&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Report Information:&lt;/strong&gt;&lt;br&gt;\n            Date: {date}&lt;br&gt;\n            Generated by: {doctor_name}&lt;br&gt;\n            Specialty: {specialty}&lt;/p&gt;\n            &lt;p&gt;This is an automated message, please do not reply to this email.&lt;/p&gt;\n            &lt;p&gt;Best regards,&lt;br&gt;\n            VitaLink Team&lt;/p&gt;\n                    \"\"\").format(\n            patient_name=f\"{patient.first_name} {patient.last_name}\",\n            doctor_name=f\"Dr. {doctor.first_name} {doctor.last_name}\",\n            specialty=doctor.specialty or _(\"General Medicine\"),\n            date=date_str\n        )\n          # Prepare data to send to Mailjet\n        data = {\n            'Messages': [\n                {\n                    \"From\": {\n                        \"Email\": os.environ[\"EMAIL_SENDER\"],\n                        \"Name\": \"VitaLink\"\n                    },\n                    \"To\": [\n                        {\n                            \"Email\": patient.email,\n                            \"Name\": f\"{patient.first_name} {patient.last_name}\"\n                        }\n                    ],\n                    \"Subject\": subject,\n                    \"TextPart\": text_content,\n                    \"HTMLPart\": html_content,\n                    \"Attachments\": [\n                        {\n                            \"ContentType\": \"application/pdf\",\n                            \"Filename\": filename,\n                            \"Base64Content\": encoded_pdf\n                        }\n                    ]\n                }\n            ]\n        }\n        # Execute the Mailjet request\n        result = mailjet.send.create(data=data)\n        # Verify the result\n        if result.status_code == 200:\n            response_data = result.json()\n            if response_data and 'Messages' in response_data and len(response_data['Messages']) &gt; 0:\n                message = response_data['Messages'][0]\n                if message.get('Status') == 'success':\n                    logger.info(f\"Email sent successfully to {patient.email}\")\n                    return True, _(\"Report sent successfully to {email}\").format(email=patient.email)\n        # If we get here, there was a problem\n        logger.error(f\"Email sending error: {result.status_code} - {result.json()}\")\n        return False, _(\"Error sending email: {error}\").format(error=result.status_code)\n    except Exception as e:\n        logger.exception(f\"Exception during email sending: {str(e)}\")\n        return False, _(\"An error occurred while sending the email: {error}\").format(error=str(e))\n</code></pre>"},{"location":"modules/health_platforms.html","title":"Health Platforms","text":"<p>Health Platforms Integration Module.</p> <p>This module provides comprehensive functionality to connect to, authenticate with, and retrieve data from various health and fitness platforms. It currently supports Fitbit with extensibility for other platforms like Google Health Connect and Apple Health.</p> <p>Key features: 1. OAuth2 authentication flows for connecting user accounts to health platforms 2. API clients for retrieving different types of health data (heart rate, steps, etc.) 3. Data processing and normalization to standardize data across platforms 4. Intelligent caching to minimize API calls and respect rate limits 5. Error handling for API failures, token expiration, and invalid requests</p> <p>The module implements a Blueprint with routes for connecting/disconnecting platforms and background functionality for data synchronization. It includes proper audit logging for all operations to maintain a record of data access.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.health_bp","title":"<code>health_bp = Blueprint('health', __name__, url_prefix='/health')</code>  <code>module-attribute</code>","text":"<p>Health Platforms Blueprint.</p> <p>This blueprint manages all routes related to health platform integrations, including OAuth flows, connection management, and data retrieval. It provides both web interface endpoints and API endpoints for interacting with third-party health data sources.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.vitals_cache","title":"<code>vitals_cache = {}</code>  <code>module-attribute</code>","text":"<p>Rate limit management for health platform API calls.</p> <p>This dictionary tracks API usage to ensure the application respects the rate limits imposed by health platforms (particularly Fitbit). It implements a sliding window approach to track call frequency and automatically backs off when approaching limits.</p> Structure <p>{     'last_reset': datetime,      # Last time the counter was reset     'calls': 0,                  # Call counter within current window     'hourly_limit': 150,         # Hourly call limit (Fitbit rate limit)     'retry_after': None          # Time when we can resume calls after hitting limit }</p> <p>When the rate limit is reached, subsequent calls are blocked until the retry_after time, preventing HTTP 429 errors from the API.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.api_rate_limit","title":"<code>api_rate_limit = {'last_reset': datetime.utcnow(), 'calls': 0, 'hourly_limit': 150, 'retry_after': None}</code>  <code>module-attribute</code>","text":""},{"location":"modules/health_platforms.html#app.health_platforms.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Health platforms module logger.</p> <p>Logger for tracking events related to health platform integrations, including connection attempts, OAuth flows, API calls, and data synchronization.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.api_logger","title":"<code>api_logger = logging.getLogger('fitbit_api')</code>  <code>module-attribute</code>","text":"<p>Specialized logger for Fitbit API interactions.</p> <p>This dedicated logger captures detailed information about all Fitbit API calls, responses, errors, and rate limit information. It writes to a separate log file for easier debugging and monitoring of API-specific issues.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.api_file_handler","title":"<code>api_file_handler = logging.FileHandler('fitbit_api.log')</code>  <code>module-attribute</code>","text":"<p>File handler for Fitbit API logs.</p> <p>Writes detailed Fitbit API interaction logs to a dedicated file, separate from the main application logs for easier troubleshooting of API issues.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.formatter","title":"<code>formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')</code>  <code>module-attribute</code>","text":"<p>Log formatter for Fitbit API logs.</p> <p>Defines the format for API log entries, including timestamp, log level, and the actual message content.</p>"},{"location":"modules/health_platforms.html#app.health_platforms.generate_platform_link","title":"<code>generate_platform_link(patient, doctor, platform)</code>","text":"<p>Generate a temporary link for a patient to connect to a health platform.</p> <p>This function creates a unique, time-limited link that can be shared with a patient to authorize connection to a health platform (e.g., Fitbit). The link contains a secure token that expires after a set period and can only be used once.</p> <p>The link is recorded in the database and associated with both the patient and the doctor who initiated the connection. Old/expired links for the same patient and platform are invalidated to maintain security.</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>The patient object to connect to the platform</p> required <code>doctor</code> <code>Doctor</code> <p>The doctor who is initiating the connection</p> required <code>platform</code> <code>HealthPlatform</code> <p>Which health platform to connect to (e.g., FITBIT)</p> required <p>Returns:</p> Name Type Description <code>HealthPlatformLink</code> <p>The created link object containing the token and URL</p> <p>Raises:</p> Type Description <code>SQLAlchemyError</code> <p>If there's a database issue when creating the link</p> Source code in <code>app/health_platforms.py</code> <pre><code>def generate_platform_link(patient, doctor, platform):\n    \"\"\"\n    Generate a temporary link for a patient to connect to a health platform.\n\n    This function creates a unique, time-limited link that can be shared with a patient\n    to authorize connection to a health platform (e.g., Fitbit). The link contains\n    a secure token that expires after a set period and can only be used once.\n\n    The link is recorded in the database and associated with both the patient and\n    the doctor who initiated the connection. Old/expired links for the same patient\n    and platform are invalidated to maintain security.\n\n    Args:\n        patient (Patient): The patient object to connect to the platform\n        doctor (Doctor): The doctor who is initiating the connection\n        platform (HealthPlatform): Which health platform to connect to (e.g., FITBIT)\n\n    Returns:\n        HealthPlatformLink: The created link object containing the token and URL\n\n    Raises:\n        SQLAlchemyError: If there's a database issue when creating the link\n    \"\"\"\n    try:\n        # First, invalidate any existing links for this patient and platform\n        existing_links = HealthPlatformLink.query.filter_by(\n            patient_id=patient.id,\n            platform=platform,\n            used=False\n        ).all()\n\n        for link in existing_links:\n            link.used = True\n\n        # Create a new link\n        new_link = HealthPlatformLink(\n            patient_id=patient.id,\n            doctor_id=doctor.id,\n            platform=platform\n        )\n\n        db.session.add(new_link)\n        db.session.commit()\n\n        # Log the action\n        try:\n            log_health_link_creation(doctor.id, new_link)\n        except Exception as log_error:\n            logger.error(f\"Error logging platform link creation: {str(log_error)}\")\n\n        return new_link\n    except Exception as e:\n        logger.error(f\"Error generating platform link: {str(e)}\")\n        db.session.rollback()\n        return None\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_link_by_uuid","title":"<code>get_link_by_uuid(uuid)</code>","text":"<p>Retrieve a health platform link by its UUID.</p> <p>This function looks up an existing health platform connection link using its unique identifier. These links are created when a doctor initiates a connection process for a patient.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The unique identifier of the platform link</p> required <p>Returns:</p> Name Type Description <code>HealthPlatformLink</code> <p>The found link object, or None if not found</p> Example <p>link = get_link_by_uuid(\"123e4567-e89b-12d3-a456-426614174000\") if link and not link.used:     # Process valid link</p> Source code in <code>app/health_platforms.py</code> <pre><code>def get_link_by_uuid(uuid):\n    \"\"\"\n    Retrieve a health platform link by its UUID.\n\n    This function looks up an existing health platform connection link\n    using its unique identifier. These links are created when a doctor\n    initiates a connection process for a patient.\n\n    Args:\n        uuid (str): The unique identifier of the platform link\n\n    Returns:\n        HealthPlatformLink: The found link object, or None if not found\n\n    Example:\n        link = get_link_by_uuid(\"123e4567-e89b-12d3-a456-426614174000\")\n        if link and not link.used:\n            # Process valid link\n    \"\"\"\n    return HealthPlatformLink.query.filter_by(uuid=uuid).first()\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_fitbit_authorization_url","title":"<code>get_fitbit_authorization_url(link_uuid)</code>","text":"<p>Generate the Fitbit authorization URL for initiating the OAuth2 flow.</p> <p>This function builds the URL to Fitbit's authorization endpoint with all necessary OAuth2 parameters. When a user visits this URL, they will be prompted to log in to their Fitbit account and authorize the VitaLink application to access their health data according to the requested scopes.</p> <p>The function includes: - Client ID from Fitbit Developer configuration - Required response_type for authorization code flow - All needed data scopes (activity, heartrate, etc.) - Redirect URI for OAuth callback - State parameter for security (using the link UUID) - Expiration setting requesting maximum token lifetime</p> <p>Parameters:</p> Name Type Description Default <code>link_uuid</code> <code>str</code> <p>UUID of the health platform link, used as the state             parameter to prevent CSRF attacks</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Complete authorization URL to redirect the user to  This URL points to Fitbit's authorization server</p> Source code in <code>app/health_platforms.py</code> <pre><code>def get_fitbit_authorization_url(link_uuid):\n    \"\"\"\n    Generate the Fitbit authorization URL for initiating the OAuth2 flow.\n\n    This function builds the URL to Fitbit's authorization endpoint with all\n    necessary OAuth2 parameters. When a user visits this URL, they will be\n    prompted to log in to their Fitbit account and authorize the VitaLink\n    application to access their health data according to the requested scopes.\n\n    The function includes:\n    - Client ID from Fitbit Developer configuration\n    - Required response_type for authorization code flow\n    - All needed data scopes (activity, heartrate, etc.)\n    - Redirect URI for OAuth callback\n    - State parameter for security (using the link UUID)\n    - Expiration setting requesting maximum token lifetime\n\n    Args:\n        link_uuid (str): UUID of the health platform link, used as the state\n                        parameter to prevent CSRF attacks\n\n    Returns:\n        str: Complete authorization URL to redirect the user to\n             This URL points to Fitbit's authorization server\n    \"\"\"\n    params = {\n        'client_id': FITBIT_CONFIG['client_id'],\n        'response_type': 'code',\n        'scope': FITBIT_CONFIG['scope'],\n        'redirect_uri': FITBIT_CONFIG['redirect_uri'],\n        'state': link_uuid,\n        'expires_in': 31536000  # 365 days (1 year) - maximum allowed by Fitbit\n    }\n\n    auth_url = f\"{FITBIT_CONFIG['authorize_url']}?{urlencode(params)}\"\n    return auth_url\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.exchange_fitbit_code_for_token","title":"<code>exchange_fitbit_code_for_token(authorization_code)</code>","text":"<p>Exchange an authorization code for an access token</p> <p>Parameters:</p> Name Type Description Default <code>authorization_code</code> <code>str</code> <p>Authorization code from Fitbit</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Token response with access_token, refresh_token, etc. or None if error</p> Source code in <code>app/health_platforms.py</code> <pre><code>def exchange_fitbit_code_for_token(authorization_code):\n    \"\"\"\n    Exchange an authorization code for an access token\n\n    Args:\n        authorization_code (str): Authorization code from Fitbit\n\n    Returns:\n        dict: Token response with access_token, refresh_token, etc. or None if error\n    \"\"\"\n    try:\n        # Create the Authorization header (Basic auth with client_id:client_secret)\n        auth_header = base64.b64encode(\n            f\"{FITBIT_CONFIG['client_id']}:{FITBIT_CONFIG['client_secret']}\".encode()\n        ).decode()\n\n        headers = {\n            'Authorization': f'Basic {auth_header}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n\n        data = {\n            'client_id': FITBIT_CONFIG['client_id'],\n            'grant_type': 'authorization_code',\n            'code': authorization_code,\n            'redirect_uri': FITBIT_CONFIG['redirect_uri']\n        }\n\n        response = requests.post(\n            FITBIT_CONFIG['token_url'],\n            headers=headers,\n            data=data\n        )\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            logger.error(f\"Error getting Fitbit token: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        logger.error(f\"Exception during token exchange: {str(e)}\")\n        return None\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.refresh_fitbit_token","title":"<code>refresh_fitbit_token(refresh_token)</code>","text":"<p>Refresh an expired Fitbit access token</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token from previous authorization</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>New token response or None if error</p> Source code in <code>app/health_platforms.py</code> <pre><code>def refresh_fitbit_token(refresh_token):\n    \"\"\"\n    Refresh an expired Fitbit access token\n\n    Args:\n        refresh_token (str): Refresh token from previous authorization\n\n    Returns:\n        dict: New token response or None if error\n    \"\"\"\n    try:\n        # Create the Authorization header (Basic auth with client_id:client_secret)\n        auth_header = base64.b64encode(\n            f\"{FITBIT_CONFIG['client_id']}:{FITBIT_CONFIG['client_secret']}\".encode()\n        ).decode()\n\n        headers = {\n            'Authorization': f'Basic {auth_header}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n\n        data = {\n            'grant_type': 'refresh_token',\n            'refresh_token': refresh_token\n        }\n\n        response = requests.post(\n            FITBIT_CONFIG['token_url'],\n            headers=headers,\n            data=data\n        )\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            logger.error(f\"Error refreshing Fitbit token: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        logger.error(f\"Exception during token refresh: {str(e)}\")\n        return None\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.save_fitbit_tokens","title":"<code>save_fitbit_tokens(patient, token_response)</code>","text":"<p>Save OAuth2 tokens from Fitbit to the patient record.</p> <p>This function processes the token response received after a successful OAuth2 authentication with Fitbit and stores the relevant token information in the patient's record. It handles both initial authorization and token refresh flows.</p> <p>The function stores: - Access token (for API calls) - Refresh token (for renewing access when it expires) - Expiration time (calculated based on expires_in value)</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>The patient object to update with token information</p> required <code>token_response</code> <code>dict</code> <p>The OAuth2 token response from Fitbit API</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if tokens were saved successfully, False if an error occurred</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Logs database errors but doesn't propagate them</p> Source code in <code>app/health_platforms.py</code> <pre><code>def save_fitbit_tokens(patient, token_response):\n    \"\"\"\n    Save OAuth2 tokens from Fitbit to the patient record.\n\n    This function processes the token response received after a successful OAuth2\n    authentication with Fitbit and stores the relevant token information in the\n    patient's record. It handles both initial authorization and token refresh flows.\n\n    The function stores:\n    - Access token (for API calls)\n    - Refresh token (for renewing access when it expires)\n    - Expiration time (calculated based on expires_in value)\n\n    Args:\n        patient (Patient): The patient object to update with token information\n        token_response (dict): The OAuth2 token response from Fitbit API\n\n    Returns:\n        bool: True if tokens were saved successfully, False if an error occurred\n\n    Raises:\n        Exception: Logs database errors but doesn't propagate them\n    \"\"\"\n    try:\n        # Extract token data\n        access_token = token_response.get('access_token')\n        refresh_token = token_response.get('refresh_token')\n        # Default to 1 year if not provided - the maximum possible for Fitbit\n        expires_in = token_response.get('expires_in', 31536000)\n\n        # Calculate expiry date\n        expires_at = datetime.utcnow() + timedelta(seconds=expires_in)\n\n        # Update patient record\n        patient.connected_platform = HealthPlatform.FITBIT\n        patient.platform_access_token = access_token\n        patient.platform_refresh_token = refresh_token\n        patient.platform_token_expires_at = expires_at\n\n        db.session.commit()\n        return True\n    except Exception as e:\n        logger.error(f\"Error saving Fitbit tokens: {str(e)}\")\n        db.session.rollback()\n        return False\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.ensure_fresh_token","title":"<code>ensure_fresh_token(patient)</code>","text":"<p>Ensure the patient has a valid (not expired) Fitbit token.</p> <p>This function checks if the patient's Fitbit access token is still valid and attempts to refresh it if expired. It handles all aspects of token management including checking expiration time, using the refresh token to obtain a new access token, and updating the patient record with new token information.</p> <p>A small buffer time (5 minutes) is applied to the expiration to prevent using tokens that are about to expire during an operation.</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>Patient object with stored token information</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Valid access token ready for API use, or None if unable to get one   (due to disconnected platform, missing tokens, or refresh failure)</p> Side effects <p>Updates the patient's token information in the database if refreshed</p> Source code in <code>app/health_platforms.py</code> <pre><code>def ensure_fresh_token(patient):\n    \"\"\"\n    Ensure the patient has a valid (not expired) Fitbit token.\n\n    This function checks if the patient's Fitbit access token is still valid\n    and attempts to refresh it if expired. It handles all aspects of token\n    management including checking expiration time, using the refresh token\n    to obtain a new access token, and updating the patient record with new\n    token information.\n\n    A small buffer time (5 minutes) is applied to the expiration to prevent\n    using tokens that are about to expire during an operation.\n\n    Args:\n        patient (Patient): Patient object with stored token information\n\n    Returns:\n        str: Valid access token ready for API use, or None if unable to get one\n              (due to disconnected platform, missing tokens, or refresh failure)\n\n    Side effects:\n        Updates the patient's token information in the database if refreshed\n    \"\"\"\n    if not patient.connected_platform == HealthPlatform.FITBIT:\n        logger.error(\"Patient is not connected to Fitbit\")\n        return None\n\n    if not patient.platform_token_expires_at or not patient.platform_access_token:\n        logger.error(\"Patient has no Fitbit token data\")\n        return None\n\n    # Check if token is still valid (with a 5 minute buffer)\n    if patient.platform_token_expires_at &gt; datetime.utcnow() + timedelta(minutes=5):\n        return patient.platform_access_token\n\n    # Token is expired or expiring soon, try to refresh\n    if not patient.platform_refresh_token:\n        logger.error(\"No refresh token available\")\n        return None\n\n    # Refresh the token\n    token_response = refresh_fitbit_token(patient.platform_refresh_token)\n    if token_response:\n        if save_fitbit_tokens(patient, token_response):\n            return token_response.get('access_token')\n\n    return None\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.check_rate_limit","title":"<code>check_rate_limit()</code>","text":"<p>Check if we have reached the Fitbit API rate limit.</p> <p>This function implements the rate limiting logic to prevent exceeding Fitbit's API call limits, which could result in temporary service blocks. It tracks call frequency in a sliding window approach and enforces waiting periods when limits are reached.</p> <p>The function checks: 1. If we're in a forced wait period after hitting the rate limit 2. If the hourly window has elapsed, resetting the counter when needed 3. If we've exceeded the hourly call limit</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if we can make API requests, False if we should wait   When False is returned, the application should avoid making   new API calls until the rate limit window resets</p> Source code in <code>app/health_platforms.py</code> <pre><code>def check_rate_limit():\n    \"\"\"\n    Check if we have reached the Fitbit API rate limit.\n\n    This function implements the rate limiting logic to prevent exceeding\n    Fitbit's API call limits, which could result in temporary service blocks.\n    It tracks call frequency in a sliding window approach and enforces\n    waiting periods when limits are reached.\n\n    The function checks:\n    1. If we're in a forced wait period after hitting the rate limit\n    2. If the hourly window has elapsed, resetting the counter when needed\n    3. If we've exceeded the hourly call limit\n\n    Returns:\n        bool: True if we can make API requests, False if we should wait\n              When False is returned, the application should avoid making\n              new API calls until the rate limit window resets\n    \"\"\"\n    global api_rate_limit\n\n    now = datetime.utcnow()\n\n    # If there's a retry_after set and it hasn't passed yet, block requests\n    if api_rate_limit['retry_after'] and now &lt; api_rate_limit['retry_after']:\n        wait_seconds = (api_rate_limit['retry_after'] - now).total_seconds()\n        api_logger.warning(f\"Rate limit active, wait {wait_seconds:.1f} seconds.\")\n        return False\n\n    # If an hour has passed since the last reset, reset the counter\n    if (now - api_rate_limit['last_reset']).total_seconds() &gt;= 3600:\n        api_rate_limit['last_reset'] = now\n        api_rate_limit['calls'] = 0\n        api_logger.info(\"Rate limit counter reset after 1 hour.\")\n\n    # Check if we've exceeded the hourly limit\n    if api_rate_limit['calls'] &gt;= api_rate_limit['hourly_limit']:\n        api_rate_limit['retry_after'] = api_rate_limit['last_reset'] + timedelta(hours=1)\n        api_logger.warning(f\"Rate limit reached ({api_rate_limit['calls']} calls). \"\n                           f\"Try again after {api_rate_limit['retry_after'].strftime('%H:%M:%S')}\")\n        return False\n\n    return True\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.increment_api_call_counter","title":"<code>increment_api_call_counter(response=None)</code>","text":"<p>Increment the API call counter and handle any rate limits.</p> <p>This function updates the API call tracking system after each API request and processes any rate limit information returned from the Fitbit API. It is essential for maintaining compliance with Fitbit's API usage policies and preventing API lockout due to excessive calls.</p> <p>The function handles various rate limiting scenarios: 1. Incrementing the call counter for normal tracking 2. Detecting 429 (Too Many Requests) responses 3. Processing the Retry-After header value to establish waiting periods</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The API response object to check for rate limit headers. If None, only increments the counter without checking for rate limiting headers.</p> <code>None</code> Side effects <p>Updates the global api_rate_limit dictionary with new counts and potentially sets the retry_after timestamp when rate limits are hit.</p> Source code in <code>app/health_platforms.py</code> <pre><code>def increment_api_call_counter(response=None):\n    \"\"\"\n    Increment the API call counter and handle any rate limits.\n\n    This function updates the API call tracking system after each API request\n    and processes any rate limit information returned from the Fitbit API.\n    It is essential for maintaining compliance with Fitbit's API usage policies\n    and preventing API lockout due to excessive calls.\n\n    The function handles various rate limiting scenarios:\n    1. Incrementing the call counter for normal tracking\n    2. Detecting 429 (Too Many Requests) responses\n    3. Processing the Retry-After header value to establish waiting periods\n\n    Args:\n        response (Response, optional): The API response object to check for\n            rate limit headers. If None, only increments the counter without\n            checking for rate limiting headers.\n\n    Side effects:\n        Updates the global api_rate_limit dictionary with new counts and\n        potentially sets the retry_after timestamp when rate limits are hit.\n    \"\"\"\n    global api_rate_limit\n\n    api_rate_limit['calls'] += 1\n\n    # If the response contains rate limit headers, update our limits\n    if response and response.status_code == 429:\n        # Get the Retry-After value if present\n        retry_after = response.headers.get('Retry-After')\n        if retry_after:\n            try:\n                seconds = int(retry_after)\n                api_rate_limit['retry_after'] = datetime.utcnow() + timedelta(seconds=seconds)\n                api_logger.warning(f\"Rate limit reached. Retry-After: {seconds} seconds.\")\n            except ValueError:\n                # If it's not an integer, assume it's an RFC1123 date\n                api_rate_limit['retry_after'] = datetime.utcnow() + timedelta(hours=1)\n                api_logger.warning(\"Rate limit reached. Wait for 1 hour.\")\n        else:\n            # If there's no Retry-After, wait 1 hour for safety\n            api_rate_limit['retry_after'] = datetime.utcnow() + timedelta(hours=1)\n            api_logger.warning(\"Rate limit reached. Wait for 1 hour.\")\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_fitbit_data","title":"<code>get_fitbit_data(patient, data_type, start_date=None, end_date=None)</code>","text":"<p>Retrieve raw data from Fitbit API for the specified data type.</p> <p>This function handles all aspects of communicating with Fitbit's API to retrieve health data, including token management, rate limit checking, proper URL formatting, and error handling. It supports various Fitbit data types as defined in FITBIT_ENDPOINTS.</p> <p>This is a lower-level function that returns the raw API response. For processed and formatted data suitable for the application, use  get_processed_fitbit_data() instead.</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>Patient object with Fitbit connection information</p> required <code>data_type</code> <code>str</code> <p>Type of data to retrieve (heart_rate, steps, sleep, etc.)              Must be one of the keys in FITBIT_ENDPOINTS</p> required <code>start_date</code> <code>str</code> <p>Start date in YYYY-MM-DD format                        Defaults to current date if not provided</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in YYYY-MM-DD format                      Defaults to current date if not provided</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Raw data from Fitbit API or None if any error occurs   (authentication failure, rate limit, invalid data type, etc.)</p> Note <p>This function respects Fitbit's rate limits and may refuse to make a request if the rate limit has been reached. In such cases, None is returned and the caller should wait before retrying.</p> Source code in <code>app/health_platforms.py</code> <pre><code>def get_fitbit_data(patient, data_type, start_date=None, end_date=None):\n    \"\"\"\n    Retrieve raw data from Fitbit API for the specified data type.\n\n    This function handles all aspects of communicating with Fitbit's API\n    to retrieve health data, including token management, rate limit checking,\n    proper URL formatting, and error handling. It supports various Fitbit\n    data types as defined in FITBIT_ENDPOINTS.\n\n    This is a lower-level function that returns the raw API response. For\n    processed and formatted data suitable for the application, use \n    get_processed_fitbit_data() instead.\n\n    Args:\n        patient (Patient): Patient object with Fitbit connection information\n        data_type (str): Type of data to retrieve (heart_rate, steps, sleep, etc.)\n                         Must be one of the keys in FITBIT_ENDPOINTS\n        start_date (str, optional): Start date in YYYY-MM-DD format\n                                   Defaults to current date if not provided\n        end_date (str, optional): End date in YYYY-MM-DD format\n                                 Defaults to current date if not provided\n\n    Returns:\n        dict: Raw data from Fitbit API or None if any error occurs\n              (authentication failure, rate limit, invalid data type, etc.)\n\n    Note:\n        This function respects Fitbit's rate limits and may refuse to make\n        a request if the rate limit has been reached. In such cases, None\n        is returned and the caller should wait before retrying.\n    \"\"\"\n    # Check if we have reached the rate limit\n    if not check_rate_limit():\n        api_logger.warning(f\"Rate limit active, request blocked: {data_type} for patient {patient.id}\")\n        return None\n\n    if data_type not in FITBIT_ENDPOINTS:\n        api_logger.error(f\"Unsupported Fitbit data type: {data_type}\")\n        return None\n\n    access_token = ensure_fresh_token(patient)\n    if not access_token:\n        api_logger.error(f\"Access token not available for patient {patient.id}\")\n        return None\n\n    endpoint_config = FITBIT_ENDPOINTS[data_type]\n\n    # Generate a unique log request ID to track this specific request\n    request_id = str(uuid.uuid4())[:8]\n\n    # Build the appropriate endpoint based on dates and data type\n    if start_date and end_date:\n        # Calculate the difference in days between the dates to check if it's within Fitbit's limits\n        try:\n            start_dt = datetime.strptime(start_date, '%Y-%m-%d')\n            end_dt = datetime.strptime(end_date, '%Y-%m-%d')\n            days_diff = (end_dt - start_dt).days + 1\n\n            # Check if the range exceeds the maximum number of days for this data type\n            max_range = endpoint_config.get('max_range_days', 31)\n\n            if days_diff &gt; max_range:\n                api_logger.warning(f\"[{request_id}] Range of {days_diff} days exceeds the limit of {max_range} for {data_type}. \"\n                                 f\"Limiting to {max_range} days from {end_date}.\")\n                # Limit the range to the maximum allowed, starting from the end date\n                start_date = (end_dt - timedelta(days=max_range-1)).strftime('%Y-%m-%d')\n                api_logger.info(f\"[{request_id}] Modified range: {start_date} - {end_date}\")\n        except ValueError as e:\n            api_logger.error(f\"[{request_id}] Error in date format: {str(e)}\")\n            return None\n\n        # Use the specific range endpoint for this data type\n        if 'range_endpoint' in endpoint_config:\n            endpoint = endpoint_config['range_endpoint'].format(start=start_date, end=end_date)\n            api_logger.info(f\"[{request_id}] Using range endpoint for {data_type}: {endpoint}\")\n        else:\n            # Fallback to the generic format if no range_endpoint is specified\n            base = endpoint_config.get('base_endpoint', '')\n            endpoint = f\"{base}/{start_date}/{end_date}.json\"\n            api_logger.info(f\"[{request_id}] Using generic endpoint for {data_type}: {endpoint}\")\n    else:\n        # If no dates are provided, use the default endpoint\n        endpoint = endpoint_config['endpoint']\n        api_logger.info(f\"[{request_id}] Using default endpoint for {data_type}: {endpoint}\")\n\n    headers = {\n        'Authorization': f'Bearer {access_token}',\n        'Accept-Language': 'it_IT'  # Request data in Italian format\n    }\n\n    api_logger.debug(f\"[{request_id}] Fitbit API call: {endpoint}\")\n\n    try:\n        # Make the API call\n        response = requests.get(\n            f\"{FITBIT_CONFIG['api_base_url']}{endpoint}\",\n            headers=headers\n        )\n          # Increment API call counter\n        increment_api_call_counter(response)\n\n        if response.status_code == 200:\n            data = response.json()\n            api_logger.info(f\"[{request_id}] Data successfully received for {data_type}\")\n\n            # Detailed log for debugging (only in debug mode)\n            if api_logger.isEnabledFor(logging.DEBUG):\n                truncated_data = str(data)[:1000] + \"...\" if len(str(data)) &gt; 1000 else str(data)\n                api_logger.debug(f\"[{request_id}] Response: {truncated_data}\")\n\n            return data\n        elif response.status_code == 429:\n            # Rate limit reached\n            retry_after = response.headers.get('Retry-After', '3600')\n            api_logger.warning(f\"[{request_id}] Rate limit reached. Retry-After: {retry_after}\")\n            return None\n        else:\n            api_logger.error(f\"[{request_id}] Error retrieving data: {response.status_code} - {response.text}\")\n            return None\n    except Exception as e:\n        api_logger.error(f\"[{request_id}] Exception during data retrieval: {str(e)}\")\n        return None\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.extract_nested_value","title":"<code>extract_nested_value(obj, path)</code>","text":"<p>Extract a nested value from an object based on a path.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict</code> <p>The dictionary to extract the value from</p> required <code>path</code> <code>list</code> <p>List of keys forming the path to the value</p> required <p>Returns:</p> Type Description <p>The value at the specified path, or None if not found</p> Source code in <code>app/health_platforms.py</code> <pre><code>def extract_nested_value(obj, path):\n    \"\"\"\n    Extract a nested value from an object based on a path.\n\n    Args:\n        obj (dict): The dictionary to extract the value from\n        path (list): List of keys forming the path to the value\n\n    Returns:\n        The value at the specified path, or None if not found\n    \"\"\"\n    if not path or not isinstance(obj, dict):\n        return None\n\n    key = path[0]\n    if key not in obj:\n        return None\n\n    if len(path) == 1:\n        return obj[key]\n\n    return extract_nested_value(obj[key], path[1:])\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_heart_rate_data","title":"<code>process_heart_rate_data(data, unit, request_id)</code>","text":"<p>Process heart rate data from Fitbit API into standardized format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Raw heart rate data from Fitbit API</p> required <code>unit</code> <code>str</code> <p>The unit for heart rate values</p> required <code>request_id</code> <code>str</code> <p>Request ID for logging</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed heart rate data in standardized format</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_heart_rate_data(data, unit, request_id):\n    \"\"\"\n    Process heart rate data from Fitbit API into standardized format.\n\n    Args:\n        data (dict): Raw heart rate data from Fitbit API\n        unit (str): The unit for heart rate values\n        request_id (str): Request ID for logging\n\n    Returns:\n        list: Processed heart rate data in standardized format\n    \"\"\"\n    heart_results = []\n\n    if 'activities-heart' not in data:\n        return []\n\n    for heart_data in data['activities-heart']:\n        if 'dateTime' in heart_data and 'value' in heart_data and isinstance(heart_data['value'], dict):\n            timestamp = heart_data['dateTime']\n            heart_value = None\n            value_type = None\n\n            # First check if there's a resting heart rate value\n            if 'restingHeartRate' in heart_data['value']:\n                heart_value = heart_data['value']['restingHeartRate']\n                value_type = 'resting'\n                api_logger.info(f\"[{request_id}] Found resting heart rate value: {heart_value} for {timestamp}\")\n            # If not, calculate an average from heart rate zones\n            elif 'heartRateZones' in heart_data['value'] and heart_data['value']['heartRateZones']:\n                zones = heart_data['value']['heartRateZones']\n                zone_values = []\n\n                for zone in zones:\n                    if 'min' in zone and 'max' in zone:\n                        # Calculate the average of each zone\n                        zone_avg = (float(zone['min']) + float(zone['max'])) / 2\n                        zone_values.append(zone_avg)\n\n                if zone_values:\n                    heart_value = sum(zone_values) / len(zone_values)\n                    value_type = 'zone_avg'\n                    api_logger.info(f\"[{request_id}] Calculated average value from zones: {heart_value} for {timestamp}\")\n\n            if heart_value is not None:\n                heart_results.append({\n                    'timestamp': timestamp,\n                    'recorded_at': timestamp,\n                    'value': float(heart_value),\n                    'unit': unit,\n                    'type': value_type\n                })\n\n    api_logger.info(f\"[{request_id}] Processed {len(heart_results)} heart rate values\")\n    return heart_results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_nested_value_list","title":"<code>process_nested_value_list(data_list, timestamp_key, value_path, unit, transform, request_id)</code>","text":"<p>Process a list of data items with nested value paths.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>List of data items to process</p> required <code>timestamp_key</code> <code>str</code> <p>Key to extract timestamp from</p> required <code>value_path</code> <code>list</code> <p>Path to the nested value</p> required <code>unit</code> <code>str</code> <p>Unit for the values</p> required <code>transform</code> <code>callable</code> <p>Function to transform values</p> required <code>request_id</code> <code>str</code> <p>Request ID for logging</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data items</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_nested_value_list(data_list, timestamp_key, value_path, unit, transform, request_id):\n    \"\"\"\n    Process a list of data items with nested value paths.\n\n    Args:\n        data_list (list): List of data items to process\n        timestamp_key (str): Key to extract timestamp from\n        value_path (list): Path to the nested value\n        unit (str): Unit for the values\n        transform (callable): Function to transform values\n        request_id (str): Request ID for logging\n\n    Returns:\n        list: Processed data items\n    \"\"\"\n    results = []\n\n    for item in data_list:\n        if timestamp_key in item:\n            try:\n                nested_value = extract_nested_value(item, value_path)\n                if nested_value is not None:\n                    value = float(nested_value)\n                    timestamp = item[timestamp_key]\n\n                    # Apply transformations\n                    value = transform(value)\n\n                    results.append({\n                        'timestamp': timestamp,\n                        'recorded_at': timestamp,\n                        'value': value,\n                        'unit': unit\n                    })\n            except (ValueError, TypeError) as e:\n                api_logger.error(f\"[{request_id}] Error during value processing: {str(e)}\")\n\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_nested_value_dict","title":"<code>process_nested_value_dict(data_dict, timestamp_key, value_path, unit, transform, request_id)</code>","text":"<p>Process a dictionary with nested value paths.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict</code> <p>Dictionary to process</p> required <code>timestamp_key</code> <code>str</code> <p>Key to extract timestamp from</p> required <code>value_path</code> <code>list</code> <p>Path to the nested value</p> required <code>unit</code> <code>str</code> <p>Unit for the values</p> required <code>transform</code> <code>callable</code> <p>Function to transform values</p> required <code>request_id</code> <code>str</code> <p>Request ID for logging</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data items</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_nested_value_dict(data_dict, timestamp_key, value_path, unit, transform, request_id):\n    \"\"\"\n    Process a dictionary with nested value paths.\n\n    Args:\n        data_dict (dict): Dictionary to process\n        timestamp_key (str): Key to extract timestamp from\n        value_path (list): Path to the nested value\n        unit (str): Unit for the values\n        transform (callable): Function to transform values\n        request_id (str): Request ID for logging\n\n    Returns:\n        list: Processed data items\n    \"\"\"\n    results = []\n\n    if timestamp_key in data_dict:\n        try:\n            nested_value = extract_nested_value(data_dict, value_path)\n            if nested_value is not None:\n                value = float(nested_value)\n                timestamp = data_dict[timestamp_key]\n\n                # Apply transformations\n                value = transform(value)\n\n                results.append({\n                    'timestamp': timestamp,\n                    'recorded_at': timestamp,\n                    'value': value,\n                    'unit': unit\n                })\n        except (ValueError, TypeError) as e:\n            api_logger.error(f\"[{request_id}] Error during value processing: {str(e)}\")\n\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_standard_list","title":"<code>process_standard_list(data_list, timestamp_key, value_key, unit, transform, request_id)</code>","text":"<p>Process a list of data items with standard key-value structure.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>List of data items to process</p> required <code>timestamp_key</code> <code>str</code> <p>Key to extract timestamp from</p> required <code>value_key</code> <code>str</code> <p>Key to extract value from</p> required <code>unit</code> <code>str</code> <p>Unit for the values</p> required <code>transform</code> <code>callable</code> <p>Function to transform values</p> required <code>request_id</code> <code>str</code> <p>Request ID for logging</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data items</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_standard_list(data_list, timestamp_key, value_key, unit, transform, request_id):\n    \"\"\"\n    Process a list of data items with standard key-value structure.\n\n    Args:\n        data_list (list): List of data items to process\n        timestamp_key (str): Key to extract timestamp from\n        value_key (str): Key to extract value from\n        unit (str): Unit for the values\n        transform (callable): Function to transform values\n        request_id (str): Request ID for logging\n\n    Returns:\n        list: Processed data items\n    \"\"\"\n    results = []\n\n    for item in data_list:\n        if value_key in item and timestamp_key in item:\n            try:\n                value = float(item[value_key])\n                timestamp = item[timestamp_key]\n\n                # Apply transformations\n                value = transform(value)\n\n                results.append({\n                    'timestamp': timestamp,\n                    'recorded_at': timestamp,\n                    'value': value,\n                    'unit': unit\n                })\n            except (ValueError, TypeError) as e:\n                api_logger.error(f\"[{request_id}] Error in value processing: {str(e)}\")\n\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_standard_dict","title":"<code>process_standard_dict(data_dict, timestamp_key, value_key, unit, transform, request_id)</code>","text":"<p>Process a dictionary with standard key-value structure.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict</code> <p>Dictionary to process</p> required <code>timestamp_key</code> <code>str</code> <p>Key to extract timestamp from</p> required <code>value_key</code> <code>str</code> <p>Key to extract value from</p> required <code>unit</code> <code>str</code> <p>Unit for the values</p> required <code>transform</code> <code>callable</code> <p>Function to transform values</p> required <code>request_id</code> <code>str</code> <p>Request ID for logging</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data items</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_standard_dict(data_dict, timestamp_key, value_key, unit, transform, request_id):\n    \"\"\"\n    Process a dictionary with standard key-value structure.\n\n    Args:\n        data_dict (dict): Dictionary to process\n        timestamp_key (str): Key to extract timestamp from\n        value_key (str): Key to extract value from\n        unit (str): Unit for the values\n        transform (callable): Function to transform values\n        request_id (str): Request ID for logging\n\n    Returns:\n        list: Processed data items\n    \"\"\"\n    results = []\n\n    if value_key in data_dict and timestamp_key in data_dict:\n        try:\n            value = float(data_dict[value_key])\n            timestamp = data_dict[timestamp_key]\n\n            # Apply transformations\n            value = transform(value)\n\n            results.append({\n                'timestamp': timestamp,\n                'recorded_at': timestamp,\n                'value': value,\n                'unit': unit\n            })\n        except (ValueError, TypeError) as e:\n            api_logger.error(f\"[{request_id}] Error in value processing: {str(e)}\")\n\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.process_fitbit_data","title":"<code>process_fitbit_data(data, data_type)</code>","text":"<p>Process raw Fitbit API data into a standardized format for the application.</p> <p>This function transforms the varied response formats from different Fitbit API endpoints into a consistent structure that can be used throughout the application. It handles the intricacies of each data type according to configurations in FITBIT_ENDPOINTS, including proper key extraction, value transformation, and unit standardization.</p> <p>Data processing includes: - Navigating the nested JSON structure of Fitbit responses - Extracting timestamps and converting to ISO 8601 format - Applying value transformations (e.g., unit conversions) - Adding appropriate measurement units</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Raw data from Fitbit API as returned by get_fitbit_data()</p> required <code>data_type</code> <code>str</code> <p>Type of data being processed (must match a key in FITBIT_ENDPOINTS)</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data in standardized format:   [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]   Returns empty list if data is None, empty, or data_type is unsupported</p> Note <p>Each data point includes: - timestamp: ISO 8601 formatted time when the measurement was taken - value: The numerical value of the measurement (may be transformed from raw value) - unit: The unit of measurement (e.g., 'bpm' for heart rate)</p> Source code in <code>app/health_platforms.py</code> <pre><code>def process_fitbit_data(data, data_type):\n    \"\"\"\n    Process raw Fitbit API data into a standardized format for the application.\n\n    This function transforms the varied response formats from different Fitbit API\n    endpoints into a consistent structure that can be used throughout the application.\n    It handles the intricacies of each data type according to configurations in\n    FITBIT_ENDPOINTS, including proper key extraction, value transformation,\n    and unit standardization.\n\n    Data processing includes:\n    - Navigating the nested JSON structure of Fitbit responses\n    - Extracting timestamps and converting to ISO 8601 format\n    - Applying value transformations (e.g., unit conversions)\n    - Adding appropriate measurement units\n\n    Args:\n        data (dict): Raw data from Fitbit API as returned by get_fitbit_data()\n        data_type (str): Type of data being processed (must match a key in FITBIT_ENDPOINTS)\n\n    Returns:\n        list: Processed data in standardized format:\n              [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]\n              Returns empty list if data is None, empty, or data_type is unsupported\n\n    Note:\n        Each data point includes:\n        - timestamp: ISO 8601 formatted time when the measurement was taken\n        - value: The numerical value of the measurement (may be transformed from raw value)\n        - unit: The unit of measurement (e.g., 'bpm' for heart rate)\n    \"\"\"\n    request_id = str(uuid.uuid4())[:8]  # ID for log tracking\n\n    if not data or data_type not in FITBIT_ENDPOINTS:\n        api_logger.warning(f\"[{request_id}] No data for processing or unsupported data type: {data_type}\")\n        return []\n\n    endpoint_config = FITBIT_ENDPOINTS[data_type]\n    response_key = endpoint_config['response_key']\n    value_key = endpoint_config['value_key']\n    timestamp_key = endpoint_config['timestamp_key']\n    unit = endpoint_config.get('unit', '')\n    transform = endpoint_config.get('value_transform', lambda x: x)  # Default identity function\n\n    api_logger.info(f\"[{request_id}] Processing data {data_type}, response with key {response_key}\")\n\n    # Special handling for heart rate\n    if data_type == 'heart_rate':\n        heart_results = process_heart_rate_data(data, unit, request_id)\n        if heart_results:\n            return heart_results\n\n    # Standard processing\n    # Extract data from response based on response key\n    if response_key in data:\n        current_data = data[response_key]\n    else:\n        api_logger.error(f\"[{request_id}] Response key {response_key} not found in data\")\n        return []\n\n    results = []\n\n    # Handling of nested values (e.g., value.restingHeartRate, value.avg)\n    if '.' in value_key:\n        value_path = value_key.split('.')\n\n        if isinstance(current_data, list):\n            # Process data in list format\n            results = process_nested_value_list(\n                current_data, timestamp_key, value_path, unit, transform, request_id\n            )\n        elif isinstance(current_data, dict):\n            # Process data in dict format\n            results = process_nested_value_dict(\n                current_data, timestamp_key, value_path, unit, transform, request_id\n            )\n    else:\n        # Standard key-value processing\n        if isinstance(current_data, list):\n            # Process list format\n            results = process_standard_list(\n                current_data, timestamp_key, value_key, unit, transform, request_id\n            )\n        elif isinstance(current_data, dict):\n            # Process single dict format\n            results = process_standard_dict(\n                current_data, timestamp_key, value_key, unit, transform, request_id\n            )\n\n    api_logger.info(f\"[{request_id}] Processed {len(results)} results for {data_type}\")\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_vitals_data","title":"<code>get_vitals_data(patient, data_type, start_date=None, end_date=None, cache_duration=300)</code>","text":"<p>Get vital sign data for a patient from their connected health platform.</p> <p>This is the main high-level function used throughout the application to retrieve  patient health data from connected platforms. It handles platform selection, caching to minimize API calls, error recovery, and returns data in a consistent format regardless of the source platform.</p> <p>Features: - Intelligent caching with configurable duration - Automatic platform selection based on patient's connected services - Consistent data format across all vital sign types and platforms - Proper error handling and logging</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>Patient object with connection information</p> required <code>data_type</code> <code>str</code> <p>Type of data to retrieve (heart_rate, steps, etc.)             Can be either a string or VitalSignType enum value</p> required <code>start_date</code> <code>str</code> <p>Start date in YYYY-MM-DD format                        Defaults to current date if not provided</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in YYYY-MM-DD format                      Defaults to current date if not provided</p> <code>None</code> <code>cache_duration</code> <code>int</code> <p>How long to keep data in cache (seconds)                            Defaults to 300 seconds (5 minutes)</p> <code>300</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data in standardized format:   [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]   Returns empty list if data retrieval fails or no data available</p> Note <p>This function is the preferred way to access health data throughout the application, as it abstracts away the complexities of different health platforms and provides consistent caching.</p> Source code in <code>app/health_platforms.py</code> <pre><code>def get_vitals_data(patient, data_type, start_date=None, end_date=None, cache_duration=300):\n    \"\"\"\n    Get vital sign data for a patient from their connected health platform.\n\n    This is the main high-level function used throughout the application to retrieve \n    patient health data from connected platforms. It handles platform selection,\n    caching to minimize API calls, error recovery, and returns data in a consistent\n    format regardless of the source platform.\n\n    Features:\n    - Intelligent caching with configurable duration\n    - Automatic platform selection based on patient's connected services\n    - Consistent data format across all vital sign types and platforms\n    - Proper error handling and logging\n\n    Args:\n        patient (Patient): Patient object with connection information\n        data_type (str): Type of data to retrieve (heart_rate, steps, etc.)\n                        Can be either a string or VitalSignType enum value\n        start_date (str, optional): Start date in YYYY-MM-DD format\n                                   Defaults to current date if not provided\n        end_date (str, optional): End date in YYYY-MM-DD format\n                                 Defaults to current date if not provided\n        cache_duration (int, optional): How long to keep data in cache (seconds)\n                                       Defaults to 300 seconds (5 minutes)\n\n    Returns:\n        list: Processed data in standardized format:\n              [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]\n              Returns empty list if data retrieval fails or no data available\n\n    Note:\n        This function is the preferred way to access health data throughout\n        the application, as it abstracts away the complexities of different\n        health platforms and provides consistent caching.\n    \"\"\"\n    # Generate a unique ID for this request\n    request_id = str(uuid.uuid4())[:8]\n\n    # Normalize the data type (convert to lowercase if it's a string)\n    if isinstance(data_type, str):\n        normalized_data_type = data_type.lower()\n    else:\n        normalized_data_type = data_type\n\n    # Set default dates if not provided\n    if not end_date:\n        end_date = datetime.now().strftime('%Y-%m-%d')\n        api_logger.debug(f\"[{request_id}] End date not provided, using today: {end_date}\")\n\n    if not start_date:\n        # Default: 7 days before end date\n        end_dt = datetime.strptime(end_date, '%Y-%m-%d')\n        start_dt = end_dt - timedelta(days=7)\n        start_date = start_dt.strftime('%Y-%m-%d')\n        api_logger.debug(f\"[{request_id}] Start date not provided, using 7 days before: {start_date}\")\n\n    # Check if we have cached data for this request\n    cache_key = f\"{patient.id}_{normalized_data_type}_{start_date}_{end_date}\"\n    if cache_key in vitals_cache:\n        # Check if the cache is still valid\n        cache_entry = vitals_cache[cache_key]\n        cache_time = cache_entry.get('cache_time')\n        if cache_time:\n            cache_age = (datetime.utcnow() - cache_time).total_seconds()\n            # If the cache is still valid, use the stored data\n            if cache_age &lt; cache_duration:\n                api_logger.info(f\"[{request_id}] Using data from cache for {normalized_data_type}, age: {cache_age:.1f}s\")\n                return cache_entry.get('data', [])\n            else:\n                api_logger.info(f\"[{request_id}] Cache expired for {normalized_data_type}, age: {cache_age:.1f}s\")\n\n    # No valid cache, need to get data from the platform\n    data = []\n\n    # Check which platform the patient is connected to\n    if not patient.connected_platform:\n        api_logger.warning(f\"[{request_id}] Patient {patient.id} not connected to any platform\")\n        return []\n\n    start_time = time.time()  # To measure execution time\n    try:\n        if patient.connected_platform == HealthPlatform.FITBIT:\n            api_logger.info(f\"[{request_id}] Requesting Fitbit data: {normalized_data_type} from {start_date} to {end_date}\")\n            data = get_processed_fitbit_data(patient, normalized_data_type, start_date, end_date)\n        elif patient.connected_platform == HealthPlatform.GOOGLE_HEALTH_CONNECT:\n            # Placeholder for Google Fit implementation\n            api_logger.warning(f\"[{request_id}] Google Fit integration not yet implemented\")\n            data = []\n        elif patient.connected_platform == HealthPlatform.APPLE_HEALTH:\n            # Placeholder for Apple Health implementation\n            api_logger.warning(f\"[{request_id}] Apple Health integration not yet implemented\")\n            data = []\n        else:\n            api_logger.warning(f\"[{request_id}] Unsupported platform: {patient.connected_platform}\")\n            data = []\n\n        # Calculate statistics on the data\n        stats = {\n            \"count\": len(data),\n            \"execution_time\": round(time.time() - start_time, 3)\n        }\n\n        if data and len(data) &gt; 0:\n            # Calculate min, max, avg only if we have data\n            try:\n                values = [item.get('value') for item in data if item.get('value') is not None]\n                if values:\n                    stats[\"min\"] = min(values)\n                    stats[\"max\"] = max(values)\n                    stats[\"avg\"] = sum(values) / len(values)\n\n                    # Get the unit of measure from the first element\n                    stats[\"unit\"] = data[0].get('unit', '')\n            except Exception as stats_error:\n                api_logger.error(f\"[{request_id}] Error calculating statistics: {str(stats_error)}\")\n\n        # Cache the data with statistics\n        vitals_cache[cache_key] = {\n            'data': data,\n            'cache_time': datetime.utcnow(),\n            'statistics': stats,\n            'source': patient.connected_platform.value\n        }\n\n        api_logger.info(f\"[{request_id}] Retrieved {len(data)} data points for {normalized_data_type} in {stats['execution_time']}s\")\n        return data\n    except Exception as e:\n        api_logger.error(f\"[{request_id}] Error retrieving data for patient {patient.id}, type {normalized_data_type}: {str(e)}\")\n        return []\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_processed_fitbit_data","title":"<code>get_processed_fitbit_data(patient, data_type, start_date=None, end_date=None)</code>","text":"<p>Retrieve and process Fitbit data in one consolidated function.</p> <p>This function combines the steps of retrieving raw data from Fitbit's API and processing it into the application's standardized format. It provides a convenient wrapper around get_fitbit_data() and process_fitbit_data() with smart defaults for date ranges and proper error handling.</p> <p>The function handles: - Defaulting to a 7-day range when dates are not specified - Converting date formats as needed - Retrieving the raw data from Fitbit - Processing the data into a standardized format - Error handling at each step</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Patient</code> <p>Patient object with Fitbit connection information</p> required <code>data_type</code> <code>str</code> <p>Type of data to retrieve (must match a key in FITBIT_ENDPOINTS)</p> required <code>start_date</code> <code>str</code> <p>Start date in YYYY-MM-DD format                        Defaults to 7 days before end_date if not provided</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date in YYYY-MM-DD format                      Defaults to current date if not provided</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Processed data in standardized format:   [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]   Returns empty list if data retrieval fails or no data available</p> Source code in <code>app/health_platforms.py</code> <pre><code>def get_processed_fitbit_data(patient, data_type, start_date=None, end_date=None):\n    \"\"\"\n    Retrieve and process Fitbit data in one consolidated function.\n\n    This function combines the steps of retrieving raw data from Fitbit's API\n    and processing it into the application's standardized format. It provides\n    a convenient wrapper around get_fitbit_data() and process_fitbit_data()\n    with smart defaults for date ranges and proper error handling.\n\n    The function handles:\n    - Defaulting to a 7-day range when dates are not specified\n    - Converting date formats as needed\n    - Retrieving the raw data from Fitbit\n    - Processing the data into a standardized format\n    - Error handling at each step\n\n    Args:\n        patient (Patient): Patient object with Fitbit connection information\n        data_type (str): Type of data to retrieve (must match a key in FITBIT_ENDPOINTS)\n        start_date (str, optional): Start date in YYYY-MM-DD format\n                                   Defaults to 7 days before end_date if not provided\n        end_date (str, optional): End date in YYYY-MM-DD format\n                                 Defaults to current date if not provided\n\n    Returns:\n        list: Processed data in standardized format:\n              [{'timestamp': ISO8601, 'value': 123, 'unit': 'xyz'}, ...]\n              Returns empty list if data retrieval fails or no data available\n    \"\"\"\n    # If dates are not specified, use default values\n    if not end_date:\n        end_date = datetime.now().strftime('%Y-%m-%d')\n\n    if not start_date:\n        # Default: 7 days before end date\n        end_dt = datetime.strptime(end_date, '%Y-%m-%d')\n        start_dt = end_dt - timedelta(days=7)\n        start_date = start_dt.strftime('%Y-%m-%d')\n\n    # Generate a unique ID for this data request (for log tracking)\n    request_id = str(uuid.uuid4())[:8]\n    api_logger.info(f\"[{request_id}] Data request: {data_type} for patient {patient.id} from {start_date} to {end_date}\")\n\n    # Convert data_type to lowercase if it's coming from JavaScript/frontend\n    # JavaScript uses uppercase like 'HEART_RATE' while Python backend expects lowercase like 'heart_rate'\n    normalized_data_type = data_type.lower() if isinstance(data_type, str) else data_type\n\n    # Detailed mapping for all supported data types\n    mapping = {\n    'heart_rate': 'heart_rate',\n    'steps': 'steps',\n    'calories': 'calories',\n    'distance': 'distance',\n    'active_minutes': 'active_minutes',\n    'sleep_duration': 'sleep_duration',\n    'floors_climbed': 'floors_climbed',\n    'elevation': 'elevation',\n    'weight': 'weight',\n    'activity_calories': 'activity_calories',\n    'calories_bmr': 'calories_bmr',\n    'minutes_sedentary': 'minutes_sedentary',\n    'minutes_lightly_active': 'minutes_lightly_active',\n    'minutes_fairly_active': 'minutes_fairly_active',\n    'calories_in': 'calories_in',\n    'water': 'water',\n    'breathing_rate': 'breathing_rate',\n    'oxygen_saturation': 'oxygen_saturation',\n    'temperature_core': 'temperature_core',\n    'temperature_skin': 'temperature_skin'\n    }\n\n\n    # Determine the correct API data type\n    api_data_type = mapping.get(normalized_data_type, normalized_data_type)\n    api_logger.debug(f\"[{request_id}] Normalized data type: {normalized_data_type} -&gt; {api_data_type}\")\n\n    # Check if the data type is supported by Fitbit\n    if api_data_type not in FITBIT_ENDPOINTS:\n        api_logger.error(f\"[{request_id}] Data type not supported by Fitbit: {api_data_type}\")\n        return []\n\n    # Multiple data retrieval strategies for greater resilience\n    results = []\n    error_count = 0\n\n    # First attempt: range data with full period\n    api_logger.info(f\"[{request_id}] Attempt 1: Requesting range data for {api_data_type}\")\n\n    try:\n        raw_data = get_fitbit_data(patient, api_data_type, start_date, end_date)\n        if raw_data:\n            # Process normal range data\n            range_results = process_fitbit_data(raw_data, api_data_type)\n            if range_results:\n                results = range_results\n                api_logger.info(f\"[{request_id}] Retrieved {len(range_results)} range data points\")\n            else:\n                api_logger.warning(f\"[{request_id}] No range data available for the period\")\n        else:\n            api_logger.warning(f\"[{request_id}] No data received for {api_data_type}\")\n            error_count += 1\n    except Exception as e:\n        api_logger.error(f\"[{request_id}] Error retrieving or processing range data: {str(e)}\")\n        error_count += 1\n\n    if results:\n        try:\n            # Some timestamps may not have the expected format, so handle exceptions\n            results.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n        except Exception as sort_error:\n            api_logger.warning(f\"[{request_id}] Unable to sort results: {str(sort_error)}\")\n\n    # Apply any additional transformations (e.g., unit of measure)\n    try:\n        endpoint_config = FITBIT_ENDPOINTS[api_data_type]\n        transform_function = endpoint_config.get('value_transform', lambda x: x)\n        unit = endpoint_config.get('unit', '')\n\n        for item in results:\n            # Make sure each item has the correct unit\n            if 'unit' not in item:\n                item['unit'] = unit\n\n            # Add the recorded_at field if it doesn't already exist\n            if 'recorded_at' not in item and 'timestamp' in item:\n                item['recorded_at'] = item['timestamp']\n    except Exception as transform_error:\n        api_logger.error(f\"[{request_id}] Error in final data transformation: {str(transform_error)}\")\n\n    api_logger.info(f\"[{request_id}] Processing completed, returning {len(results)} data points for {api_data_type}\")\n    return results\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.create_link","title":"<code>create_link(patient_id, platform_name)</code>","text":"<p>Create a connection link for a patient to connect to a health platform.</p> <p>This API endpoint generates a unique, time-limited URL that can be shared with a patient to authorize connection to their health platform account (like Fitbit). The link includes a secure UUID and platform information. Once created, the link can be sent to the patient via email or other means.</p> <p>The function performs several validations: - Verifies the patient exists - Ensures the requesting doctor has permission to manage this patient - Validates that the platform name is supported - Checks if the patient already has a connection to this platform</p> <p>Parameters:</p> Name Type Description Default <code>patient_id</code> <code>int</code> <p>ID of the patient in the database</p> required <code>platform_name</code> <code>str</code> <p>Name of the platform to connect to (must match HealthPlatform enum)</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>JSON object with: success (bool): Whether the operation succeeded message (str): Description message link (dict): Details of the created link (if successful)     - uuid: Unique identifier for this link     - url: Full URL that the patient should visit     - expires_at: ISO 8601 timestamp when the link will expire</p> Status Codes <p>201: Link created successfully 400: Invalid platform name 403: Not authorized to manage this patient 404: Patient not found 409: Patient already connected to this platform 500: Server error</p> <p>Route: /health/link Method: POST Auth: Required (Doctor)</p> Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/create_link/&lt;int:patient_id&gt;/&lt;string:platform_name&gt;', methods=['POST'])\n@login_required\ndef create_link(patient_id, platform_name):\n    \"\"\"\n    Create a connection link for a patient to connect to a health platform.\n\n    This API endpoint generates a unique, time-limited URL that can be shared\n    with a patient to authorize connection to their health platform account\n    (like Fitbit). The link includes a secure UUID and platform information.\n    Once created, the link can be sent to the patient via email or other means.\n\n    The function performs several validations:\n    - Verifies the patient exists\n    - Ensures the requesting doctor has permission to manage this patient\n    - Validates that the platform name is supported\n    - Checks if the patient already has a connection to this platform\n\n    Args:\n        patient_id (int): ID of the patient in the database\n        platform_name (str): Name of the platform to connect to (must match HealthPlatform enum)\n\n    Returns:\n        Response: JSON object with:\n            success (bool): Whether the operation succeeded\n            message (str): Description message\n            link (dict): Details of the created link (if successful)\n                - uuid: Unique identifier for this link\n                - url: Full URL that the patient should visit\n                - expires_at: ISO 8601 timestamp when the link will expire\n\n    Status Codes:\n        201: Link created successfully\n        400: Invalid platform name\n        403: Not authorized to manage this patient\n        404: Patient not found\n        409: Patient already connected to this platform\n        500: Server error\n\n    Route: /health/link\n    Method: POST\n    Auth: Required (Doctor)\n    \"\"\"\n    try:\n        patient = Patient.query.get_or_404(patient_id)\n\n        # Ensure the doctor is associated with this patient\n        if patient not in current_user.patients.all():\n            return jsonify({\n                'success': False,\n                'message': _('You are not authorized to manage this patient')\n            }), 403\n\n        # Convert platform name to enum\n        try:\n            platform = HealthPlatform(platform_name)\n        except ValueError:\n            return jsonify({\n                'success': False,\n                'message': _('Invalid platform name')\n            }), 400\n\n        # Generate link\n        link = generate_platform_link(patient, current_user, platform)\n\n        if link:\n            # Return link details\n            return jsonify({\n                'success': True,\n                'link_uuid': link.uuid,\n                'expires_at': link.expires_at.isoformat(),\n                'platform': platform.value,\n                'connect_url': url_for('health.connect_platform', link_uuid=link.uuid, _external=True)\n            })\n        else:\n            return jsonify({\n                'success': False,\n                'message': _('Error generating platform link')\n            }), 500\n    except Exception as e:\n        logger.error(f\"Error creating health platform link: {str(e)}\")\n        return jsonify({\n            'success': False,\n            'message': _('An error occurred')\n        }), 500\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.connect_platform","title":"<code>connect_platform(link_uuid)</code>","text":"<p>Handle the patient-facing connection flow to a health platform.</p> <p>This web endpoint presents the connection interface to patients who have received a link from their doctor. It displays a page explaining the health platform connection process and provides buttons to initiate the OAuth flow for the specific platform (Fitbit, Google Health Connect, etc.).</p> <p>The function: - Validates the provided UUID corresponds to an active, non-expired link - Retrieves the associated patient and platform information - Renders a user-friendly interface explaining what data will be shared - Provides platform-specific connection buttons that initiate OAuth</p> <p>Parameters:</p> Name Type Description Default <code>link_uuid</code> <code>str</code> <p>UUID of the health platform link as generated by create_link()</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>HTML page with platform connection UI or error message      Will redirect to OAuth provider if the user initiates connection</p> Template <p>health_connect.html - Success case with connection UI health_connect_result.html - Error cases with appropriate message</p> <p>Route: /health/connect/ Method: GET Auth: Not required (patient-facing public URL) Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/connect/&lt;string:link_uuid&gt;')\ndef connect_platform(link_uuid):\n    \"\"\"\n    Handle the patient-facing connection flow to a health platform.\n\n    This web endpoint presents the connection interface to patients who have\n    received a link from their doctor. It displays a page explaining the\n    health platform connection process and provides buttons to initiate the\n    OAuth flow for the specific platform (Fitbit, Google Health Connect, etc.).\n\n    The function:\n    - Validates the provided UUID corresponds to an active, non-expired link\n    - Retrieves the associated patient and platform information\n    - Renders a user-friendly interface explaining what data will be shared\n    - Provides platform-specific connection buttons that initiate OAuth\n\n    Args:\n        link_uuid (str): UUID of the health platform link as generated by create_link()\n\n    Returns:\n        Response: HTML page with platform connection UI or error message\n                 Will redirect to OAuth provider if the user initiates connection\n\n    Template:\n        health_connect.html - Success case with connection UI\n        health_connect_result.html - Error cases with appropriate message\n\n    Route: /health/connect/&lt;uuid&gt;\n    Method: GET\n    Auth: Not required (patient-facing public URL)\n    \"\"\"\n    # Get the link\n    link = get_link_by_uuid(link_uuid)\n    if not link:\n        flash(_('Invalid or expired link'), 'danger')\n        return render_template('health_connect_result.html', \n                              success=False,\n                              message=_('The link you are trying to use is invalid or has expired'),\n                              now=datetime.now())\n      # Check if link is expired\n    if link.is_expired():\n        flash(_('This link has expired'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link you are trying to use has expired'),\n                              now=datetime.now())\n\n    # Check if link was already used\n    if link.used:\n        flash(_('This link has already been used'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link you are trying to use has already been used'),\n                              now=datetime.now())\n\n    # Store link UUID in session for the callback\n    session['link_uuid'] = link_uuid\n    session['platform'] = link.platform.value\n\n    # Get the patient\n    patient = Patient.query.get(link.patient_id)\n\n    # Show the connect page\n    return render_template('health_connect.html',\n                          link=link,\n                          patient=patient,\n                          platform=link.platform.value)\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.start_auth","title":"<code>start_auth(platform_name)</code>","text":"<p>Start the OAuth2 authorization flow for the specified health platform.</p> <p>This endpoint initiates the OAuth2 authorization flow when a patient clicks on a platform connection button. It validates the session, retrieves the appropriate authorization URL for the selected platform, and redirects the user to the platform's authorization page.</p> <p>The function handles: - Session validation to ensure the connection link is valid - Link validation to prevent expired or misused links - Platform-specific OAuth2 flow initiation - Security state parameter setup to prevent CSRF attacks</p> <p>Currently supported platforms: - Fitbit - Google Health Connect (planned) - Apple Health (planned)</p> <p>Parameters:</p> Name Type Description Default <code>platform_name</code> <code>str</code> <p>Name of the platform to connect to (must match HealthPlatform enum)</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>Redirect to the OAuth provider's authorization page or error page      if validation fails</p> <p>Route: /health/start-auth/ Method: GET Auth: Not required (patient-facing, protected by session and link validation) Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/start_auth/&lt;string:platform_name&gt;')\ndef start_auth(platform_name):\n    \"\"\"\n    Start the OAuth2 authorization flow for the specified health platform.\n\n    This endpoint initiates the OAuth2 authorization flow when a patient clicks\n    on a platform connection button. It validates the session, retrieves the\n    appropriate authorization URL for the selected platform, and redirects the\n    user to the platform's authorization page.\n\n    The function handles:\n    - Session validation to ensure the connection link is valid\n    - Link validation to prevent expired or misused links\n    - Platform-specific OAuth2 flow initiation\n    - Security state parameter setup to prevent CSRF attacks\n\n    Currently supported platforms:\n    - Fitbit\n    - Google Health Connect (planned)\n    - Apple Health (planned)\n\n    Args:\n        platform_name (str): Name of the platform to connect to (must match HealthPlatform enum)\n\n    Returns:\n        Response: Redirect to the OAuth provider's authorization page or error page\n                 if validation fails\n\n    Route: /health/start-auth/&lt;platform_name&gt;\n    Method: GET\n    Auth: Not required (patient-facing, protected by session and link validation)\n    \"\"\"# Check if we have a link UUID in the session\n    link_uuid = session.get('link_uuid')\n    if not link_uuid:\n        flash(_('Invalid session'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('Your session is invalid or has expired'),\n                              now=datetime.now())\n\n    # Get the link\n    link = get_link_by_uuid(link_uuid)\n\n    if not link or link.is_expired() or link.used:\n        flash(_('Invalid or expired link'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link you are trying to use is invalid or has expired'),\n                              now=datetime.now())\n      # Generate the authorization URL based on the platform\n    if platform_name == 'fitbit':\n        auth_url = get_fitbit_authorization_url(link_uuid)\n        return redirect(auth_url)\n    else:\n        flash(_('Unsupported platform'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The platform you selected is not supported'),\n                              now=datetime.now())\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.oauth_callback","title":"<code>oauth_callback()</code>","text":"<p>Handle the callback from OAuth2 providers after patient authorization.</p> <p>This endpoint processes the response from health platforms after a patient has authorized or denied access to their data. It handles both successful authorizations (receiving an authorization code) and errors/rejections.</p> <p>The complete OAuth2 flow involves: 1. Getting the authorization code from the redirect 2. Exchanging the code for access and refresh tokens 3. Storing the tokens securely in the patient record 4. Marking the connection as active in the system 5. Recording the connection event in the audit log</p> <p>Error handling covers: - User rejections of authorization - Missing or invalid state parameters - Failed token exchanges - Database errors during token storage</p> <p>Returns:</p> Name Type Description <code>Response</code> <p>HTML page with success or error message to display to the patient</p> <p>Route: /health/oauth-callback Method: GET Auth: Not required (patient-facing callback)</p> Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/oauth_callback')\ndef oauth_callback():\n    \"\"\"\n    Handle the callback from OAuth2 providers after patient authorization.\n\n    This endpoint processes the response from health platforms after a patient\n    has authorized or denied access to their data. It handles both successful\n    authorizations (receiving an authorization code) and errors/rejections.\n\n    The complete OAuth2 flow involves:\n    1. Getting the authorization code from the redirect\n    2. Exchanging the code for access and refresh tokens\n    3. Storing the tokens securely in the patient record\n    4. Marking the connection as active in the system\n    5. Recording the connection event in the audit log\n\n    Error handling covers:\n    - User rejections of authorization\n    - Missing or invalid state parameters\n    - Failed token exchanges\n    - Database errors during token storage\n\n    Args:\n        None - Parameters are received via query string\n               - code: Authorization code from OAuth provider\n               - state: Link UUID for verification\n               - error/error_description: Details if auth failed\n\n    Returns:\n        Response: HTML page with success or error message to display to the patient\n\n    Route: /health/oauth-callback\n    Method: GET\n    Auth: Not required (patient-facing callback)\n    \"\"\"\n    # Check for error parameter\n    error = request.args.get('error')\n    if error:\n        flash(_('Authentication failed: %(error)s', error=error), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The health platform authentication failed'),\n                              now=datetime.now())\n\n    # Get the authorization code\n    code = request.args.get('code')\n    if not code:\n        flash(_('No authorization code received'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('No authorization code was received from the health platform'),\n                              now=datetime.now())\n      # Get the state (link UUID)\n    state = request.args.get('state')\n    if not state:\n        flash(_('Invalid state parameter'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The state parameter is missing from the callback'),\n                              now=datetime.now())\n\n    # Get the link\n    link = get_link_by_uuid(state)\n\n    if not link:\n        flash(_('Invalid link'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link is invalid'),\n                              now=datetime.now())\n      # Check if link is expired\n    if link.is_expired():\n        flash(_('This link has expired'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link has expired'),\n                              now=datetime.now())\n\n    # Check if link was already used\n    if link.used:\n        flash(_('This link has already been used'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The link has already been used'),\n                              now=datetime.now())\n\n    # Get the patient\n    patient = Patient.query.get(link.patient_id)\n\n    # Exchange the code for a token based on the platform\n    if link.platform == HealthPlatform.FITBIT:\n        token_response = exchange_fitbit_code_for_token(code)\n\n        if not token_response:\n            flash(_('Failed to exchange authorization code for token'), 'danger')\n            return render_template('health_connect_result.html',\n                                  success=False,\n                                  message=_('Failed to exchange the authorization code for a token'))\n\n        # Save the tokens to the patient record\n        if save_fitbit_tokens(patient, token_response):\n            # Mark the link as used\n            link.used = True\n            db.session.commit()\n              # Log the connection\n            try:\n                log_platform_connection(link.doctor_id, patient, HealthPlatform.FITBIT.value)\n            except Exception as log_error:\n                logger.error(f\"Error logging platform connection: {str(log_error)}\")\n\n            flash(_('Successfully connected to Fitbit'), 'success')\n            return render_template('health_connect_result.html',\n                                  success=True,\n                                  message=_('Your Fitbit account has been successfully connected'),\n                                  now=datetime.now())\n        else:\n            flash(_('Failed to save token data'), 'danger')\n            return render_template('health_connect_result.html',\n                                  success=False,\n                                  message=_('Failed to save the token data'),\n                                  now=datetime.now())\n    else:\n        flash(_('Unsupported platform'), 'danger')\n        return render_template('health_connect_result.html',\n                              success=False,\n                              message=_('The platform is not supported'),\n                              now=datetime.now())\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.check_connection","title":"<code>check_connection(patient_id)</code>","text":"<p>API endpoint to check if a patient is connected to a health platform.</p> <p>This endpoint allows doctors to verify if a patient has an active connection to any health platform and retrieve the connection details. It's commonly used by the frontend to determine if health data can be fetched and when displaying connection status indicators.</p> <p>The response includes: - Connection status (true/false) - Platform name if connected - Connection timestamp - Token expiration information</p> <p>For disconnected patients, it provides information on why no connection exists (never connected, expired tokens, manually disconnected).</p> <p>Parameters:</p> Name Type Description Default <code>patient_id</code> <code>int</code> <p>ID of the patient to check</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>JSON object with: connected (bool): Whether the patient is connected platform (str, optional): Name of the connected platform if any connected_since (str, optional): ISO timestamp of when connection was established expires_at (str, optional): ISO timestamp of when the token expires message (str): Descriptive message about the connection status</p> Status Codes <p>200: Request processed successfully 403: Not authorized to view this patient's data 404: Patient not found 500: Server error</p> <p>Route: /health/connection/ Method: GET Auth: Required (Doctor) Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/check_connection/&lt;int:patient_id&gt;')\n@login_required\ndef check_connection(patient_id):\n    \"\"\"\n    API endpoint to check if a patient is connected to a health platform.\n\n    This endpoint allows doctors to verify if a patient has an active connection\n    to any health platform and retrieve the connection details. It's commonly\n    used by the frontend to determine if health data can be fetched and when\n    displaying connection status indicators.\n\n    The response includes:\n    - Connection status (true/false)\n    - Platform name if connected\n    - Connection timestamp\n    - Token expiration information\n\n    For disconnected patients, it provides information on why no connection\n    exists (never connected, expired tokens, manually disconnected).\n\n    Args:\n        patient_id (int): ID of the patient to check\n\n    Returns:\n        Response: JSON object with:\n            connected (bool): Whether the patient is connected\n            platform (str, optional): Name of the connected platform if any\n            connected_since (str, optional): ISO timestamp of when connection was established\n            expires_at (str, optional): ISO timestamp of when the token expires\n            message (str): Descriptive message about the connection status\n\n    Status Codes:\n        200: Request processed successfully\n        403: Not authorized to view this patient's data\n        404: Patient not found\n        500: Server error\n\n    Route: /health/connection/&lt;patient_id&gt;\n    Method: GET\n    Auth: Required (Doctor)\n    \"\"\"\n    try:\n        patient = Patient.query.get_or_404(patient_id)\n\n        # Ensure the doctor is associated with this patient\n        if patient not in current_user.patients.all():\n            return jsonify({\n                'connected': False,\n                'message': _('You are not authorized to view this patient\\'s data')\n            }), 403\n\n        # Check if patient has a connected platform\n        if patient.connected_platform:\n            # Verify token is still valid\n            if patient.platform_token_expires_at and patient.platform_access_token:\n                # Check if the token is still valid with the service\n                is_valid = False\n\n                # Platform-specific validity check\n                if patient.connected_platform == HealthPlatform.FITBIT:\n                    # Try to make a simple API call to check if the token is still valid\n                    try:\n                        headers = {\n                            'Authorization': f'Bearer {patient.platform_access_token}'\n                        }\n                        response = requests.get(\n                            f\"{FITBIT_CONFIG['api_base_url']}/1/user/-/profile.json\",\n                            headers=headers\n                        )\n                        is_valid = response.status_code == 200\n                    except Exception as e:\n                        logger.error(f\"Error checking Fitbit token validity: {str(e)}\")\n                        is_valid = False\n\n                if is_valid:\n                    return jsonify({\n                        'connected': True,\n                        'platform': patient.connected_platform.value,\n                        'connected_since': patient.platform_token_expires_at.isoformat() if patient.platform_token_expires_at else None,\n                        'token_expires_at': patient.platform_token_expires_at.isoformat() if patient.platform_token_expires_at else None\n                    })\n                else:\n                    # Token is invalid, clear connection data\n                    patient.connected_platform = None\n                    patient.platform_access_token = None\n                    patient.platform_refresh_token = None\n                    patient.platform_token_expires_at = None\n                    db.session.commit()\n\n                    # Log the disconnection due to invalid token\n                    try:\n                        log_platform_disconnection(current_user.id, patient, patient.connected_platform.value)\n                    except Exception as log_error:\n                        logger.error(f\"Error logging platform disconnection: {str(log_error)}\")\n\n                    return jsonify({\n                        'connected': False,\n                        'message': _('Token has expired or been revoked')\n                    })\n            else:\n                return jsonify({\n                    'connected': False,\n                    'message': _('Incomplete token data')\n                })\n        else:\n            return jsonify({\n                'connected': False,\n                'message': _('Not connected to any health platform')\n            })\n    except Exception as e:\n        logger.error(f\"Error checking connection status: {str(e)}\")\n        return jsonify({\n            'connected': False,\n            'message': _('Error checking connection status')\n        }), 500\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.disconnect_platform","title":"<code>disconnect_platform(patient_id, platform)</code>","text":"<p>API endpoint to disconnect a patient from a health platform.</p> <p>This endpoint allows doctors to remove a patient's connection to a health platform. It revokes the OAuth tokens and clears connection data from the patient record. This is useful when: - A patient requests disconnection - The patient changes accounts - Privacy concerns require removing access - Repeated token refresh failures indicate an invalid connection</p> <p>The function: - Validates doctor authorization for the patient - Verifies the platform is valid - Checks if the patient is actually connected to the specified platform - Clears all token and connection data - Adds an audit log entry for the disconnection</p> <p>Parameters:</p> Name Type Description Default <code>patient_id</code> <code>int</code> <p>ID of the patient to disconnect</p> required <code>platform</code> <code>str</code> <p>Name of the platform to disconnect (must match HealthPlatform enum)</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>JSON object with: success (bool): Whether the disconnection was successful message (str): Description message about the result</p> Status Codes <p>200: Disconnection successful 400: Invalid platform name 403: Not authorized to manage this patient's connections 404: Patient not found or not connected to specified platform 500: Server error</p> <p>Route: /health/disconnect// Method: POST Auth: Required (Doctor) Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/disconnect/&lt;int:patient_id&gt;/&lt;string:platform&gt;', methods=['POST'])\n@login_required\ndef disconnect_platform(patient_id, platform):\n    \"\"\"\n    API endpoint to disconnect a patient from a health platform.\n\n    This endpoint allows doctors to remove a patient's connection to a health\n    platform. It revokes the OAuth tokens and clears connection data from the\n    patient record. This is useful when:\n    - A patient requests disconnection\n    - The patient changes accounts\n    - Privacy concerns require removing access\n    - Repeated token refresh failures indicate an invalid connection\n\n    The function:\n    - Validates doctor authorization for the patient\n    - Verifies the platform is valid\n    - Checks if the patient is actually connected to the specified platform\n    - Clears all token and connection data\n    - Adds an audit log entry for the disconnection\n\n    Args:\n        patient_id (int): ID of the patient to disconnect\n        platform (str): Name of the platform to disconnect (must match HealthPlatform enum)\n\n    Returns:\n        Response: JSON object with:\n            success (bool): Whether the disconnection was successful\n            message (str): Description message about the result\n\n    Status Codes:\n        200: Disconnection successful\n        400: Invalid platform name\n        403: Not authorized to manage this patient's connections\n        404: Patient not found or not connected to specified platform\n        500: Server error\n\n    Route: /health/disconnect/&lt;patient_id&gt;/&lt;platform&gt;\n    Method: POST\n    Auth: Required (Doctor)\n    \"\"\"\n    try:\n        patient = Patient.query.get_or_404(patient_id)\n\n        # Ensure the doctor is associated with this patient\n        if patient not in current_user.patients.all():\n            return jsonify({\n                'success': False,\n                'message': _('You are not authorized to manage this patient\\'s connections')\n            }), 403\n\n        # Convert platform string to enum value\n        try:\n            platform_enum = HealthPlatform(platform)\n        except ValueError:\n            return jsonify({\n                'success': False,\n                'message': _('Invalid platform specified')\n            }), 400\n\n        # Check if patient is actually connected to this platform\n        if patient.connected_platform != platform_enum:\n            return jsonify({\n                'success': False,\n                'message': _('Patient is not connected to the specified platform')\n            }), 400\n\n        # Clear connection data\n        patient.connected_platform = None\n        patient.platform_access_token = None\n        patient.platform_refresh_token = None\n        patient.platform_token_expires_at = None\n        db.session.commit()\n\n        # Log the disconnection\n        try:\n            log_platform_disconnection(current_user.id, patient, platform)\n        except Exception as log_error:\n            logger.error(f\"Error logging platform disconnection: {str(log_error)}\")\n\n        return jsonify({\n            'success': True,\n            'message': _('Successfully disconnected from health platform')\n        })\n    except Exception as e:\n        logger.error(f\"Error disconnecting from health platform: {str(e)}\")\n        return jsonify({\n            'success': False,\n            'message': _('Error disconnecting from health platform')\n        }), 500\n</code></pre>"},{"location":"modules/health_platforms.html#app.health_platforms.get_data","title":"<code>get_data(data_type, patient_id)</code>","text":"<p>API endpoint to retrieve health data from connected platforms.</p> <p>This endpoint provides a unified interface for the frontend to request health data of various types for a patient. It's primarily used for AJAX requests from the vitals monitoring page to populate charts and data tables. The function handles platform selection, permission checking, and returns data in a consistent format regardless of the source platform.</p> <p>The endpoint supports date range filtering and leverages the caching system to minimize API calls to health platforms. All data is returned in a standardized format suitable for direct use in frontend visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>Type of data to retrieve (must be a valid VitalSignType value)</p> required <code>patient_id</code> <code>int</code> <p>ID of the patient to get data for</p> required Query Parameters <p>start_date (str, optional): Start date in YYYY-MM-DD format                            Defaults to 7 days before end_date end_date (str, optional): End date in YYYY-MM-DD format                          Defaults to current date</p> <p>Returns:</p> Name Type Description <code>Response</code> <p>JSON object with: success (bool): Whether the data retrieval was successful data (list): Array of data points in format:       [{'timestamp': ISO8601, 'value': numeric, 'unit': string}, ...] message (str, optional): Error description if success is false</p> Status Codes <p>200: Data retrieved successfully 403: Not authorized to access this patient's data 404: Patient not found 500: Server error or health platform error</p> <p>Route: /health/data// Method: GET Auth: Required (Doctor) Source code in <code>app/health_platforms.py</code> <pre><code>@health_bp.route('/data/&lt;string:data_type&gt;/&lt;int:patient_id&gt;')\n@login_required\ndef get_data(data_type, patient_id):\n    \"\"\"\n    API endpoint to retrieve health data from connected platforms.\n\n    This endpoint provides a unified interface for the frontend to request health\n    data of various types for a patient. It's primarily used for AJAX requests from\n    the vitals monitoring page to populate charts and data tables. The function\n    handles platform selection, permission checking, and returns data in a consistent\n    format regardless of the source platform.\n\n    The endpoint supports date range filtering and leverages the caching system\n    to minimize API calls to health platforms. All data is returned in a standardized\n    format suitable for direct use in frontend visualizations.\n\n    Args:\n        data_type (str): Type of data to retrieve (must be a valid VitalSignType value)\n        patient_id (int): ID of the patient to get data for\n\n    Query Parameters:\n        start_date (str, optional): Start date in YYYY-MM-DD format\n                                   Defaults to 7 days before end_date\n        end_date (str, optional): End date in YYYY-MM-DD format\n                                 Defaults to current date\n\n    Returns:\n        Response: JSON object with:\n            success (bool): Whether the data retrieval was successful\n            data (list): Array of data points in format:\n                  [{'timestamp': ISO8601, 'value': numeric, 'unit': string}, ...]\n            message (str, optional): Error description if success is false\n\n    Status Codes:\n        200: Data retrieved successfully\n        403: Not authorized to access this patient's data\n        404: Patient not found\n        500: Server error or health platform error\n\n    Route: /health/data/&lt;data_type&gt;/&lt;patient_id&gt;\n    Method: GET\n    Auth: Required (Doctor)\n    \"\"\"\n    try:\n        # Get start_date and end_date from query params if provided\n        start_date = request.args.get('start_date', None)\n        end_date = request.args.get('end_date', None)\n\n        patient = Patient.query.get_or_404(patient_id)\n\n        # Ensure the doctor is associated with this patient\n        if patient not in current_user.patients.all():\n            return jsonify({\n                'success': False,\n                'message': _('You are not authorized to view this patient\\'s data')\n            }), 403\n\n        # Check if patient is connected to a platform\n        if not patient.connected_platform:\n            return jsonify({\n                'success': False,\n                'message': _('Patient is not connected to any health platform'),\n                'connect_url': url_for('views.patient_vitals', patient_id=patient_id)\n            }), 404\n\n        # Get data based on the platform\n        if patient.connected_platform == HealthPlatform.FITBIT:\n            data = get_processed_fitbit_data(patient, data_type, start_date, end_date)\n\n            # Log the data sync\n            try:\n                result_summary = {\n                    'data_points': len(data) if data else 0,\n                    'start_date': start_date,\n                    'end_date': end_date\n                }\n                log_data_sync(current_user.id, patient, patient.connected_platform.value, data_type, result_summary)\n            except Exception as log_error:\n                logger.error(f\"Error logging data sync: {str(log_error)}\")\n\n            if data:\n                return jsonify(data)\n            else:\n                return jsonify([])\n        else:\n            return jsonify({\n                'success': False,\n                'message': _('Unsupported platform'),\n                'platform': patient.connected_platform.value\n            }), 400\n    except Exception as e:\n        logger.error(f\"Error retrieving health platform data: {str(e)}\")\n        return jsonify({\n            'success': False,\n            'message': _('An error occurred')\n        }), 500\n</code></pre>"},{"location":"modules/health_platforms_config.html","title":"Health Platforms Config","text":"<p>Health Platforms Configuration Module. This module contains configuration settings for integrations with external health platforms like Fitbit, Google Fit, Apple Health, etc. It defines: 1. API endpoints, credentials and authentication settings 2. Data mapping from external platforms to internal data models 3. Configuration for data retrieval, processing, and visualization 4. Rate limiting and caching parameters Environment variables are used for sensitive information like client IDs and secrets.</p>"},{"location":"modules/health_platforms_config.html#app.health_platforms_config.FITBIT_CONFIG","title":"<code>FITBIT_CONFIG = {'client_id': os.environ['FITBIT_CLIENT_ID'], 'client_secret': os.environ['FITBIT_CLIENT_SECRET'], 'redirect_uri': os.environ['FITBIT_REDIRECT_URI'], 'authorize_url': 'https://www.fitbit.com/oauth2/authorize', 'token_url': 'https://api.fitbit.com/oauth2/token', 'scope': 'activity heartrate sleep weight profile electrocardiogram cardio_fitness irregular_rhythm_notifications location nutrition oxygen_saturation respiratory_rate temperature', 'api_base_url': 'https://api.fitbit.com'}</code>  <code>module-attribute</code>","text":""},{"location":"modules/health_platforms_config.html#app.health_platforms_config.FITBIT_ENDPOINTS","title":"<code>FITBIT_ENDPOINTS = {'heart_rate': {'endpoint': '/1/user/-/activities/heart/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/heart/date', 'daily_endpoint': '/1/user/-/activities/heart/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/heart/date/{start}/{end}.json', 'max_range_days': 30, 'response_key': 'activities-heart', 'value_key': 'value.restingHeartRate', 'timestamp_key': 'dateTime', 'unit': 'bpm', 'oauth_scope': 'heartrate', 'value_transform': lambda x: x, 'chart_color': '#FF5252'}, 'steps': {'endpoint': '/1/user/-/activities/steps/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/steps/date', 'daily_endpoint': '/1/user/-/activities/steps/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/steps/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-steps', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'steps', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#2196F3'}, 'calories': {'endpoint': '/1/user/-/activities/calories/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/calories/date', 'daily_endpoint': '/1/user/-/activities/calories/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/calories/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-calories', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'kcal', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#FF9800'}, 'distance': {'endpoint': '/1/user/-/activities/distance/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/distance/date', 'daily_endpoint': '/1/user/-/activities/distance/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/distance/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-distance', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'km', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#4CAF50'}, 'active_minutes': {'endpoint': '/1/user/-/activities/minutesVeryActive/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/minutesVeryActive/date', 'daily_endpoint': '/1/user/-/activities/minutesVeryActive/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/minutesVeryActive/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-minutesVeryActive', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'min', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#9C27B0'}, 'sleep_duration': {'endpoint': '/1.2/user/-/sleep/date/today.json', 'base_endpoint': '/1.2/user/-/sleep/date', 'daily_endpoint': '/1.2/user/-/sleep/date/{date}.json', 'range_endpoint': '/1.2/user/-/sleep/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'sleep', 'value_key': 'minutesAsleep', 'timestamp_key': 'startTime', 'unit': 'min', 'oauth_scope': 'sleep', 'value_transform': lambda x: x / 60, 'chart_color': '#3F51B5'}, 'floors_climbed': {'endpoint': '/1/user/-/activities/floors/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/floors/date', 'daily_endpoint': '/1/user/-/activities/floors/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/floors/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-floors', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'floors', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#795548'}, 'elevation': {'endpoint': '/1/user/-/activities/elevation/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/elevation/date', 'daily_endpoint': '/1/user/-/activities/elevation/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/elevation/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-elevation', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'm', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#795548'}, 'weight': {'endpoint': '/1/user/-/body/log/weight/date/today/1w.json', 'base_endpoint': '/1/user/-/body/log/weight/date', 'daily_endpoint': '/1/user/-/body/log/weight/date/{date}.json', 'range_endpoint': '/1/user/-/body/log/weight/date/{start}/{end}.json', 'max_range_days': 31, 'response_key': 'weight', 'value_key': 'weight', 'timestamp_key': 'date', 'unit': 'kg', 'oauth_scope': 'weight', 'value_transform': lambda x: x, 'chart_color': '#607D8B'}, 'activity_calories': {'endpoint': '/1/user/-/activities/activityCalories/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/activityCalories/date', 'daily_endpoint': '/1/user/-/activities/activityCalories/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/activityCalories/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-activityCalories', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'kcal', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#FF5722'}, 'calories_bmr': {'endpoint': '/1/user/-/activities/caloriesBMR/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/caloriesBMR/date', 'daily_endpoint': '/1/user/-/activities/caloriesBMR/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/caloriesBMR/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-caloriesBMR', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'kcal', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#FF5722'}, 'minutes_sedentary': {'endpoint': '/1/user/-/activities/minutesSedentary/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/minutesSedentary/date', 'daily_endpoint': '/1/user/-/activities/minutesSedentary/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/minutesSedentary/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-minutesSedentary', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'min', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#9E9E9E'}, 'minutes_lightly_active': {'endpoint': '/1/user/-/activities/minutesLightlyActive/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/minutesLightlyActive/date', 'daily_endpoint': '/1/user/-/activities/minutesLightlyActive/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/minutesLightlyActive/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-minutesLightlyActive', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'min', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#8BC34A'}, 'minutes_fairly_active': {'endpoint': '/1/user/-/activities/minutesFairlyActive/date/today/1w.json', 'base_endpoint': '/1/user/-/activities/minutesFairlyActive/date', 'daily_endpoint': '/1/user/-/activities/minutesFairlyActive/date/{date}/1d.json', 'range_endpoint': '/1/user/-/activities/minutesFairlyActive/date/{start}/{end}.json', 'max_range_days': 100, 'response_key': 'activities-minutesFairlyActive', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'min', 'oauth_scope': 'activity', 'value_transform': lambda x: x, 'chart_color': '#FFC107'}, 'calories_in': {'endpoint': '/1/user/-/foods/log/caloriesIn/date/today/1w.json', 'base_endpoint': '/1/user/-/foods/log/caloriesIn/date', 'daily_endpoint': '/1/user/-/foods/log/caloriesIn/date/{date}.json', 'range_endpoint': '/1/user/-/foods/log/caloriesIn/date/{start}/{end}.json', 'max_range_days': 365, 'response_key': 'foods-log-caloriesIn', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'kcal', 'oauth_scope': 'nutrition', 'value_transform': lambda x: x, 'chart_color': '#F44336'}, 'water': {'endpoint': '/1/user/-/foods/log/water/date/today/1w.json', 'base_endpoint': '/1/user/-/foods/log/water/date', 'daily_endpoint': '/1/user/-/foods/log/water/date/{date}.json', 'range_endpoint': '/1/user/-/foods/log/water/date/{start}/{end}.json', 'max_range_days': 365, 'response_key': 'foods-log-water', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': 'ml', 'oauth_scope': 'nutrition', 'value_transform': lambda x: x, 'chart_color': '#03A9F4'}, 'breathing_rate': {'endpoint': '/1/user/-/br/date/today/1w.json', 'base_endpoint': '/1/user/-/br/date', 'daily_endpoint': '/1/user/-/br/date/{date}.json', 'range_endpoint': '/1/user/-/br/date/{start}/{end}.json', 'max_range_days': 30, 'response_key': 'br', 'value_key': 'value.breathingRate', 'timestamp_key': 'dateTime', 'unit': 'resp/min', 'oauth_scope': 'respiratory_rate', 'value_transform': lambda x: x, 'chart_color': '#00BCD4'}, 'oxygen_saturation': {'endpoint': '/1/user/-/spo2/date/today/1w.json', 'base_endpoint': '/1/user/-/spo2/date', 'daily_endpoint': '/1/user/-/spo2/date/{date}.json', 'range_endpoint': '/1/user/-/spo2/date/{start}/{end}.json', 'max_range_days': 30, 'response_key': 'spo2', 'value_key': 'value.avg', 'timestamp_key': 'dateTime', 'unit': '%', 'oauth_scope': 'oxygen_saturation', 'value_transform': lambda x: x, 'chart_color': '#3F51B5'}, 'temperature_core': {'endpoint': '/1/user/-/temp/core/date/today/1w.json', 'base_endpoint': '/1/user/-/temp/core/date', 'daily_endpoint': '/1/user/-/temp/core/date/{date}.json', 'range_endpoint': '/1/user/-/temp/core/date/{start}/{end}.json', 'max_range_days': 30, 'response_key': 'tempCore', 'value_key': 'value', 'timestamp_key': 'dateTime', 'unit': '\u00b0C', 'oauth_scope': 'temperature', 'value_transform': lambda x: x, 'chart_color': '#3F51B5'}, 'temperature_skin': {'endpoint': '/1/user/-/temp/skin/date/today/1w.json', 'base_endpoint': '/1/user/-/temp/skin/date', 'daily_endpoint': '/1/user/-/temp/skin/date/{date}.json', 'range_endpoint': '/1/user/-/temp/skin/date/{start}/{end}.json', 'max_range_days': 30, 'response_key': 'tempSkin', 'value_key': 'value.nightlyRelative', 'timestamp_key': 'dateTime', 'unit': '\u00b0C', 'oauth_scope': 'temperature', 'value_transform': lambda x: x, 'chart_color': '#3F51B5'}}</code>  <code>module-attribute</code>","text":""},{"location":"modules/language.html","title":"Language","text":"<p>Language Management Module. This module provides functionality for managing the application's internationalization (i18n) and localization (l10n) settings. It includes: 1. Routes for changing the application language 2. Session-based language persistence 3. Utilities for language detection and handling The module works with Flask-Babel to provide a seamless multilingual experience, allowing users to switch between available languages (English, Italian, etc.).</p>"},{"location":"modules/language.html#app.language.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/language.html#app.language.language_bp","title":"<code>language_bp = Blueprint('language', __name__, url_prefix='/language')</code>  <code>module-attribute</code>","text":""},{"location":"modules/language.html#app.language.change_language","title":"<code>change_language(lang_code)</code>","text":"<p>Change the language for the application Args:     lang_code: The language code (e.g., 'en', 'it')</p> Source code in <code>app/language.py</code> <pre><code>@language_bp.route('/change/&lt;string:lang_code&gt;', methods=['GET'])\ndef change_language(lang_code):\n    \"\"\"\n    Change the language for the application\n    Args:\n        lang_code: The language code (e.g., 'en', 'it')\n    \"\"\"\n    # Log the current state before changes\n    logger.debug(f\"Changing language to: {lang_code}\")\n    logger.debug(f\"Current session: {session}\")\n    logger.debug(f\"Request path: {request.path}\")\n    logger.debug(f\"Next URL: {request.args.get('next')}\")\n    # Validate language code\n    if lang_code in current_app.config['LANGUAGES']:\n        session['language'] = lang_code\n        logger.debug(f\"Language set in session: {session['language']}\")\n    else:\n        logger.warning(f\"Invalid language code: {lang_code}\")\n    # Get the URL to return to, or default to home\n    next_url = request.args.get('next') or url_for('views.index')\n    logger.debug(f\"Redirecting to: {next_url}\")\n    return redirect(next_url)\n</code></pre>"},{"location":"modules/main.html","title":"Main","text":"<p>Main Application Entry Point. This module serves as the entry point for running the VitaLink application directly. It configures the web server using environment variables and starts the Flask development server. Environment variables:     PORT: The port to run the server on (default: 5000)     HOST: The host to bind to (default: 0.0.0.0, making it accessible externally)     DEBUG: Whether to run in debug mode (default: True) Usage:     python -m app.main</p>"},{"location":"modules/main.html#app.main.port","title":"<code>port = int(os.environ.get('PORT', 5000))</code>  <code>module-attribute</code>","text":""},{"location":"modules/main.html#app.main.host","title":"<code>host = os.environ.get('HOST', '0.0.0.0')</code>  <code>module-attribute</code>","text":""},{"location":"modules/main.html#app.main.debug","title":"<code>debug = os.environ.get('DEBUG', 'True').lower() == 'true'</code>  <code>module-attribute</code>","text":""},{"location":"modules/migrate.html","title":"Migrate","text":"<p>Database Migration Module. This module provides functionality for managing database schema migrations using Flask-Migrate and Alembic. It enables: 1. Creating database migration scripts based on model changes 2. Running migrations to update database schema 3. Versioning of database schema changes 4. Rolling back to previous schema versions when needed The module can be run as a standalone script to initiate migrations or imported to use the migration functionality elsewhere in the application.</p>"},{"location":"modules/migrate.html#app.migrate.PROJECT_ROOT","title":"<code>PROJECT_ROOT = Path(__file__).resolve().parent.parent</code>  <code>module-attribute</code>","text":""},{"location":"modules/migrate.html#app.migrate.migrate","title":"<code>migrate = Migrate(app, db)</code>  <code>module-attribute</code>","text":""},{"location":"modules/migrate.html#app.migrate.run_migration","title":"<code>run_migration()</code>","text":"<p>Run database migration to add new columns and tables.</p> Source code in <code>app/migrate.py</code> <pre><code>def run_migration():\n    \"\"\"Run database migration to add new columns and tables.\"\"\"\n    if not (PROJECT_ROOT / \"migrations\").exists():\n        print(\"Initializing migrations directory ...\")\n        os.system(\"flask db init\")\n    print(\"Creating migration ...\")\n    os.system(\"flask db migrate -m 'Add health platform integration'\")\n    print(\"Applying migration ...\")\n    os.system(\"flask db upgrade\")\n    print(\"Migration completed successfully!\")\n</code></pre>"},{"location":"modules/models.html","title":"Models","text":"<p>Data Models Module. This module defines the database models and their relationships for the VitaLink application. It includes models for doctors, patients, medical notes, vital sign observations, audit logs, and health platform integrations. The models use SQLAlchemy ORM for database interactions and follow a relational database design with appropriate foreign key relationships. Each model includes methods for serialization, password handling (where applicable), and other utility functions related to their specific domain. Key models include: - Doctor: Medical professionals using the system - Patient: Individuals receiving care and being monitored - Note: Medical notes created by doctors about patients - VitalObservation: Medical interpretations of vital sign data - AuditLog: Tracking of all system actions for compliance - HealthPlatformLink: Integration with external health data sources Enums in this module define standardized types for vital signs, health platforms, and audit-related classifications.</p>"},{"location":"modules/models.html#app.models.VitalSignType","title":"<code>VitalSignType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of all supported vital sign and health metric types. This enum defines standardized identifiers for various health metrics and vital signs that can be tracked in the system. Each enum value corresponds to a specific type of health data that can be imported from health platforms, manually recorded, or analyzed. The enum is grouped into categories: 1. Main vital parameters: Core physiological measurements 2. Physical activity: Movement and exercise metrics 3. Metabolism and detailed activity: Energy expenditure and activity breakdown 4. Nutrition and hydration: Food and fluid intake Each enum value stores a string identifier used in APIs and database storage.</p> Source code in <code>app/models.py</code> <pre><code>class VitalSignType(Enum):\n    \"\"\"\n    Enumeration of all supported vital sign and health metric types.\n    This enum defines standardized identifiers for various health metrics and vital signs\n    that can be tracked in the system. Each enum value corresponds to a specific type of\n    health data that can be imported from health platforms, manually recorded, or analyzed.\n    The enum is grouped into categories:\n    1. Main vital parameters: Core physiological measurements\n    2. Physical activity: Movement and exercise metrics\n    3. Metabolism and detailed activity: Energy expenditure and activity breakdown\n    4. Nutrition and hydration: Food and fluid intake\n    Each enum value stores a string identifier used in APIs and database storage.\n    \"\"\"\n    # Main vital parameters\n    HEART_RATE = \"heart_rate\"\n    OXYGEN_SATURATION = \"oxygen_saturation\"\n    BREATHING_RATE = \"breathing_rate\"\n    WEIGHT = \"weight\"\n    TEMPERATURE_CORE = \"temperature_core\"\n    TEMPERATURE_SKIN = \"temperature_skin\"\n    # Physical activity parameters\n    STEPS = \"steps\"\n    CALORIES = \"calories\"\n    DISTANCE = \"distance\"\n    ACTIVE_MINUTES = \"active_minutes\"\n    SLEEP_DURATION = \"sleep_duration\"\n    FLOORS_CLIMBED = \"floors_climbed\"\n    ELEVATION = \"elevation\"\n    # Metabolism and detailed activity\n    ACTIVITY_CALORIES = \"activity_calories\"\n    CALORIES_BMR = \"calories_bmr\"\n    MINUTES_SEDENTARY = \"minutes_sedentary\"\n    MINUTES_LIGHTLY_ACTIVE = \"minutes_lightly_active\"\n    MINUTES_FAIRLY_ACTIVE = \"minutes_fairly_active\"\n    # Nutrition and hydration\n    CALORIES_IN = \"calories_in\"\n    WATER = \"water\"\n</code></pre>"},{"location":"modules/models.html#app.models.VitalSignType.HEART_RATE","title":"<code>HEART_RATE = 'heart_rate'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.OXYGEN_SATURATION","title":"<code>OXYGEN_SATURATION = 'oxygen_saturation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.BREATHING_RATE","title":"<code>BREATHING_RATE = 'breathing_rate'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.WEIGHT","title":"<code>WEIGHT = 'weight'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.TEMPERATURE_CORE","title":"<code>TEMPERATURE_CORE = 'temperature_core'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.TEMPERATURE_SKIN","title":"<code>TEMPERATURE_SKIN = 'temperature_skin'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.STEPS","title":"<code>STEPS = 'steps'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.CALORIES","title":"<code>CALORIES = 'calories'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.DISTANCE","title":"<code>DISTANCE = 'distance'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.ACTIVE_MINUTES","title":"<code>ACTIVE_MINUTES = 'active_minutes'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.SLEEP_DURATION","title":"<code>SLEEP_DURATION = 'sleep_duration'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.FLOORS_CLIMBED","title":"<code>FLOORS_CLIMBED = 'floors_climbed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.ELEVATION","title":"<code>ELEVATION = 'elevation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.ACTIVITY_CALORIES","title":"<code>ACTIVITY_CALORIES = 'activity_calories'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.CALORIES_BMR","title":"<code>CALORIES_BMR = 'calories_bmr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.MINUTES_SEDENTARY","title":"<code>MINUTES_SEDENTARY = 'minutes_sedentary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.MINUTES_LIGHTLY_ACTIVE","title":"<code>MINUTES_LIGHTLY_ACTIVE = 'minutes_lightly_active'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.MINUTES_FAIRLY_ACTIVE","title":"<code>MINUTES_FAIRLY_ACTIVE = 'minutes_fairly_active'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.CALORIES_IN","title":"<code>CALORIES_IN = 'calories_in'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalSignType.WATER","title":"<code>WATER = 'water'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.DoctorPatient","title":"<code>DoctorPatient</code>","text":"<p>               Bases: <code>Model</code></p> <p>Association model between doctors and patients. This model implements the many-to-many relationship between doctors and patients, allowing each doctor to be associated with multiple patients and each patient to be associated with multiple doctors. This supports collaborative care scenarios where multiple healthcare providers may treat the same patient. The model includes a timestamp of when the association was created, allowing the system to track when a doctor began caring for a specific patient. Attributes:     doctor_id (int): Foreign key to the doctor table, part of composite primary key     patient_id (int): Foreign key to the patient table, part of composite primary key     assigned_date (datetime): When this association was created</p> Source code in <code>app/models.py</code> <pre><code>class DoctorPatient(db.Model):\n    \"\"\"\n    Association model between doctors and patients.\n    This model implements the many-to-many relationship between doctors and patients,\n    allowing each doctor to be associated with multiple patients and each patient\n    to be associated with multiple doctors. This supports collaborative care scenarios\n    where multiple healthcare providers may treat the same patient.\n    The model includes a timestamp of when the association was created, allowing\n    the system to track when a doctor began caring for a specific patient.\n    Attributes:\n        doctor_id (int): Foreign key to the doctor table, part of composite primary key\n        patient_id (int): Foreign key to the patient table, part of composite primary key\n        assigned_date (datetime): When this association was created\n    \"\"\"\n    __tablename__ = 'doctor_patient'\n    doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), primary_key=True)\n    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), primary_key=True)\n    assigned_date = db.Column(db.DateTime, default=datetime.utcnow)\n</code></pre>"},{"location":"modules/models.html#app.models.DoctorPatient.__tablename__","title":"<code>__tablename__ = 'doctor_patient'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.DoctorPatient.doctor_id","title":"<code>doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.DoctorPatient.patient_id","title":"<code>patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.DoctorPatient.assigned_date","title":"<code>assigned_date = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor","title":"<code>Doctor</code>","text":"<p>               Bases: <code>UserMixin</code>, <code>Model</code></p> <p>Model representing a medical professional in the system. This model stores information about doctors who use the VitaLink system. It extends Flask-Login's UserMixin to provide user authentication functionality. Doctors can be associated with multiple patients, create medical notes, and record vital sign observations. Attributes:     id (int): Primary key and unique identifier     email (str): Email address used for login, must be unique     password_hash (str): Securely hashed password, never stored in plaintext     first_name (str): Doctor's first name     last_name (str): Doctor's last name     specialty (str): Medical specialty or area of practice     created_at (datetime): When the doctor account was created     updated_at (datetime): When the doctor account was last updated     patients (relationship): Many-to-many relationship with Patient model     notes (relationship): One-to-many relationship with Note model     vital_observations (relationship): One-to-many relationship with VitalObservation model</p> Source code in <code>app/models.py</code> <pre><code>class Doctor(UserMixin, db.Model):\n    \"\"\"\n    Model representing a medical professional in the system.\n    This model stores information about doctors who use the VitaLink system.\n    It extends Flask-Login's UserMixin to provide user authentication functionality.\n    Doctors can be associated with multiple patients, create medical notes,\n    and record vital sign observations.\n    Attributes:\n        id (int): Primary key and unique identifier\n        email (str): Email address used for login, must be unique\n        password_hash (str): Securely hashed password, never stored in plaintext\n        first_name (str): Doctor's first name\n        last_name (str): Doctor's last name\n        specialty (str): Medical specialty or area of practice\n        created_at (datetime): When the doctor account was created\n        updated_at (datetime): When the doctor account was last updated\n        patients (relationship): Many-to-many relationship with Patient model\n        notes (relationship): One-to-many relationship with Note model\n        vital_observations (relationship): One-to-many relationship with VitalObservation model\n    \"\"\"\n    __tablename__ = 'doctor'\n    id = db.Column(db.Integer, primary_key=True)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    first_name = db.Column(db.String(100), nullable=False)\n    last_name = db.Column(db.String(100), nullable=False)\n    specialty = db.Column(db.String(100))\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    # Relationship with patients (many-to-many)\n    patients = db.relationship('Patient', \n                              secondary='doctor_patient',\n                              backref=db.backref('doctors', lazy='dynamic'),\n                              lazy='dynamic')\n    # Notes and observations created by this doctor\n    notes = db.relationship('Note', backref='doctor', lazy='dynamic')\n    vital_observations = db.relationship('VitalObservation', backref='doctor', lazy='dynamic')\n    def set_password(self, password):\n        \"\"\"\n        Set the doctor's password hash.\n        This method securely hashes the provided password using Werkzeug's\n        generate_password_hash function and stores the hash in the database.\n        The original password is never stored in plaintext.\n        Args:\n            password (str): The plain text password to hash\n        Returns:\n            None\n        \"\"\"\n        self.password_hash = generate_password_hash(password)\n    def check_password(self, password):\n        \"\"\"\n        Check if the provided password matches the stored hash.\n        This method verifies the provided password against the stored hash\n        using Werkzeug's check_password_hash function, which is resistant\n        to timing attacks.\n        Args:\n            password (str): The plain text password to verify\n        Returns:\n            bool: True if the password is correct, False otherwise\n        \"\"\"\n        return check_password_hash(self.password_hash, password)\n    def to_dict(self):\n        \"\"\"\n        Convert the doctor object to a serializable dictionary.\n        This method creates a dictionary representation of the Doctor object\n        suitable for JSON serialization in API responses. It formats datetime\n        objects as ISO 8601 strings and includes all relevant doctor attributes\n        except for the password hash.\n        Returns:\n            dict: Dictionary containing the doctor's attributes\n                  with datetimes converted to ISO format strings\n        \"\"\"\n        return {\n            'id': self.id,\n            'email': self.email,\n            'first_name': self.first_name,\n            'last_name': self.last_name,\n            'specialty': self.specialty,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n    def get_patients(self):\n        \"\"\"\n        Get all patients associated with this doctor.\n        This method retrieves all Patient objects that have been linked to this doctor\n        through the DoctorPatient association table. This represents the doctor's\n        current patient roster.\n        Returns:\n            list: List of Patient objects associated with the doctor\n        \"\"\"\n        return self.patients.all()\n    def add_patient(self, patient):\n        \"\"\"\n        Add a patient to this doctor's patient list.\n        This method establishes a doctor-patient relationship by creating a new\n        entry in the DoctorPatient association table. If the relationship already\n        exists, no action is taken. The method handles the database session\n        and commits the change.\n        Args:\n            patient (Patient): Patient object to add to this doctor's care\n        Returns:\n            None\n        \"\"\"\n        if patient not in self.patients.all():\n            association = DoctorPatient(doctor_id=self.id, patient_id=patient.id)\n            db.session.add(association)\n            db.session.commit()\n    def remove_patient(self, patient):\n        \"\"\"\n        Remove a patient from this doctor's patient list.\n        This method ends a doctor-patient relationship by removing the corresponding\n        entry from the DoctorPatient association table. If no such relationship\n        exists, no action is taken. The method handles the database session\n        and commits the change.\n        Args:\n            patient (Patient): Patient object to remove from this doctor's care\n        Returns:\n            None\n        \"\"\"\n        association = DoctorPatient.query.filter_by(doctor_id=self.id, patient_id=patient.id).first()\n        if association:\n            db.session.delete(association)\n            db.session.commit()\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.__tablename__","title":"<code>__tablename__ = 'doctor'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.email","title":"<code>email = db.Column(db.String(120), unique=True, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.password_hash","title":"<code>password_hash = db.Column(db.String(256), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.first_name","title":"<code>first_name = db.Column(db.String(100), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.last_name","title":"<code>last_name = db.Column(db.String(100), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.specialty","title":"<code>specialty = db.Column(db.String(100))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.created_at","title":"<code>created_at = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.updated_at","title":"<code>updated_at = db.Column(db.DateTime, default=(datetime.utcnow), onupdate=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.patients","title":"<code>patients = db.relationship('Patient', secondary='doctor_patient', backref=(db.backref('doctors', lazy='dynamic')), lazy='dynamic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.notes","title":"<code>notes = db.relationship('Note', backref='doctor', lazy='dynamic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.vital_observations","title":"<code>vital_observations = db.relationship('VitalObservation', backref='doctor', lazy='dynamic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Doctor.set_password","title":"<code>set_password(password)</code>","text":"<p>Set the doctor's password hash. This method securely hashes the provided password using Werkzeug's generate_password_hash function and stores the hash in the database. The original password is never stored in plaintext. Args:     password (str): The plain text password to hash Returns:     None</p> Source code in <code>app/models.py</code> <pre><code>def set_password(self, password):\n    \"\"\"\n    Set the doctor's password hash.\n    This method securely hashes the provided password using Werkzeug's\n    generate_password_hash function and stores the hash in the database.\n    The original password is never stored in plaintext.\n    Args:\n        password (str): The plain text password to hash\n    Returns:\n        None\n    \"\"\"\n    self.password_hash = generate_password_hash(password)\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.check_password","title":"<code>check_password(password)</code>","text":"<p>Check if the provided password matches the stored hash. This method verifies the provided password against the stored hash using Werkzeug's check_password_hash function, which is resistant to timing attacks. Args:     password (str): The plain text password to verify Returns:     bool: True if the password is correct, False otherwise</p> Source code in <code>app/models.py</code> <pre><code>def check_password(self, password):\n    \"\"\"\n    Check if the provided password matches the stored hash.\n    This method verifies the provided password against the stored hash\n    using Werkzeug's check_password_hash function, which is resistant\n    to timing attacks.\n    Args:\n        password (str): The plain text password to verify\n    Returns:\n        bool: True if the password is correct, False otherwise\n    \"\"\"\n    return check_password_hash(self.password_hash, password)\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the doctor object to a serializable dictionary. This method creates a dictionary representation of the Doctor object suitable for JSON serialization in API responses. It formats datetime objects as ISO 8601 strings and includes all relevant doctor attributes except for the password hash. Returns:     dict: Dictionary containing the doctor's attributes           with datetimes converted to ISO format strings</p> Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the doctor object to a serializable dictionary.\n    This method creates a dictionary representation of the Doctor object\n    suitable for JSON serialization in API responses. It formats datetime\n    objects as ISO 8601 strings and includes all relevant doctor attributes\n    except for the password hash.\n    Returns:\n        dict: Dictionary containing the doctor's attributes\n              with datetimes converted to ISO format strings\n    \"\"\"\n    return {\n        'id': self.id,\n        'email': self.email,\n        'first_name': self.first_name,\n        'last_name': self.last_name,\n        'specialty': self.specialty,\n        'created_at': self.created_at.isoformat() if self.created_at else None,\n        'updated_at': self.updated_at.isoformat() if self.updated_at else None\n    }\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.get_patients","title":"<code>get_patients()</code>","text":"<p>Get all patients associated with this doctor. This method retrieves all Patient objects that have been linked to this doctor through the DoctorPatient association table. This represents the doctor's current patient roster. Returns:     list: List of Patient objects associated with the doctor</p> Source code in <code>app/models.py</code> <pre><code>def get_patients(self):\n    \"\"\"\n    Get all patients associated with this doctor.\n    This method retrieves all Patient objects that have been linked to this doctor\n    through the DoctorPatient association table. This represents the doctor's\n    current patient roster.\n    Returns:\n        list: List of Patient objects associated with the doctor\n    \"\"\"\n    return self.patients.all()\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.add_patient","title":"<code>add_patient(patient)</code>","text":"<p>Add a patient to this doctor's patient list. This method establishes a doctor-patient relationship by creating a new entry in the DoctorPatient association table. If the relationship already exists, no action is taken. The method handles the database session and commits the change. Args:     patient (Patient): Patient object to add to this doctor's care Returns:     None</p> Source code in <code>app/models.py</code> <pre><code>def add_patient(self, patient):\n    \"\"\"\n    Add a patient to this doctor's patient list.\n    This method establishes a doctor-patient relationship by creating a new\n    entry in the DoctorPatient association table. If the relationship already\n    exists, no action is taken. The method handles the database session\n    and commits the change.\n    Args:\n        patient (Patient): Patient object to add to this doctor's care\n    Returns:\n        None\n    \"\"\"\n    if patient not in self.patients.all():\n        association = DoctorPatient(doctor_id=self.id, patient_id=patient.id)\n        db.session.add(association)\n        db.session.commit()\n</code></pre>"},{"location":"modules/models.html#app.models.Doctor.remove_patient","title":"<code>remove_patient(patient)</code>","text":"<p>Remove a patient from this doctor's patient list. This method ends a doctor-patient relationship by removing the corresponding entry from the DoctorPatient association table. If no such relationship exists, no action is taken. The method handles the database session and commits the change. Args:     patient (Patient): Patient object to remove from this doctor's care Returns:     None</p> Source code in <code>app/models.py</code> <pre><code>def remove_patient(self, patient):\n    \"\"\"\n    Remove a patient from this doctor's patient list.\n    This method ends a doctor-patient relationship by removing the corresponding\n    entry from the DoctorPatient association table. If no such relationship\n    exists, no action is taken. The method handles the database session\n    and commits the change.\n    Args:\n        patient (Patient): Patient object to remove from this doctor's care\n    Returns:\n        None\n    \"\"\"\n    association = DoctorPatient.query.filter_by(doctor_id=self.id, patient_id=patient.id).first()\n    if association:\n        db.session.delete(association)\n        db.session.commit()\n</code></pre>"},{"location":"modules/models.html#app.models.HealthPlatform","title":"<code>HealthPlatform</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of health platforms that can be integrated with the system. This enum defines the health platforms and wearable device ecosystems that are supported for data integration. Each platform requires specific OAuth2 authentication flows and API endpoints for retrieving health data. Attributes:     FITBIT: Integration with Fitbit devices and platform     GOOGLE_HEALTH_CONNECT: Integration with Google Health Connect     APPLE_HEALTH: Integration with Apple Health</p> Source code in <code>app/models.py</code> <pre><code>class HealthPlatform(Enum):\n    \"\"\"\n    Enumeration of health platforms that can be integrated with the system.\n    This enum defines the health platforms and wearable device ecosystems\n    that are supported for data integration. Each platform requires specific\n    OAuth2 authentication flows and API endpoints for retrieving health data.\n    Attributes:\n        FITBIT: Integration with Fitbit devices and platform\n        GOOGLE_HEALTH_CONNECT: Integration with Google Health Connect\n        APPLE_HEALTH: Integration with Apple Health\n    \"\"\"\n    FITBIT = \"fitbit\"\n    GOOGLE_HEALTH_CONNECT = \"google_health_connect\"\n    APPLE_HEALTH = \"apple_health\"\n</code></pre>"},{"location":"modules/models.html#app.models.HealthPlatform.FITBIT","title":"<code>FITBIT = 'fitbit'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatform.GOOGLE_HEALTH_CONNECT","title":"<code>GOOGLE_HEALTH_CONNECT = 'google_health_connect'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatform.APPLE_HEALTH","title":"<code>APPLE_HEALTH = 'apple_health'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient","title":"<code>Patient</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model representing a patient in the system. This model stores comprehensive information about patients, including their personal details, contact information, and health platform integration. The model uses a UUID for secure identification in URLs and APIs, while maintaining a standard integer primary key for database relationships. Patients can be associated with multiple doctors for collaborative care, have medical notes, vital sign observations, and connect to external health platforms (like Fitbit) to provide real-time health data. Attributes:     id (int): Primary key and unique identifier     uuid (str): Unique UUID used in URLs and APIs     first_name (str): Patient's first name     last_name (str): Patient's last name     date_of_birth (date): Patient's date of birth     gender (str): Patient's gender     contact_number (str): Patient's contact phone number     email (str): Email address used for sending notifications, must be unique     address (str): Patient's physical address     created_at (datetime): When the patient record was created     updated_at (datetime): When the patient record was last updated     connected_platform (HealthPlatform): Health platform connected to this patient     platform_access_token (str): OAuth access token for the connected platform     platform_refresh_token (str): OAuth refresh token for the connected platform     platform_token_expires_at (datetime): Expiration date of the access token     notes (relationship): One-to-many relationship with Note model     vital_observations (relationship): One-to-many relationship with VitalObservation model</p> Source code in <code>app/models.py</code> <pre><code>class Patient(db.Model):\n    \"\"\"\n    Model representing a patient in the system.\n    This model stores comprehensive information about patients, including\n    their personal details, contact information, and health platform integration.\n    The model uses a UUID for secure identification in URLs and APIs, while\n    maintaining a standard integer primary key for database relationships.\n    Patients can be associated with multiple doctors for collaborative care,\n    have medical notes, vital sign observations, and connect to external\n    health platforms (like Fitbit) to provide real-time health data.\n    Attributes:\n        id (int): Primary key and unique identifier\n        uuid (str): Unique UUID used in URLs and APIs\n        first_name (str): Patient's first name\n        last_name (str): Patient's last name\n        date_of_birth (date): Patient's date of birth\n        gender (str): Patient's gender\n        contact_number (str): Patient's contact phone number\n        email (str): Email address used for sending notifications, must be unique\n        address (str): Patient's physical address\n        created_at (datetime): When the patient record was created\n        updated_at (datetime): When the patient record was last updated\n        connected_platform (HealthPlatform): Health platform connected to this patient\n        platform_access_token (str): OAuth access token for the connected platform\n        platform_refresh_token (str): OAuth refresh token for the connected platform\n        platform_token_expires_at (datetime): Expiration date of the access token\n        notes (relationship): One-to-many relationship with Note model\n        vital_observations (relationship): One-to-many relationship with VitalObservation model\n    \"\"\"\n    __tablename__ = 'patient'\n    id = db.Column(db.Integer, primary_key=True)\n    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))\n    first_name = db.Column(db.String(100), nullable=False)\n    last_name = db.Column(db.String(100), nullable=False)\n    date_of_birth = db.Column(db.Date, nullable=False)\n    gender = db.Column(db.String(20))\n    contact_number = db.Column(db.String(20), nullable=False)\n    email = db.Column(db.String(120))\n    address = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    # Health platform integration\n    connected_platform = db.Column(db.Enum(HealthPlatform), nullable=True)\n    platform_access_token = db.Column(db.String(1024), nullable=True)\n    platform_refresh_token = db.Column(db.String(1024), nullable=True)\n    platform_token_expires_at = db.Column(db.DateTime, nullable=True)\n    # Relationships\n    notes = db.relationship('Note', backref='patient', lazy='dynamic')\n    vital_observations = db.relationship('VitalObservation', backref='patient', lazy='dynamic')\n    def to_dict(self):\n        \"\"\"\n        Convert the patient object to a serializable dictionary.\n        This method creates a dictionary representation of the Patient object\n        suitable for JSON serialization in API responses. It formats date and\n        datetime objects as ISO 8601 strings.\n        Returns:\n            dict: Dictionary containing all the patient's attributes\n                  with dates and datetimes converted to ISO format strings\n        \"\"\"\n        return {\n            'id': self.id,\n            'uuid': self.uuid,\n            'first_name': self.first_name,\n            'last_name': self.last_name,\n            'date_of_birth': self.date_of_birth.isoformat() if self.date_of_birth else None,\n            'gender': self.gender,\n            'contact_number': self.contact_number,\n            'email': self.email,\n            'address': self.address,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n    def get_vital_observations(self, vital_type=None, start_date=None, end_date=None):\n        \"\"\"\n        Get vital observations for this patient with optional filtering.\n        This method retrieves vital sign observations associated with the patient,\n        with optional filtering by vital sign type and date range. Results are\n        ordered by creation date, with the most recent observations first.\n        Args:\n            vital_type (VitalSignType, optional): Type of vital sign to filter by\n            start_date (datetime, optional): Start date for filtering\n            end_date (datetime, optional): End date for filtering\n        Returns:\n            list: List of VitalObservation objects that meet the filtering criteria\n        \"\"\"\n        query = self.vital_observations\n        if vital_type:\n            query = query.filter_by(vital_type=vital_type)\n        if start_date:\n            query = query.filter(VitalObservation.start_date &gt;= start_date)\n        if end_date:\n            query = query.filter(VitalObservation.end_date &lt;= end_date)\n        return query.order_by(VitalObservation.created_at.desc()).all()\n    def get_notes(self):\n        \"\"\"\n        Get all medical notes associated with this patient.\n        This method retrieves all notes created for this patient,\n        ordered by creation date with the most recent notes first.\n        Returns:\n            list: List of Note objects ordered by creation date (most recent first)\n        \"\"\"\n        return self.notes.order_by(Note.created_at.desc()).all()\n</code></pre>"},{"location":"modules/models.html#app.models.Patient.__tablename__","title":"<code>__tablename__ = 'patient'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.uuid","title":"<code>uuid = db.Column(db.String(36), unique=True, nullable=False, default=(lambda: str(uuid.uuid4())))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.first_name","title":"<code>first_name = db.Column(db.String(100), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.last_name","title":"<code>last_name = db.Column(db.String(100), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.date_of_birth","title":"<code>date_of_birth = db.Column(db.Date, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.gender","title":"<code>gender = db.Column(db.String(20))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.contact_number","title":"<code>contact_number = db.Column(db.String(20), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.email","title":"<code>email = db.Column(db.String(120))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.address","title":"<code>address = db.Column(db.Text)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.created_at","title":"<code>created_at = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.updated_at","title":"<code>updated_at = db.Column(db.DateTime, default=(datetime.utcnow), onupdate=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.connected_platform","title":"<code>connected_platform = db.Column(db.Enum(HealthPlatform), nullable=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.platform_access_token","title":"<code>platform_access_token = db.Column(db.String(1024), nullable=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.platform_refresh_token","title":"<code>platform_refresh_token = db.Column(db.String(1024), nullable=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.platform_token_expires_at","title":"<code>platform_token_expires_at = db.Column(db.DateTime, nullable=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.notes","title":"<code>notes = db.relationship('Note', backref='patient', lazy='dynamic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.vital_observations","title":"<code>vital_observations = db.relationship('VitalObservation', backref='patient', lazy='dynamic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Patient.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the patient object to a serializable dictionary. This method creates a dictionary representation of the Patient object suitable for JSON serialization in API responses. It formats date and datetime objects as ISO 8601 strings. Returns:     dict: Dictionary containing all the patient's attributes           with dates and datetimes converted to ISO format strings</p> Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the patient object to a serializable dictionary.\n    This method creates a dictionary representation of the Patient object\n    suitable for JSON serialization in API responses. It formats date and\n    datetime objects as ISO 8601 strings.\n    Returns:\n        dict: Dictionary containing all the patient's attributes\n              with dates and datetimes converted to ISO format strings\n    \"\"\"\n    return {\n        'id': self.id,\n        'uuid': self.uuid,\n        'first_name': self.first_name,\n        'last_name': self.last_name,\n        'date_of_birth': self.date_of_birth.isoformat() if self.date_of_birth else None,\n        'gender': self.gender,\n        'contact_number': self.contact_number,\n        'email': self.email,\n        'address': self.address,\n        'created_at': self.created_at.isoformat() if self.created_at else None,\n        'updated_at': self.updated_at.isoformat() if self.updated_at else None\n    }\n</code></pre>"},{"location":"modules/models.html#app.models.Patient.get_vital_observations","title":"<code>get_vital_observations(vital_type=None, start_date=None, end_date=None)</code>","text":"<p>Get vital observations for this patient with optional filtering. This method retrieves vital sign observations associated with the patient, with optional filtering by vital sign type and date range. Results are ordered by creation date, with the most recent observations first. Args:     vital_type (VitalSignType, optional): Type of vital sign to filter by     start_date (datetime, optional): Start date for filtering     end_date (datetime, optional): End date for filtering Returns:     list: List of VitalObservation objects that meet the filtering criteria</p> Source code in <code>app/models.py</code> <pre><code>def get_vital_observations(self, vital_type=None, start_date=None, end_date=None):\n    \"\"\"\n    Get vital observations for this patient with optional filtering.\n    This method retrieves vital sign observations associated with the patient,\n    with optional filtering by vital sign type and date range. Results are\n    ordered by creation date, with the most recent observations first.\n    Args:\n        vital_type (VitalSignType, optional): Type of vital sign to filter by\n        start_date (datetime, optional): Start date for filtering\n        end_date (datetime, optional): End date for filtering\n    Returns:\n        list: List of VitalObservation objects that meet the filtering criteria\n    \"\"\"\n    query = self.vital_observations\n    if vital_type:\n        query = query.filter_by(vital_type=vital_type)\n    if start_date:\n        query = query.filter(VitalObservation.start_date &gt;= start_date)\n    if end_date:\n        query = query.filter(VitalObservation.end_date &lt;= end_date)\n    return query.order_by(VitalObservation.created_at.desc()).all()\n</code></pre>"},{"location":"modules/models.html#app.models.Patient.get_notes","title":"<code>get_notes()</code>","text":"<p>Get all medical notes associated with this patient. This method retrieves all notes created for this patient, ordered by creation date with the most recent notes first. Returns:     list: List of Note objects ordered by creation date (most recent first)</p> Source code in <code>app/models.py</code> <pre><code>def get_notes(self):\n    \"\"\"\n    Get all medical notes associated with this patient.\n    This method retrieves all notes created for this patient,\n    ordered by creation date with the most recent notes first.\n    Returns:\n        list: List of Note objects ordered by creation date (most recent first)\n    \"\"\"\n    return self.notes.order_by(Note.created_at.desc()).all()\n</code></pre>"},{"location":"modules/models.html#app.models.Note","title":"<code>Note</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model representing a medical note for a patient. This model stores textual notes created by doctors about patients. Notes can include observations, treatment plans, reminders, or any other relevant medical information. Each note is associated with both a patient and the doctor who created it. Attributes:     id (int): Primary key and unique identifier     patient_id (int): Foreign key to the patient this note is about     doctor_id (int): Foreign key to the doctor who created this note     content (str): The text content of the medical note     created_at (datetime): When the note was created     updated_at (datetime): When the note was last updated</p> Source code in <code>app/models.py</code> <pre><code>class Note(db.Model):\n    \"\"\"\n    Model representing a medical note for a patient.\n    This model stores textual notes created by doctors about patients.\n    Notes can include observations, treatment plans, reminders,\n    or any other relevant medical information. Each note is associated\n    with both a patient and the doctor who created it.\n    Attributes:\n        id (int): Primary key and unique identifier\n        patient_id (int): Foreign key to the patient this note is about\n        doctor_id (int): Foreign key to the doctor who created this note\n        content (str): The text content of the medical note\n        created_at (datetime): When the note was created\n        updated_at (datetime): When the note was last updated\n    \"\"\"\n    __tablename__ = 'note'\n    id = db.Column(db.Integer, primary_key=True)\n    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)\n    doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    def to_dict(self):\n        \"\"\"\n        Convert the note object to a serializable dictionary.\n        This method creates a dictionary representation of the Note object\n        suitable for JSON serialization in API responses. It formats datetime\n        objects as ISO 8601 strings.\n        Returns:\n            dict: Dictionary containing all the note's attributes\n                  with datetimes converted to ISO format strings\n        \"\"\"\n        return {\n            'id': self.id,\n            'patient_id': self.patient_id,\n            'doctor_id': self.doctor_id,\n            'content': self.content,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n</code></pre>"},{"location":"modules/models.html#app.models.Note.__tablename__","title":"<code>__tablename__ = 'note'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.patient_id","title":"<code>patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.doctor_id","title":"<code>doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.content","title":"<code>content = db.Column(db.Text, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.created_at","title":"<code>created_at = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.updated_at","title":"<code>updated_at = db.Column(db.DateTime, default=(datetime.utcnow), onupdate=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.Note.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the note object to a serializable dictionary. This method creates a dictionary representation of the Note object suitable for JSON serialization in API responses. It formats datetime objects as ISO 8601 strings. Returns:     dict: Dictionary containing all the note's attributes           with datetimes converted to ISO format strings</p> Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the note object to a serializable dictionary.\n    This method creates a dictionary representation of the Note object\n    suitable for JSON serialization in API responses. It formats datetime\n    objects as ISO 8601 strings.\n    Returns:\n        dict: Dictionary containing all the note's attributes\n              with datetimes converted to ISO format strings\n    \"\"\"\n    return {\n        'id': self.id,\n        'patient_id': self.patient_id,\n        'doctor_id': self.doctor_id,\n        'content': self.content,\n        'created_at': self.created_at.isoformat() if self.created_at else None,\n        'updated_at': self.updated_at.isoformat() if self.updated_at else None\n    }\n</code></pre>"},{"location":"modules/models.html#app.models.VitalObservation","title":"<code>VitalObservation</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model representing medical observations about vital sign data. This model stores doctors' interpretations and analyses of vital sign data over specific time periods. Unlike raw vital sign data points, observations represent medical insights, trends, or concerns identified by healthcare  professionals after reviewing the data. Observations have a time range (start to end date) that they cover, and include a text commentary from the doctor about what they observed in the vital sign data during that period. Attributes:     id (int): Primary key and unique identifier     patient_id (int): Foreign key to the patient this observation is about     doctor_id (int): Foreign key to the doctor who created this observation     vital_type (VitalSignType): Type of vital sign being observed     content (str): Doctor's notes and interpretation of the vital sign data     start_date (datetime): Beginning of the observation period     end_date (datetime): End of the observation period     created_at (datetime): When the observation was created     updated_at (datetime): When the observation was last updated</p> Source code in <code>app/models.py</code> <pre><code>class VitalObservation(db.Model):\n    \"\"\"\n    Model representing medical observations about vital sign data.\n    This model stores doctors' interpretations and analyses of vital sign data\n    over specific time periods. Unlike raw vital sign data points, observations\n    represent medical insights, trends, or concerns identified by healthcare \n    professionals after reviewing the data.\n    Observations have a time range (start to end date) that they cover,\n    and include a text commentary from the doctor about what they observed\n    in the vital sign data during that period.\n    Attributes:\n        id (int): Primary key and unique identifier\n        patient_id (int): Foreign key to the patient this observation is about\n        doctor_id (int): Foreign key to the doctor who created this observation\n        vital_type (VitalSignType): Type of vital sign being observed\n        content (str): Doctor's notes and interpretation of the vital sign data\n        start_date (datetime): Beginning of the observation period\n        end_date (datetime): End of the observation period\n        created_at (datetime): When the observation was created\n        updated_at (datetime): When the observation was last updated\n    \"\"\"\n    __tablename__ = 'vital_observation'\n    id = db.Column(db.Integer, primary_key=True)\n    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)\n    doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)\n    vital_type = db.Column(db.Enum(VitalSignType), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    start_date = db.Column(db.DateTime, nullable=False)\n    end_date = db.Column(db.DateTime, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    def to_dict(self):\n        # Convert the object to a serializable dictionary\n        #\n        # Returns:\n        #   dict: Dictionary representation of the object\n        # Load the Doctor model to get the doctor's name\n        from .app import db\n        doctor = db.session.query(Doctor).get(self.doctor_id)\n        return {\n            'id': self.id,\n            'patient_id': self.patient_id,\n            'doctor_id': self.doctor_id,\n            'doctor_name': f\"{doctor.first_name} {doctor.last_name}\" if doctor else \"Unknown Doctor\",\n            'vital_type': self.vital_type.value,\n            'content': self.content,\n            'start_date': self.start_date.isoformat() if self.start_date else None,\n            'end_date': self.end_date.isoformat() if self.end_date else None,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n</code></pre>"},{"location":"modules/models.html#app.models.VitalObservation.__tablename__","title":"<code>__tablename__ = 'vital_observation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.patient_id","title":"<code>patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.doctor_id","title":"<code>doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.vital_type","title":"<code>vital_type = db.Column(db.Enum(VitalSignType), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.content","title":"<code>content = db.Column(db.Text, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.start_date","title":"<code>start_date = db.Column(db.DateTime, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.end_date","title":"<code>end_date = db.Column(db.DateTime, nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.created_at","title":"<code>created_at = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.updated_at","title":"<code>updated_at = db.Column(db.DateTime, default=(datetime.utcnow), onupdate=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.VitalObservation.to_dict","title":"<code>to_dict()</code>","text":"Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    # Convert the object to a serializable dictionary\n    #\n    # Returns:\n    #   dict: Dictionary representation of the object\n    # Load the Doctor model to get the doctor's name\n    from .app import db\n    doctor = db.session.query(Doctor).get(self.doctor_id)\n    return {\n        'id': self.id,\n        'patient_id': self.patient_id,\n        'doctor_id': self.doctor_id,\n        'doctor_name': f\"{doctor.first_name} {doctor.last_name}\" if doctor else \"Unknown Doctor\",\n        'vital_type': self.vital_type.value,\n        'content': self.content,\n        'start_date': self.start_date.isoformat() if self.start_date else None,\n        'end_date': self.end_date.isoformat() if self.end_date else None,\n        'created_at': self.created_at.isoformat() if self.created_at else None,\n        'updated_at': self.updated_at.isoformat() if self.updated_at else None\n    }\n</code></pre>"},{"location":"modules/models.html#app.models.ActionType","title":"<code>ActionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration defining the types of actions for the audit log system. This enum defines all possible action types that can be recorded in the audit log, providing standardized identifiers for different types of operations performed  in the system. These values help categorize and filter audit logs for  reporting and compliance purposes. Attributes:     CREATE: Action of creating a new entity     UPDATE: Action of updating an existing entity     DELETE: Action of deleting an entity     VIEW: Action of viewing an entity     EXPORT: Action of exporting an entity (e.g., report generation)     GENERATE_LINK: Action of generating a link for health platform integration     CONNECT: Action of connecting a health platform     DISCONNECT: Action of disconnecting a health platform     SYNC: Action of synchronizing data from a health platform     IMPORT: Action of importing an existing entity</p> Source code in <code>app/models.py</code> <pre><code>class ActionType(Enum):\n    \"\"\"\n    Enumeration defining the types of actions for the audit log system.\n    This enum defines all possible action types that can be recorded in the audit log,\n    providing standardized identifiers for different types of operations performed \n    in the system. These values help categorize and filter audit logs for \n    reporting and compliance purposes.\n    Attributes:\n        CREATE: Action of creating a new entity\n        UPDATE: Action of updating an existing entity\n        DELETE: Action of deleting an entity\n        VIEW: Action of viewing an entity\n        EXPORT: Action of exporting an entity (e.g., report generation)\n        GENERATE_LINK: Action of generating a link for health platform integration\n        CONNECT: Action of connecting a health platform\n        DISCONNECT: Action of disconnecting a health platform\n        SYNC: Action of synchronizing data from a health platform\n        IMPORT: Action of importing an existing entity\n    \"\"\"\n    CREATE = \"CREATE\"\n    UPDATE = \"UPDATE\"\n    DELETE = \"DELETE\"\n    VIEW = \"VIEW\"\n    EXPORT = \"EXPORT\"\n    GENERATE_LINK = \"GENERATE_LINK\"\n    CONNECT = \"CONNECT\"\n    DISCONNECT = \"DISCONNECT\"\n    SYNC = \"SYNC\"\n    IMPORT = \"IMPORT\"\n</code></pre>"},{"location":"modules/models.html#app.models.ActionType.CREATE","title":"<code>CREATE = 'CREATE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.UPDATE","title":"<code>UPDATE = 'UPDATE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.DELETE","title":"<code>DELETE = 'DELETE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.VIEW","title":"<code>VIEW = 'VIEW'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.EXPORT","title":"<code>EXPORT = 'EXPORT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.GENERATE_LINK","title":"<code>GENERATE_LINK = 'GENERATE_LINK'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.CONNECT","title":"<code>CONNECT = 'CONNECT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.DISCONNECT","title":"<code>DISCONNECT = 'DISCONNECT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.SYNC","title":"<code>SYNC = 'SYNC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.ActionType.IMPORT","title":"<code>IMPORT = 'IMPORT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType","title":"<code>EntityType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration defining the types of entities that can be tracked in the audit log system. This enum defines all the different entities for which actions can be recorded in the audit log. By categorizing entities, the system can provide more targeted filtering and reporting capabilities for audit investigations. Attributes:     PATIENT: Patient entity     VITAL_SIGN: Vital sign entity     NOTE: Medical note entity     REPORT: Report/document entity     HEALTH_PLATFORM: Health platform entity     HEALTH_LINK: Health platform link entity     OBSERVATION: Vital observation entity</p> Source code in <code>app/models.py</code> <pre><code>class EntityType(Enum):\n    \"\"\"\n    Enumeration defining the types of entities that can be tracked in the audit log system.\n    This enum defines all the different entities for which actions can be recorded\n    in the audit log. By categorizing entities, the system can provide more\n    targeted filtering and reporting capabilities for audit investigations.\n    Attributes:\n        PATIENT: Patient entity\n        VITAL_SIGN: Vital sign entity\n        NOTE: Medical note entity\n        REPORT: Report/document entity\n        HEALTH_PLATFORM: Health platform entity\n        HEALTH_LINK: Health platform link entity\n        OBSERVATION: Vital observation entity\n    \"\"\"\n    PATIENT = \"patient\"\n    VITAL_SIGN = \"vital_sign\"\n    NOTE = \"note\"\n    REPORT = \"report\"\n    HEALTH_PLATFORM = \"health_platform\"\n    HEALTH_LINK = \"health_link\"\n    OBSERVATION = \"observation\"\n</code></pre>"},{"location":"modules/models.html#app.models.EntityType.PATIENT","title":"<code>PATIENT = 'patient'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.VITAL_SIGN","title":"<code>VITAL_SIGN = 'vital_sign'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.NOTE","title":"<code>NOTE = 'note'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.REPORT","title":"<code>REPORT = 'report'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.HEALTH_PLATFORM","title":"<code>HEALTH_PLATFORM = 'health_platform'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.HEALTH_LINK","title":"<code>HEALTH_LINK = 'health_link'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.EntityType.OBSERVATION","title":"<code>OBSERVATION = 'observation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink","title":"<code>HealthPlatformLink</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for storing temporary links for health platform integration. This model manages the temporary connection links that doctors can generate for patients to connect their health platforms (like Fitbit, Google Fit). These links have a limited validity period (24 hours) and can only be used once. The system creates a unique URL based on the UUID that patients can use to authorize the application to access their health platform data without needing to share their health platform credentials directly. Attributes:     id (int): Primary key and unique identifier     uuid (str): Unique UUID for the link, used in URLs     patient_id (int): Foreign key to the patient this link is for     doctor_id (int): Foreign key to the doctor who created the link     created_at (datetime): Link creation date/time     expires_at (datetime): Link expiration date/time (24 hours after creation)     used (bool): Whether the link has been used     platform (HealthPlatform): The health platform this link is for     patient (relationship): Relationship to the Patient model     doctor (relationship): Relationship to the Doctor model</p> Source code in <code>app/models.py</code> <pre><code>class HealthPlatformLink(db.Model):\n    \"\"\"\n    Model for storing temporary links for health platform integration.\n    This model manages the temporary connection links that doctors can generate\n    for patients to connect their health platforms (like Fitbit, Google Fit).\n    These links have a limited validity period (24 hours) and can only be used once.\n    The system creates a unique URL based on the UUID that patients can use to\n    authorize the application to access their health platform data without\n    needing to share their health platform credentials directly.\n    Attributes:\n        id (int): Primary key and unique identifier\n        uuid (str): Unique UUID for the link, used in URLs\n        patient_id (int): Foreign key to the patient this link is for\n        doctor_id (int): Foreign key to the doctor who created the link\n        created_at (datetime): Link creation date/time\n        expires_at (datetime): Link expiration date/time (24 hours after creation)\n        used (bool): Whether the link has been used\n        platform (HealthPlatform): The health platform this link is for\n        patient (relationship): Relationship to the Patient model\n        doctor (relationship): Relationship to the Doctor model\n    \"\"\"\n    __tablename__ = 'health_platform_link'\n    id = db.Column(db.Integer, primary_key=True)\n    uuid = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))\n    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)\n    doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    expires_at = db.Column(db.DateTime, default=lambda: datetime.utcnow() + timedelta(hours=24))\n    used = db.Column(db.Boolean, default=False)\n    platform = db.Column(db.Enum(HealthPlatform), nullable=False)\n    # Relationships\n    patient = db.relationship('Patient', backref=db.backref('health_platform_links', lazy='dynamic'))\n    doctor = db.relationship('Doctor', backref=db.backref('health_platform_links', lazy='dynamic'))\n    def is_expired(self):\n        \"\"\"\n        Check if the link has expired.\n        A link expires 24 hours after creation or if it has already been used.\n        This method compares the current time with the expiration timestamp.\n        Returns:\n            bool: True if the link has expired, False otherwise\n        \"\"\"\n        return datetime.utcnow() &gt; self.expires_at\n    def to_dict(self):\n        \"\"\"\n        Convert the link object to a serializable dictionary.\n        This method creates a dictionary representation of the HealthPlatformLink object\n        suitable for JSON serialization in API responses. It formats datetime\n        objects as ISO 8601 strings.\n        Returns:\n            dict: Dictionary containing all the link's attributes\n                  with datetimes converted to ISO format strings\n        \"\"\"\n        return {\n            'id': self.id,\n            'uuid': self.uuid,\n            'patient_id': self.patient_id,\n            'doctor_id': self.doctor_id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'expires_at': self.expires_at.isoformat() if self.expires_at else None,\n            'used': self.used,\n            'platform': self.platform.value if self.platform else None,\n        }\n</code></pre>"},{"location":"modules/models.html#app.models.HealthPlatformLink.__tablename__","title":"<code>__tablename__ = 'health_platform_link'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.uuid","title":"<code>uuid = db.Column(db.String(36), unique=True, nullable=False, default=(lambda: str(uuid.uuid4())))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.patient_id","title":"<code>patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.doctor_id","title":"<code>doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.created_at","title":"<code>created_at = db.Column(db.DateTime, default=(datetime.utcnow))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.expires_at","title":"<code>expires_at = db.Column(db.DateTime, default=(lambda: datetime.utcnow() + timedelta(hours=24)))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.used","title":"<code>used = db.Column(db.Boolean, default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.platform","title":"<code>platform = db.Column(db.Enum(HealthPlatform), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.patient","title":"<code>patient = db.relationship('Patient', backref=(db.backref('health_platform_links', lazy='dynamic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.doctor","title":"<code>doctor = db.relationship('Doctor', backref=(db.backref('health_platform_links', lazy='dynamic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.HealthPlatformLink.is_expired","title":"<code>is_expired()</code>","text":"<p>Check if the link has expired. A link expires 24 hours after creation or if it has already been used. This method compares the current time with the expiration timestamp. Returns:     bool: True if the link has expired, False otherwise</p> Source code in <code>app/models.py</code> <pre><code>def is_expired(self):\n    \"\"\"\n    Check if the link has expired.\n    A link expires 24 hours after creation or if it has already been used.\n    This method compares the current time with the expiration timestamp.\n    Returns:\n        bool: True if the link has expired, False otherwise\n    \"\"\"\n    return datetime.utcnow() &gt; self.expires_at\n</code></pre>"},{"location":"modules/models.html#app.models.HealthPlatformLink.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the link object to a serializable dictionary. This method creates a dictionary representation of the HealthPlatformLink object suitable for JSON serialization in API responses. It formats datetime objects as ISO 8601 strings. Returns:     dict: Dictionary containing all the link's attributes           with datetimes converted to ISO format strings</p> Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the link object to a serializable dictionary.\n    This method creates a dictionary representation of the HealthPlatformLink object\n    suitable for JSON serialization in API responses. It formats datetime\n    objects as ISO 8601 strings.\n    Returns:\n        dict: Dictionary containing all the link's attributes\n              with datetimes converted to ISO format strings\n    \"\"\"\n    return {\n        'id': self.id,\n        'uuid': self.uuid,\n        'patient_id': self.patient_id,\n        'doctor_id': self.doctor_id,\n        'created_at': self.created_at.isoformat() if self.created_at else None,\n        'expires_at': self.expires_at.isoformat() if self.expires_at else None,\n        'used': self.used,\n        'platform': self.platform.value if self.platform else None,\n    }\n</code></pre>"},{"location":"modules/models.html#app.models.AuditLog","title":"<code>AuditLog</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for storing audit logs of all actions performed in the system. This model is used to track who did what and when, for compliance, security, and accountability purposes. Each entry records details about an action performed by a specific doctor, including the affected entity, timestamp, and additional contextual information. The audit log is a critical component for healthcare applications where maintaining an immutable record of all system activities is essential for regulatory compliance (e.g., HIPAA, GDPR) and security incident investigation. Attributes:     id (int): Primary key and unique identifier     doctor_id (int): Foreign key to the doctor who performed the action     doctor (relationship): Relationship with the doctor who performed the action     timestamp (datetime): Date and time when the action was performed     action_type (ActionType): Type of action performed (enum)     entity_type (EntityType): Type of entity affected by the action (enum)     entity_id (int): ID of the entity affected by the action     details (str): Additional details about the action (stored as JSON)     patient_id (int): Optional foreign key to the patient related to the action     patient (relationship): Relationship with the patient related to the action     ip_address (str): IP address from which the action was performed</p> Source code in <code>app/models.py</code> <pre><code>class AuditLog(db.Model):\n    \"\"\"\n    Model for storing audit logs of all actions performed in the system.\n    This model is used to track who did what and when, for compliance, security,\n    and accountability purposes. Each entry records details about an action\n    performed by a specific doctor, including the affected entity, timestamp,\n    and additional contextual information.\n    The audit log is a critical component for healthcare applications where\n    maintaining an immutable record of all system activities is essential for\n    regulatory compliance (e.g., HIPAA, GDPR) and security incident investigation.\n    Attributes:\n        id (int): Primary key and unique identifier\n        doctor_id (int): Foreign key to the doctor who performed the action\n        doctor (relationship): Relationship with the doctor who performed the action\n        timestamp (datetime): Date and time when the action was performed\n        action_type (ActionType): Type of action performed (enum)\n        entity_type (EntityType): Type of entity affected by the action (enum)\n        entity_id (int): ID of the entity affected by the action\n        details (str): Additional details about the action (stored as JSON)\n        patient_id (int): Optional foreign key to the patient related to the action\n        patient (relationship): Relationship with the patient related to the action\n        ip_address (str): IP address from which the action was performed\n    \"\"\"\n    __tablename__ = 'audit_log'\n    id = db.Column(db.Integer, primary_key=True)\n    # Who performed the action\n    doctor_id = db.Column(db.Integer, db.ForeignKey('doctor.id'), nullable=False)\n    doctor = db.relationship('Doctor')\n    # When the action was performed\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)\n    # What type of action was performed\n    action_type = db.Column(db.Enum(ActionType), nullable=False)\n    # Which entity was affected\n    entity_type = db.Column(db.Enum(EntityType), nullable=False)\n    entity_id = db.Column(db.Integer, nullable=False)  # ID of the affected entity\n    # Additional details about the action (stored as JSON)\n    details = db.Column(db.Text)  # JSON string with action details\n    # Optional patient ID to facilitate queries\n    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=True)\n    patient = db.relationship('Patient')\n    # IP address of the user who performed the action\n    ip_address = db.Column(db.String(50))\n    def __init__(self, doctor_id, action_type, entity_type, entity_id, details=None, patient_id=None, ip_address=None):\n        \"\"\"\n        Initialize a new audit log record.\n        This constructor sets up a new audit log entry with the provided information.\n        The timestamp is automatically set to the current UTC time.\n        Any JSON-serializable details can be stored to provide additional context\n        about the action being logged.\n        Args:\n            doctor_id (int): ID of the doctor who performed the action\n            action_type (ActionType): Type of action performed\n            entity_type (EntityType): Type of entity affected by the action\n            entity_id (int): ID of the entity affected by the action\n            details (dict, optional): Additional details about the action\n            patient_id (int, optional): ID of the patient related to the action\n            ip_address (str, optional): IP address from which the action was performed\n        \"\"\"\n        self.doctor_id = doctor_id\n        self.action_type = action_type\n        self.entity_type = entity_type\n        self.entity_id = entity_id\n        self.details = json.dumps(details) if details else None\n        self.patient_id = patient_id\n        self.ip_address = ip_address\n    def get_details(self):\n        \"\"\"\n        Convert the JSON string of details to a Python dictionary.\n        This method retrieves the additional details stored as a JSON string\n        and deserializes them into a Python dictionary for easier access.\n        If no details are stored, an empty dictionary is returned.\n        Returns:\n            dict: The action details as a dictionary\n        \"\"\"\n        if self.details:\n            return json.loads(self.details)\n        return {}\n    def to_dict(self):\n        \"\"\"\n        Convert the audit log object to a serializable dictionary.\n        This method creates a dictionary representation of the AuditLog object\n        suitable for JSON serialization in API responses and for displaying\n        in the user interface. It formats the timestamp to UTC+2 timezone\n        and includes related entities' display names.\n        Returns:\n            dict: Dictionary containing all the audit log's attributes\n                  with properly formatted timestamp and related entity names\n        \"\"\"\n        utc_plus_2 = timezone(timedelta(hours=2))\n        timestamp = self.timestamp\n        if timestamp:\n            if timestamp.tzinfo is None:\n                timestamp = timestamp.replace(tzinfo=timezone.utc)\n            timestamp = timestamp.astimezone(utc_plus_2)\n            timestamp = timestamp.replace(microsecond=0)\n            timestamp_str = timestamp.strftime('%Y-%m-%dT%H:%M:%S')\n            timestamp_str = timestamp_str.replace('T', ' ')  # Convert to UTC format\n        else:\n            timestamp_str = None\n        return {\n            'id': self.id,\n            'doctor_id': self.doctor_id,\n            'doctor_name': f\"{self.doctor.first_name} {self.doctor.last_name}\" if self.doctor else None,\n            'timestamp': timestamp_str,\n            'action_type': self.action_type.value,\n            'entity_type': self.entity_type.value,\n            'entity_id': self.entity_id,\n            'details': self.get_details(),\n            'patient_id': self.patient_id,\n            'patient_name': f\"{self.patient.first_name} {self.patient.last_name}\" if self.patient else None,\n            'ip_address': self.ip_address\n        }\n</code></pre>"},{"location":"modules/models.html#app.models.AuditLog.__tablename__","title":"<code>__tablename__ = 'audit_log'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.id","title":"<code>id = db.Column(db.Integer, primary_key=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.doctor","title":"<code>doctor = db.relationship('Doctor')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.timestamp","title":"<code>timestamp = db.Column(db.DateTime, default=(datetime.utcnow), nullable=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.patient","title":"<code>patient = db.relationship('Patient')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.doctor_id","title":"<code>doctor_id = doctor_id</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.action_type","title":"<code>action_type = action_type</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.entity_type","title":"<code>entity_type = entity_type</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.entity_id","title":"<code>entity_id = entity_id</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.details","title":"<code>details = json.dumps(details) if details else None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.patient_id","title":"<code>patient_id = patient_id</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.ip_address","title":"<code>ip_address = ip_address</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/models.html#app.models.AuditLog.__init__","title":"<code>__init__(doctor_id, action_type, entity_type, entity_id, details=None, patient_id=None, ip_address=None)</code>","text":"<p>Initialize a new audit log record. This constructor sets up a new audit log entry with the provided information. The timestamp is automatically set to the current UTC time. Any JSON-serializable details can be stored to provide additional context about the action being logged. Args:     doctor_id (int): ID of the doctor who performed the action     action_type (ActionType): Type of action performed     entity_type (EntityType): Type of entity affected by the action     entity_id (int): ID of the entity affected by the action     details (dict, optional): Additional details about the action     patient_id (int, optional): ID of the patient related to the action     ip_address (str, optional): IP address from which the action was performed</p> Source code in <code>app/models.py</code> <pre><code>def __init__(self, doctor_id, action_type, entity_type, entity_id, details=None, patient_id=None, ip_address=None):\n    \"\"\"\n    Initialize a new audit log record.\n    This constructor sets up a new audit log entry with the provided information.\n    The timestamp is automatically set to the current UTC time.\n    Any JSON-serializable details can be stored to provide additional context\n    about the action being logged.\n    Args:\n        doctor_id (int): ID of the doctor who performed the action\n        action_type (ActionType): Type of action performed\n        entity_type (EntityType): Type of entity affected by the action\n        entity_id (int): ID of the entity affected by the action\n        details (dict, optional): Additional details about the action\n        patient_id (int, optional): ID of the patient related to the action\n        ip_address (str, optional): IP address from which the action was performed\n    \"\"\"\n    self.doctor_id = doctor_id\n    self.action_type = action_type\n    self.entity_type = entity_type\n    self.entity_id = entity_id\n    self.details = json.dumps(details) if details else None\n    self.patient_id = patient_id\n    self.ip_address = ip_address\n</code></pre>"},{"location":"modules/models.html#app.models.AuditLog.get_details","title":"<code>get_details()</code>","text":"<p>Convert the JSON string of details to a Python dictionary. This method retrieves the additional details stored as a JSON string and deserializes them into a Python dictionary for easier access. If no details are stored, an empty dictionary is returned. Returns:     dict: The action details as a dictionary</p> Source code in <code>app/models.py</code> <pre><code>def get_details(self):\n    \"\"\"\n    Convert the JSON string of details to a Python dictionary.\n    This method retrieves the additional details stored as a JSON string\n    and deserializes them into a Python dictionary for easier access.\n    If no details are stored, an empty dictionary is returned.\n    Returns:\n        dict: The action details as a dictionary\n    \"\"\"\n    if self.details:\n        return json.loads(self.details)\n    return {}\n</code></pre>"},{"location":"modules/models.html#app.models.AuditLog.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the audit log object to a serializable dictionary. This method creates a dictionary representation of the AuditLog object suitable for JSON serialization in API responses and for displaying in the user interface. It formats the timestamp to UTC+2 timezone and includes related entities' display names. Returns:     dict: Dictionary containing all the audit log's attributes           with properly formatted timestamp and related entity names</p> Source code in <code>app/models.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the audit log object to a serializable dictionary.\n    This method creates a dictionary representation of the AuditLog object\n    suitable for JSON serialization in API responses and for displaying\n    in the user interface. It formats the timestamp to UTC+2 timezone\n    and includes related entities' display names.\n    Returns:\n        dict: Dictionary containing all the audit log's attributes\n              with properly formatted timestamp and related entity names\n    \"\"\"\n    utc_plus_2 = timezone(timedelta(hours=2))\n    timestamp = self.timestamp\n    if timestamp:\n        if timestamp.tzinfo is None:\n            timestamp = timestamp.replace(tzinfo=timezone.utc)\n        timestamp = timestamp.astimezone(utc_plus_2)\n        timestamp = timestamp.replace(microsecond=0)\n        timestamp_str = timestamp.strftime('%Y-%m-%dT%H:%M:%S')\n        timestamp_str = timestamp_str.replace('T', ' ')  # Convert to UTC format\n    else:\n        timestamp_str = None\n    return {\n        'id': self.id,\n        'doctor_id': self.doctor_id,\n        'doctor_name': f\"{self.doctor.first_name} {self.doctor.last_name}\" if self.doctor else None,\n        'timestamp': timestamp_str,\n        'action_type': self.action_type.value,\n        'entity_type': self.entity_type.value,\n        'entity_id': self.entity_id,\n        'details': self.get_details(),\n        'patient_id': self.patient_id,\n        'patient_name': f\"{self.patient.first_name} {self.patient.last_name}\" if self.patient else None,\n        'ip_address': self.ip_address\n    }\n</code></pre>"},{"location":"modules/observations.html","title":"Observations","text":"<p>Observations Module. This module provides functionality for creating, retrieving, updating, and deleting vital sign observations for patients. It includes web routes for the application's user interface as well as utility functions for working with observation data. Observations represent medical professionals' interpretations of vital sign data over specific time periods, allowing tracking and analysis of patient health trends.</p>"},{"location":"modules/observations.html#app.observations.observations_bp","title":"<code>observations_bp = Blueprint('observations', __name__)</code>  <code>module-attribute</code>","text":"<p>Observations Blueprint. This blueprint manages all routes related to vital sign observations, including creating, retrieving, updating, and deleting observations. It provides both web interface endpoints and utility functions for  handling observation data.</p>"},{"location":"modules/observations.html#app.observations.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Observations module logger. Logger for observation-related events such as creation, updates,  and deletions of vital sign observations, along with any errors that occur during these operations.</p>"},{"location":"modules/observations.html#app.observations.get_web_observations","title":"<code>get_web_observations(patient_id)</code>","text":"<p>Get observations for a specific patient. This endpoint retrieves vital sign observations for a specific patient with optional filtering by date range and vital sign type. Args:     patient_id (int): The ID of the patient to get observations for Query Parameters:     start_date (str, optional): ISO formatted date to filter observations after     end_date (str, optional): ISO formatted date to filter observations before     vital_type (str, optional): Type of vital sign to filter by Returns:     JSON response with filtered observations or error message</p> Source code in <code>app/observations.py</code> <pre><code>@observations_bp.route('/web/observations/&lt;int:patient_id&gt;', methods=['GET'])\n@login_required\ndef get_web_observations(patient_id):\n    \"\"\"\n    Get observations for a specific patient.\n    This endpoint retrieves vital sign observations for a specific patient\n    with optional filtering by date range and vital sign type.\n    Args:\n        patient_id (int): The ID of the patient to get observations for\n    Query Parameters:\n        start_date (str, optional): ISO formatted date to filter observations after\n        end_date (str, optional): ISO formatted date to filter observations before\n        vital_type (str, optional): Type of vital sign to filter by\n    Returns:\n        JSON response with filtered observations or error message\n    \"\"\"    # Find the patient\n    patient = Patient.query.get_or_404(patient_id)\n    # Verify that the doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Get query parameters for filtering\n    start_date_str = request.args.get('start_date')\n    end_date_str = request.args.get('end_date')\n    vital_type = request.args.get('vital_type')\n    # Create query\n    query = VitalObservation.query.filter_by(patient_id=patient_id)\n      # Apply filters\n    if start_date_str:\n        try:\n            start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00'))\n            query = query.filter(VitalObservation.start_date &gt;= start_date)\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid start date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    if end_date_str:\n        try:\n            end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00'))\n            query = query.filter(VitalObservation.end_date &lt;= end_date)\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid end date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    if vital_type:\n        try:\n            vital_type_enum = VitalSignType(vital_type)\n            query = query.filter_by(vital_type=vital_type_enum)\n        except ValueError:\n            return jsonify({\n                \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                    \"types\": \", \".join(t.value for t in VitalSignType)\n                }\n            }), 400\n    # Execute query\n    observations = query.order_by(VitalObservation.created_at.desc()).all()\n    return jsonify([obs.to_dict() for obs in observations]), 200\n</code></pre>"},{"location":"modules/observations.html#app.observations.add_web_observation","title":"<code>add_web_observation()</code>","text":"<p>Add a new vital sign observation. This endpoint creates a new observation for a patient's vital signs over a specific time period. The observation includes interpretation and notes from the doctor. Request Body JSON:     patient_id (int): ID of the patient the observation is for     vital_type (str): Type of vital sign from VitalSignType enum     content (str): Doctor's notes and interpretation of the vital sign data     start_date (str): ISO formatted start date of the observation period     end_date (str): ISO formatted end date of the observation period Returns:     JSON response with the created observation or error message Status Codes:     201: Observation created successfully     400: Invalid request data     403: Not authorized to create observation for this patient     404: Patient not found     500: Database error</p> Source code in <code>app/observations.py</code> <pre><code>@observations_bp.route('/web/observations', methods=['POST'])\n@login_required\ndef add_web_observation():\n    \"\"\"\n    Add a new vital sign observation.\n    This endpoint creates a new observation for a patient's vital signs over a specific\n    time period. The observation includes interpretation and notes from the doctor.\n    Request Body JSON:\n        patient_id (int): ID of the patient the observation is for\n        vital_type (str): Type of vital sign from VitalSignType enum\n        content (str): Doctor's notes and interpretation of the vital sign data\n        start_date (str): ISO formatted start date of the observation period\n        end_date (str): ISO formatted end date of the observation period\n    Returns:\n        JSON response with the created observation or error message\n    Status Codes:\n        201: Observation created successfully\n        400: Invalid request data\n        403: Not authorized to create observation for this patient\n        404: Patient not found\n        500: Database error\n    \"\"\"    # Validate request data\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON data in request\")}), 400\n    data = request.json\n    logger.debug(f\"Data received for new observation: {data}\")\n    # Validate required fields\n    required_fields = ['patient_id', 'vital_type', 'content', 'start_date', 'end_date']\n    for field in required_fields:\n        if field not in data:\n            return jsonify({\"error\": _(\"Required field missing: %(field)s\") % {\"field\": field}}), 400\n    # Find the patient\n    patient_id = data['patient_id']\n    patient = Patient.query.get(patient_id)\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Verify that the doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n      # Validate vital sign type\n    try:\n        logger.debug(f\"Received vital sign type: {data['vital_type']}\")\n        logger.debug(f\"Available vital sign types: {[t.value for t in VitalSignType]}\")\n        vital_type = VitalSignType(data['vital_type'])\n    except ValueError as e:\n        logger.error(f\"Invalid vital sign type: {data['vital_type']}, error: {str(e)}\")\n        return jsonify({\n            \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                \"types\": \", \".join(t.value for t in VitalSignType)\n            }\n        }), 400\n    # Parse dates\n    try:\n        start_date = datetime.fromisoformat(data['start_date'].replace('Z', '+00:00'))\n    except ValueError:\n        return jsonify({\"error\": _(\"Invalid start date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    try:\n        end_date = datetime.fromisoformat(data['end_date'].replace('Z', '+00:00'))\n    except ValueError:\n        return jsonify({\"error\": _(\"Invalid end date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Verify that start date is before end date\n    if start_date &gt;= end_date:\n        return jsonify({\"error\": _(\"Start date must be before end date\")}), 400\n      # Create the observation\n    try:\n        observation = VitalObservation(\n            patient_id=patient_id,\n            doctor_id=current_user.id,\n            vital_type=vital_type,\n            content=data['content'],\n            start_date=start_date,\n            end_date=end_date\n        )\n        db.session.add(observation)\n        db.session.commit()\n        # Audit logging\n        try:\n            log_observation_creation(current_user.id, observation)\n        except Exception as e:\n            logger.error(f\"Error during audit logging for observation creation: {str(e)}\")\n        logger.info(f\"Observation added for patient {patient_id} by doctor {current_user.id}\")\n        return jsonify({\n            \"message\": _(\"Observation added successfully\"),\n            \"observation\": observation.to_dict()\n        }), 201\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error while adding the observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while adding the observation\")}), 500\n</code></pre>"},{"location":"modules/observations.html#app.observations.update_web_observation","title":"<code>update_web_observation(observation_id)</code>","text":"<p>Update an existing vital sign observation. This endpoint allows doctors to modify their own previously created observations. Any combination of observation fields may be updated. Args:     observation_id (int): ID of the observation to update Request Body JSON:     vital_type (str, optional): New type of vital sign     content (str, optional): Updated notes or interpretation     start_date (str, optional): New ISO formatted start date     end_date (str, optional): New ISO formatted end date Returns:     JSON response with the updated observation or error message Status Codes:     200: Observation updated successfully     400: Invalid request data     403: Not authorized to modify this observation     404: Observation not found     500: Database error</p> Source code in <code>app/observations.py</code> <pre><code>@observations_bp.route('/web/observations/&lt;int:observation_id&gt;', methods=['PUT'])\n@login_required\ndef update_web_observation(observation_id):\n    \"\"\"\n    Update an existing vital sign observation.\n    This endpoint allows doctors to modify their own previously created observations.\n    Any combination of observation fields may be updated.\n    Args:\n        observation_id (int): ID of the observation to update\n    Request Body JSON:\n        vital_type (str, optional): New type of vital sign\n        content (str, optional): Updated notes or interpretation\n        start_date (str, optional): New ISO formatted start date\n        end_date (str, optional): New ISO formatted end date\n    Returns:\n        JSON response with the updated observation or error message\n    Status Codes:\n        200: Observation updated successfully\n        400: Invalid request data\n        403: Not authorized to modify this observation\n        404: Observation not found\n        500: Database error\n    \"\"\"    # Find the observation\n    observation = VitalObservation.query.get_or_404(observation_id)\n    # Verify that the doctor is the creator of the observation\n    if observation.doctor_id != current_user.id:\n        return jsonify({\"error\": _(\"You are not authorized to modify this observation\")}), 403\n    # Validate the request data\n    if not request.is_json:\n        return jsonify({\"error\": _(\"Missing JSON data in request\")}), 400\n    data = request.json\n      # Update the vital sign type if provided\n    if 'vital_type' in data:\n        try:\n            observation.vital_type = VitalSignType(data['vital_type'])\n        except ValueError:\n            return jsonify({\n                \"error\": _(\"Invalid vital sign type. Must be one of: %(types)s\") % {\n                    \"types\": \", \".join(t.value for t in VitalSignType)\n                }\n            }), 400\n    # Update the content if provided\n    if 'content' in data:\n        observation.content = data['content']\n    # Update the start date if provided\n    if 'start_date' in data:\n        try:\n            observation.start_date = datetime.fromisoformat(data['start_date'].replace('Z', '+00:00'))\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid start date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Aggiorna la data di fine se fornita\n    if 'end_date' in data:\n        try:\n            observation.end_date = datetime.fromisoformat(data['end_date'].replace('Z', '+00:00'))\n        except ValueError:\n            return jsonify({\"error\": _(\"Invalid end date format. Use ISO format (YYYY-MM-DD)\")}), 400\n    # Verify that start date is before end date\n    if observation.start_date &gt;= observation.end_date:\n        return jsonify({\"error\": _(\"Start date must be before end date\")}), 400\n    # Save the changes\n    try:\n        # Save previous data for audit\n        old_data = {\n            'vital_type': observation.vital_type.value if observation.vital_type else None,\n            'content': observation.content,\n            'start_date': observation.start_date.isoformat() if observation.start_date else None,\n            'end_date': observation.end_date.isoformat() if observation.end_date else None,\n        }\n        observation.updated_at = datetime.utcnow()\n        db.session.commit()\n        # Audit logging\n        try:\n            log_observation_update(current_user.id, observation, old_data)\n        except Exception as e:\n            logger.error(f\"Error during audit logging for observation update: {str(e)}\")\n        logger.info(f\"Observation {observation_id} updated by doctor {current_user.id}\")\n        return jsonify({\n            \"message\": _(\"Observation updated successfully\"),\n            \"observation\": observation.to_dict()\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error while updating the observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while updating the observation\")}), 500\n</code></pre>"},{"location":"modules/observations.html#app.observations.delete_web_observation","title":"<code>delete_web_observation(observation_id)</code>","text":"<p>Delete an existing vital sign observation. This endpoint allows doctors to remove their own previously created observations. A record of the deletion is maintained in the audit log for compliance purposes. Args:     observation_id (int): ID of the observation to delete Returns:     JSON response with success message or error details Status Codes:     200: Observation deleted successfully     403: Not authorized to delete this observation     404: Observation not found     500: Database error</p> Source code in <code>app/observations.py</code> <pre><code>@observations_bp.route('/web/observations/&lt;int:observation_id&gt;', methods=['DELETE'])\n@login_required\ndef delete_web_observation(observation_id):\n    \"\"\"\n    Delete an existing vital sign observation.\n    This endpoint allows doctors to remove their own previously created observations.\n    A record of the deletion is maintained in the audit log for compliance purposes.\n    Args:\n        observation_id (int): ID of the observation to delete\n    Returns:\n        JSON response with success message or error details\n    Status Codes:\n        200: Observation deleted successfully\n        403: Not authorized to delete this observation\n        404: Observation not found\n        500: Database error\n    \"\"\"    # Find the observation\n    observation = VitalObservation.query.get_or_404(observation_id)\n    # Verify that the doctor is the creator of the observation\n    if observation.doctor_id != current_user.id:\n        return jsonify({\"error\": _(\"You are not authorized to delete this observation\")}), 403\n    # Delete the observation\n    try:\n        # Save a copy of the observation data before deletion for audit\n        observation_copy = {\n            'id': observation.id,\n            'patient_id': observation.patient_id,\n            'vital_type': observation.vital_type,\n            'content': observation.content,\n            'start_date': observation.start_date,\n            'end_date': observation.end_date\n        }        \n        db.session.delete(observation)\n        db.session.commit()\n        # Audit logging\n        try:\n            # Create a temporary object with attributes needed for logging\n            class TempObservation:\n                def __init__(self, data):\n                    self.id = data['id']\n                    self.patient_id = data['patient_id']\n                    self.vital_type = data['vital_type']\n                    self.content = data['content']\n                    self.start_date = data['start_date']\n                    self.end_date = data['end_date']\n            temp_obs = TempObservation(observation_copy)\n            log_observation_delete(current_user.id, temp_obs)\n        except Exception as e:\n            logger.error(f\"Error during audit logging for observation deletion: {str(e)}\")\n        logger.info(f\"Observation {observation_id} deleted by doctor {current_user.id}\")\n        return jsonify({\n            \"message\": _(\"Observation deleted successfully\")\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error while deleting the observation: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while deleting the observation\")}), 500\n</code></pre>"},{"location":"modules/reports.html","title":"Reports","text":"<p>Reports Generation Module. This module provides functionality for generating patient health reports in various formats (PDF, CSV, etc.). It includes: 1. Functions to create graphical charts for vital signs visualization 2. Data processing utilities to prepare and format health data for reporting 3. PDF generation with ReportLab for comprehensive patient reports 4. CSV export functionality for data analysis Reports can include multiple vital signs, observations, and trends over configurable time periods, providing healthcare professionals with valuable insights.</p>"},{"location":"modules/reports.html#app.reports.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Mapping of period codes to their duration in days. This dictionary defines the number of days that each period identifier represents, used for calculating date ranges when generating reports and charts. Keys:     '1d': One day     '7d': One week (7 days)     '1m': One month (approximated as 30 days)     '3m': Three months (approximated as 90 days)     '1y': One year (approximated as 365 days)</p>"},{"location":"modules/reports.html#app.reports.PERIOD_DAYS","title":"<code>PERIOD_DAYS = {'1d': 1, '7d': 7, '1m': 30, '3m': 90, '1y': 365}</code>  <code>module-attribute</code>","text":""},{"location":"modules/reports.html#app.reports.create_vital_chart","title":"<code>create_vital_chart(vitals_data, period_name, vital_type)</code>","text":"<p>Create a chart drawing for a specific vital sign and time period. This function generates a professionally styled line chart visualization for vital sign data over a specified time period. It handles data sorting, formatting, and limiting the number of data points to ensure readability. The function applies appropriate styling based on the vital sign type including specific colors and formatting. Args:     vitals_data (list): List of dictionaries containing vital sign data points.         Each dictionary must have at least 'value' and 'timestamp' keys.     period_name (str): Name of the time period for the chart title (e.g. \"Last 7 days\").     vital_type (str): Type of vital sign from VitalSignType enum values (e.g. \"heart_rate\"). Returns:     Drawing: ReportLab Drawing object containing the styled chart ready to be             included in a PDF document.</p> Source code in <code>app/reports.py</code> <pre><code>def create_vital_chart(vitals_data, period_name, vital_type):\n    \"\"\"\n    Create a chart drawing for a specific vital sign and time period.\n    This function generates a professionally styled line chart visualization for vital sign data\n    over a specified time period. It handles data sorting, formatting, and limiting the number\n    of data points to ensure readability. The function applies appropriate styling based on the\n    vital sign type including specific colors and formatting.\n    Args:\n        vitals_data (list): List of dictionaries containing vital sign data points.\n            Each dictionary must have at least 'value' and 'timestamp' keys.\n        period_name (str): Name of the time period for the chart title (e.g. \"Last 7 days\").\n        vital_type (str): Type of vital sign from VitalSignType enum values (e.g. \"heart_rate\").\n    Returns:\n        Drawing: ReportLab Drawing object containing the styled chart ready to be\n                included in a PDF document.\n    \"\"\"\n    # Sort data by timestamp\n    sorted_data = sorted(vitals_data, key=lambda v: v.get('timestamp', ''))\n    # Extract values and dates for chart\n    values = [float(v.get('value', 0)) for v in sorted_data]\n    timestamps = [v.get('timestamp', '') for v in sorted_data]\n    # Format dates for display\n    dates = []\n    for ts in timestamps:\n        if ts:\n            try:\n                dt = datetime.fromisoformat(ts.replace('Z', '+00:00'))\n                dates.append(dt.strftime('%d/%m'))\n            except (ValueError, AttributeError):\n                dates.append('')\n        else:\n            dates.append('')\n    # Limit number of data points to make chart readable\n    max_points = 20\n    if len(values) &gt; max_points:\n        step = len(values) // max_points\n        values = values[::step]\n        dates = dates[::step]\n    # Create drawing and chart\n    drawing = Drawing(500, 220)\n      # Define chart colors based on vital type\n    chart_colors = {\n    'heart_rate': colors.red,\n    'oxygen_saturation': colors.blue,\n    'breathing_rate': colors.cyan,\n    'weight': colors.green,\n    'temperature_core': colors.orange,\n    'temperature_skin': colors.orange,\n    'steps': colors.teal,\n    'calories': colors.orange,  # &lt;-- ADDED\n    'sleep_duration': colors.navy,\n    'distance': colors.green,\n    'active_minutes': colors.purple,\n    'floors_climbed': colors.saddlebrown,\n    'elevation': colors.brown,\n    'activity_calories': colors.orange,\n    'calories_bmr': colors.orange,\n    'minutes_sedentary': colors.gray,\n    'minutes_lightly_active': colors.lightgreen,\n    'minutes_fairly_active': colors.yellow,\n    'calories_in': colors.red,\n    'water': colors.blue\n}\n    chart_color = chart_colors.get(vital_type, colors.blueviolet)\n    chart = HorizontalLineChart()\n    chart.width = 450\n    chart.height = 170\n    chart.x = 25\n    chart.y = 20\n    # Set data\n    if values:\n        chart.data = [values]\n        chart.categoryAxis.categoryNames = dates\n        chart.valueAxis.valueMin = min(values) * 0.9 if values else 0\n        chart.valueAxis.valueMax = max(values) * 1.1 if values else 100\n        # Ensure min and max are float\n        chart.valueAxis.valueMin = float(chart.valueAxis.valueMin)\n        chart.valueAxis.valueMax = float(chart.valueAxis.valueMax)\n        # Style the chart\n        chart.lines[0].strokeWidth = 2.5\n        chart.lines[0].strokeColor = chart_color\n        # Enhance chart appearance\n        chart.categoryAxis.labels.angle = 30\n        chart.categoryAxis.labels.boxAnchor = 'ne'\n        chart.categoryAxis.labels.fontName = 'Helvetica'\n        chart.categoryAxis.labels.fontSize = 7\n        chart.valueAxis.labels.fontName = 'Helvetica'\n        chart.valueAxis.labels.fontSize = 8\n        # Configurazione griglia\n        chart.categoryAxis.strokeWidth = 0.5\n        chart.valueAxis.strokeWidth = 0.5\n        chart.valueAxis.gridStrokeWidth = 0.25\n        chart.valueAxis.gridStrokeColor = colors.lightgrey\n        # Add title\n        vital_name = vital_type.replace('_', ' ').title()\n        title = f\"{vital_name} - {period_name}\"\n        drawing.add(chart)\n        # Add legend with title\n        legend = Legend()\n        legend.alignment = 'right'\n        legend.x = 25\n        legend.y = 200\n        legend.columnMaximum = 1\n        legend.fontName = 'Helvetica-Bold'\n        legend.fontSize = 9\n        legend.dxTextSpace = 5\n        legend.dy = 5\n        legend.dx = 10\n        legend.deltay = 10\n        legend.colorNamePairs = [(chart_color, title)]\n        drawing.add(legend)\n    return drawing\n</code></pre>"},{"location":"modules/reports.html#app.reports.generate_specific_report","title":"<code>generate_specific_report(patient, doctor, selected_notes, selected_vital_types, selected_charts, selected_observations, summary=None, language=None)</code>","text":"<p>Generate a customized PDF report with only selected patient data. This function creates a professionally formatted PDF report containing only the specifically selected vital signs, observations, and clinical notes for a patient. The report includes patient and doctor information, optional summary text, selected clinical notes, vital sign charts for selected time periods, and relevant medical observations. The PDF is styled with a modern, clean design optimized for medical professionals. Args:     patient (Patient): Patient object containing demographic and identification information.     doctor (Doctor): Doctor object representing the healthcare professional generating the report.     selected_notes (list): List of selected Note objects to include in the report.     selected_vital_types (list): List of VitalSignType enum values for which charts should be generated.     selected_charts (dict): Dictionary mapping vital type values to lists of time period codes                           (e.g. {'heart_rate': ['7d', '1m']}). Controls which charts are included.     selected_observations (list): List of VitalObservation objects to include in the report.     summary (str, optional): Optional summary text provided by the doctor. This text appears                            at the beginning of the report but is not saved to the database.     language (str, optional): Optional language code override ('it' or 'en').                             If not provided, uses the current Flask-Babel locale. Returns:     BytesIO: PDF file as a binary stream ready to be served to the client or saved.             The PDF follows medical documentation best practices and includes             proper headers, footers, and organizational structure.</p> Source code in <code>app/reports.py</code> <pre><code>def generate_specific_report(patient, doctor, selected_notes, selected_vital_types, selected_charts, selected_observations, summary=None, language=None):\n    \"\"\"\n    Generate a customized PDF report with only selected patient data.\n    This function creates a professionally formatted PDF report containing only the\n    specifically selected vital signs, observations, and clinical notes for a patient.\n    The report includes patient and doctor information, optional summary text, selected\n    clinical notes, vital sign charts for selected time periods, and relevant medical\n    observations. The PDF is styled with a modern, clean design optimized for medical\n    professionals.\n    Args:\n        patient (Patient): Patient object containing demographic and identification information.\n        doctor (Doctor): Doctor object representing the healthcare professional generating the report.\n        selected_notes (list): List of selected Note objects to include in the report.\n        selected_vital_types (list): List of VitalSignType enum values for which charts should be generated.\n        selected_charts (dict): Dictionary mapping vital type values to lists of time period codes\n                              (e.g. {'heart_rate': ['7d', '1m']}). Controls which charts are included.\n        selected_observations (list): List of VitalObservation objects to include in the report.\n        summary (str, optional): Optional summary text provided by the doctor. This text appears\n                               at the beginning of the report but is not saved to the database.\n        language (str, optional): Optional language code override ('it' or 'en').\n                                If not provided, uses the current Flask-Babel locale.\n    Returns:\n        BytesIO: PDF file as a binary stream ready to be served to the client or saved.\n                The PDF follows medical documentation best practices and includes\n                proper headers, footers, and organizational structure.\n    \"\"\"\n    buffer = BytesIO()\n    # Set language if provided (Flask-Babel handles this automatically if None)\n    if language:\n        # Qui potrebbe essere necessario un meccanismo per impostare la lingua temporaneamente\n        pass\n    # Create the PDF document\n    doc = SimpleDocTemplate(\n        buffer,\n        pagesize=letter,\n        rightMargin=54,  # 3/4 inch margins for more modern look\n        leftMargin=54,\n        topMargin=54,\n        bottomMargin=54\n    )\n    # Get styles\n    styles = getSampleStyleSheet()\n    # Add custom styles for modern look\n    styles.add(ParagraphStyle(\n        name='Heading1Center',\n        parent=styles['Heading1'],\n        alignment=1,  # 0=left, 1=center, 2=right\n        fontName='Helvetica-Bold',\n        fontSize=16,\n        spaceAfter=12,\n        textColor=colors.darkblue\n    ))\n    styles.add(ParagraphStyle(\n        name='Heading2Modern',\n        parent=styles['Heading2'],\n        fontName='Helvetica-Bold',\n        fontSize=14,\n        spaceAfter=6,\n        textColor=colors.darkblue\n    ))\n    styles.add(ParagraphStyle(\n        name='Heading3Modern',\n        parent=styles['Heading3'],\n        fontName='Helvetica-Bold',\n        fontSize=12,\n        spaceAfter=6,\n        textColor=colors.navy\n    ))\n    styles.add(ParagraphStyle(\n        name='Normal-Center',\n        parent=styles['Normal'],\n        alignment=1,\n        fontSize=10\n    ))\n    styles.add(ParagraphStyle(\n        name='Normal-Bold',\n        parent=styles['Normal'],\n        fontName='Helvetica-Bold',\n        fontSize=10\n    ))\n    styles.add(ParagraphStyle(\n        name='Normal-Italic',\n        parent=styles['Normal'],\n        fontName='Helvetica-Oblique',\n        fontSize=10\n    ))\n    styles.add(ParagraphStyle(\n        name='ObservationTitle',\n        parent=styles['Normal-Bold'],\n        fontSize=10,\n        textColor=colors.darkblue\n    ))\n    styles.add(ParagraphStyle(\n        name='ObservationContent',\n        parent=styles['Normal'],\n        fontSize=10,\n        leftIndent=15\n    ))\n    styles.add(ParagraphStyle(\n        name='Footer',\n        parent=styles['Normal'],\n        fontSize=8,\n        textColor=colors.grey\n    ))\n    # Build content\n    content = []\n    # Report Header with modern style\n    content.append(Paragraph(_('Specific Report'), styles['Heading1Center']))\n    content.append(Spacer(1, 6))\n    # Date of report\n    content.append(Paragraph(f\"{_('Generated on')}: {datetime.now().strftime('%d/%m/%Y %H:%M')}\", styles['Normal-Center']))\n    content.append(Spacer(1, 24))\n    # Define a modern table style with rounded corners using background colors\n    modern_table_style = [\n        ('BACKGROUND', (0, 0), (0, -1), colors.lavender),\n        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),\n        ('ALIGN', (0, 0), (0, -1), 'RIGHT'),\n        ('ALIGN', (1, 0), (1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n        ('FONTSIZE', (0, 0), (-1, -1), 10),\n        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),\n        ('TOPPADDING', (0, 0), (-1, -1), 8),\n        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),\n        ('BOX', (0, 0), (-1, -1), 0.5, colors.grey),\n        ('BACKGROUND', (1, 0), (1, -1), colors.white),\n        ('LINEBELOW', (0, 0), (-1, -2), 0.5, colors.grey),\n        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey)\n    ]\n    # Patient Information with modern styling\n    content.append(Paragraph(_('Patient Information'), styles['Heading2Modern']))\n    content.append(Spacer(1, 6))\n    patient_data = [\n        [f\"{_('Name')}:\", f\"{patient.first_name} {patient.last_name}\"],\n        [f\"{_('Date of Birth')}:\", patient.date_of_birth.strftime('%d/%m/%Y')],\n        [f\"{_('Gender')}:\", patient.gender or _('Not specified')],\n        [f\"{_('Contact')}:\", patient.contact_number],\n        [f\"{_('Email')}:\", patient.email or _('Not provided')]\n    ]\n    patient_table = Table(patient_data, colWidths=[1.5*inch, 4*inch])\n    patient_table.setStyle(TableStyle(modern_table_style))\n    content.append(patient_table)\n    content.append(Spacer(1, 18))\n    # Doctor Information\n    content.append(Paragraph(_('Attending Physician'), styles['Heading2Modern']))\n    content.append(Spacer(1, 6))\n    doctor_data = [\n        [f\"{_('Name')}:\", f\"Dr. {doctor.first_name} {doctor.last_name}\"],\n        [f\"{_('Specialty')}:\", doctor.specialty or _('General Practice')],\n        [f\"{_('Email')}:\", doctor.email]\n    ]\n    doctor_table = Table(doctor_data, colWidths=[1.5*inch, 4*inch])\n    doctor_table.setStyle(TableStyle(modern_table_style))\n    content.append(doctor_table)\n    content.append(Spacer(1, 36)) # More spacing for clearer separation\n    # Summary section (if provided)\n    if summary:\n        content.append(Paragraph(_('Summary'), styles['Heading2Modern']))\n        content.append(Spacer(1, 6))\n        content.append(Paragraph(summary, styles['Normal']))\n        content.append(Spacer(1, 24))\n    # Selected notes section\n    if selected_notes:\n        content.append(Paragraph(_('Clinical Notes'), styles['Heading2Modern']))\n        content.append(Spacer(1, 8))\n        for i, note in enumerate(selected_notes):\n            date_str = note.created_at.strftime('%d/%m/%Y %H:%M')\n            doctor_name = f\"Dr. {note.doctor.first_name} {note.doctor.last_name}\"\n            content.append(Paragraph(f\"&lt;b&gt;{date_str} - {doctor_name}&lt;/b&gt;\", styles['Normal-Bold']))\n            content.append(Paragraph(note.content, styles['ObservationContent']))\n            content.append(Spacer(1, 8))\n            # Add a divider between notes except for the last one\n            if i &lt; len(selected_notes) - 1:\n                content.append(Spacer(1, 3))\n                content.append(Paragraph(\"&lt;hr width='100%' color='#e0e0e0' /&gt;\", styles['Normal-Center']))\n                content.append(Spacer(1, 8))\n        content.append(Spacer(1, 24))\n    # Group observations by vital type for later use\n    obs_by_type = {}\n    if selected_observations:\n        for obs in selected_observations:\n            vital_type = obs.vital_type.value\n            if vital_type not in obs_by_type:\n                obs_by_type[vital_type] = []\n            obs_by_type[vital_type].append(obs)\n    # Selected vital signs section with integrated observations\n    if selected_vital_types and selected_charts:\n        content.append(Paragraph(_('Vital Signs'), styles['Heading2Modern']))\n        content.append(Spacer(1, 8))\n        from .health_platforms import get_vitals_data\n        # Define colors for each vital type\n        vital_colors = {\n        'heart_rate': colors.red,\n        'steps': colors.teal,\n        'calories': colors.orange,\n        'distance': colors.green,\n        'active_minutes': colors.purple,\n        'sleep_duration': colors.navy,\n        'floors_climbed': colors.saddlebrown,\n        'elevation': colors.brown,\n        'weight': colors.green,\n        'activity_calories': colors.orange,\n        'calories_bmr': colors.orange,\n        'minutes_sedentary': colors.gray,\n        'minutes_lightly_active': colors.lightgreen,\n        'minutes_fairly_active': colors.yellow,\n        'calories_in': colors.red,\n        'water': colors.blue,\n        'breathing_rate': colors.cyan,\n        'oxygen_saturation': colors.blue,\n        'temperature_core': colors.orange,\n        'temperature_skin': colors.orange\n        }\n        for vital_type in selected_vital_types:\n            vital_type_value = vital_type.value\n            color = vital_colors.get(vital_type_value, colors.darkblue)\n            # Create a paragraph style with the specific vital color\n            styles.add(ParagraphStyle(\n                name=f'Heading3-{vital_type_value}',\n                parent=styles['Heading3Modern'],\n                textColor=color\n            ))\n            content.append(Paragraph(f\"{vital_type_value.replace('_', ' ').title()}\", styles[f'Heading3-{vital_type_value}']))\n            content.append(Spacer(1, 6))\n            has_data = False\n            # Check if this vital type has selected charts\n            if vital_type_value in selected_charts and selected_charts[vital_type_value]:\n                periods = selected_charts[vital_type_value]\n                for period_days in periods:\n                    # Get period display name\n                    if period_days == 1:\n                        period_name = _('1 Day')\n                    elif period_days == 7:\n                        period_name = _('7 Days')\n                    elif period_days == 30:\n                        period_name = _('1 Month')\n                    elif period_days == 90:\n                        period_name = _('3 Months')\n                    else:\n                        period_name = f\"{period_days} {_('days')}\"\n                    # Calculate date range\n                    end_date = datetime.now()\n                    start_date = end_date - timedelta(days=period_days)\n                    # Display date range in an elegant way\n                    date_range_text = f\"{start_date.strftime('%d/%m/%Y')} - {end_date.strftime('%d/%m/%Y')}\"\n                    content.append(Paragraph(f\"&lt;i&gt;{date_range_text}&lt;/i&gt;\", styles['Normal-Italic']))\n                    content.append(Spacer(1, 6))\n                    try:\n                        # Try to get data from health platform\n                        vitals_data = get_vitals_data(\n                            patient,\n                            vital_type_value,\n                            start_date.strftime('%Y-%m-%d'),\n                            end_date.strftime('%Y-%m-%d')\n                        )\n                        if vitals_data and len(vitals_data) &gt; 0:\n                            has_data = True\n                            # Create chart\n                            chart = create_vital_chart(vitals_data, period_name, vital_type_value)\n                            content.append(chart)\n                            content.append(Spacer(1, 12))\n                        else:\n                            content.append(Paragraph(f\"{period_name}: {_('No vital data available for this period.')}\", styles['Normal-Italic']))\n                            content.append(Spacer(1, 6))\n                    except Exception as e:\n                        logger.error(f\"Error getting data for {vital_type_value}: {str(e)}\")\n                        content.append(Paragraph(f\"{period_name}: {_('No vital data available for this period.')}\", styles['Normal-Italic']))\n                        content.append(Spacer(1, 6))\n            else:\n                content.append(Paragraph(_('No vital data available for this period.'), styles['Normal-Italic']))\n            # Add observations for this vital type immediately after its charts\n            if vital_type_value in obs_by_type and obs_by_type[vital_type_value]:\n                if has_data:\n                    content.append(Spacer(1, 12))\n                # Add a subheading for observations\n                content.append(Paragraph(_('Observations'), styles['ObservationTitle']))\n                content.append(Spacer(1, 6))\n                obs_list = obs_by_type[vital_type_value]\n                for i, obs in enumerate(obs_list):\n                    # Format the date range\n                    date_range = f\"{obs.start_date.strftime('%d/%m/%Y')} - {obs.end_date.strftime('%d/%m/%Y')}\"\n                    doctor_name = f\"Dr. {obs.doctor.first_name} {obs.doctor.last_name}\"\n                    # Use a box with soft background for each observation\n                    obs_table = Table([[Paragraph(f\"&lt;b&gt;{date_range}&lt;/b&gt; - {doctor_name}\", styles['Normal-Bold'])], \n                                       [Paragraph(obs.content, styles['Normal'])]], \n                                      colWidths=[5.5*inch])\n                    obs_table.setStyle(TableStyle([\n                        ('BACKGROUND', (0, 0), (-1, 0), colors.lavender),\n                        ('BACKGROUND', (0, 1), (-1, 1), colors.white),\n                        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),\n                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),\n                        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n                        ('FONTSIZE', (0, 0), (-1, -1), 10),\n                        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),\n                        ('TOPPADDING', (0, 0), (-1, -1), 8),\n                        ('LEFTPADDING', (0, 0), (-1, -1), 12),\n                        ('RIGHTPADDING', (0, 0), (-1, -1), 12),\n                        ('BOX', (0, 0), (-1, -1), 0.5, colors.grey),\n                        ('GRID', (0, 0), (-1, -1), 0.5, colors.lightgrey)\n                    ]))\n                    content.append(obs_table)\n                    # Add a divider between observations except for the last one\n                    if i &lt; len(obs_list) - 1:\n                        content.append(Spacer(1, 8))\n                content.append(Spacer(1, 12))\n            # Add spacing between different vital types\n            content.append(Spacer(1, 24))\n    # Footer with page numbers\n    def add_page_number(canvas, doc):\n        \"\"\"\n        Add page numbers and footer to each page of the PDF report.\n        This function is called by ReportLab's document build process for each page\n        during PDF generation. It adds a thin grey line above the footer area,\n        page numbers in the format 'Page X / Y' in the bottom right corner,\n        and a timestamp with the application name in the bottom left corner.\n        Args:\n            canvas (Canvas): ReportLab canvas object for drawing on the PDF page\n            doc (SimpleDocTemplate): The PDF document being built, containing page information\n                                    such as current page number and page size\n        Returns:\n            None: The function modifies the canvas in-place\n        \"\"\"\n        canvas.saveState()\n        canvas.setFont('Helvetica', 8)\n        canvas.setFillColor(colors.grey)\n        # Draw a thin line above the footer\n        page_width = doc.pagesize[0]\n        canvas.line(54, 40, page_width-54, 40)\n        # Add page number\n        page_num = f\"{_('Page')} {doc.page} / {doc.page}\"\n        canvas.drawRightString(page_width-54, 25, page_num)\n        # Add timestamp\n        timestamp = f\"VitaLink - {datetime.now().strftime('%d/%m/%Y')}\"\n        canvas.drawString(54, 25, timestamp)\n        canvas.restoreState()\n    # Build PDF with page numbers\n    doc.build(content, onFirstPage=add_page_number, onLaterPages=add_page_number)\n    buffer.seek(0)\n    return buffer\n</code></pre>"},{"location":"modules/utils.html","title":"Utils","text":"<p>Utility Module. This module provides common utility functions used throughout the VitaLink application. It includes helpers for: 1. Data validation (email, UUID, password strength) 2. Date parsing and formatting 3. Data serialization for API responses and JSON conversion 4. Common string manipulation utilities These functions are designed to be reusable across the application and provide consistent behavior for frequently needed operations.</p>"},{"location":"modules/utils.html#app.utils.validate_email","title":"<code>validate_email(email)</code>","text":"<p>Validate if a string is a correctly formatted email address. This function uses a regular expression pattern to check if the provided  string conforms to standard email format requirements. Args:     email (str): The email address string to validate Returns:     bool: True if the email is valid, False otherwise Example:     &gt;&gt;&gt; validate_email(\"doctor@example.com\")     True     &gt;&gt;&gt; validate_email(\"invalid-email\")     False     &gt;&gt;&gt; validate_email(None)     False</p> Source code in <code>app/utils.py</code> <pre><code>def validate_email(email):\n    \"\"\"\n    Validate if a string is a correctly formatted email address.\n    This function uses a regular expression pattern to check if the provided \n    string conforms to standard email format requirements.\n    Args:\n        email (str): The email address string to validate\n    Returns:\n        bool: True if the email is valid, False otherwise\n    Example:\n        &gt;&gt;&gt; validate_email(\"doctor@example.com\")\n        True\n        &gt;&gt;&gt; validate_email(\"invalid-email\")\n        False\n        &gt;&gt;&gt; validate_email(None)\n        False\n    \"\"\"\n    if email is None:\n        return False\n    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(email_pattern, email) is not None\n</code></pre>"},{"location":"modules/utils.html#app.utils.is_valid_password","title":"<code>is_valid_password(password)</code>","text":"<p>Validate password strength against security requirements. This function checks if a password meets the minimum security requirements: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one digit - At least one special character Args:     password (str): The password string to validate Returns:     tuple: A tuple containing:         - bool: True if password meets all requirements, False otherwise         - str: A message describing the validation result or the specific requirement not met Example:     &gt;&gt;&gt; is_valid_password(\"Abc123!\")     (True, \"The password is strong\")     &gt;&gt;&gt; is_valid_password(\"password\")     (False, \"The password must contain at least one uppercase letter\")     &gt;&gt;&gt; is_valid_password(None)     (False, \"The password must be at least 8 characters long\")</p> Source code in <code>app/utils.py</code> <pre><code>def is_valid_password(password):\n    \"\"\"\n    Validate password strength against security requirements.\n    This function checks if a password meets the minimum security requirements:\n    - At least 8 characters long\n    - At least one uppercase letter\n    - At least one lowercase letter\n    - At least one digit\n    - At least one special character\n    Args:\n        password (str): The password string to validate\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if password meets all requirements, False otherwise\n            - str: A message describing the validation result or the specific requirement not met\n    Example:\n        &gt;&gt;&gt; is_valid_password(\"Abc123!\")\n        (True, \"The password is strong\")\n        &gt;&gt;&gt; is_valid_password(\"password\")\n        (False, \"The password must contain at least one uppercase letter\")\n        &gt;&gt;&gt; is_valid_password(None)\n        (False, \"The password must be at least 8 characters long\")\n    \"\"\"\n    if password is None:\n        return False, _(\"The password must be at least 8 characters long\")\n    if len(password) &lt; 8:\n        return False, _(\"The password must be at least 8 characters long\")\n    if not re.search(r'[A-Z]', password):\n        return False, _(\"The password must contain at least one uppercase letter\")\n    if not re.search(r'[a-z]', password):\n        return False, _(\"The password must contain at least one lowercase letter\")\n    if not re.search(r'[0-9]', password):\n        return False, _(\"The password must contain at least one digit\")\n    if not re.search(r'[!@#$%^&amp;*(),.?\":{}|&lt;&gt;]', password):\n        return False, _(\"The password must contain at least one special character\")\n    return True, _(\"The password is strong\")\n</code></pre>"},{"location":"modules/utils.html#app.utils.validate_uuid","title":"<code>validate_uuid(uuid_string)</code>","text":"<p>Validate if a string is a correctly formatted UUID. This function attempts to parse the provided string as a UUID and then compares the resulting string representation to ensure it matches the original input. This approach catches malformed UUIDs as well as strings that might parse but don't strictly follow UUID format. Args:     uuid_string (str): The UUID string to validate Returns:     bool: True if the string is a valid UUID, False otherwise Example:     &gt;&gt;&gt; validate_uuid(\"123e4567-e89b-12d3-a456-426614174000\")     True     &gt;&gt;&gt; validate_uuid(\"invalid-uuid\")     False     &gt;&gt;&gt; validate_uuid(None)     False</p> Source code in <code>app/utils.py</code> <pre><code>def validate_uuid(uuid_string):\n    \"\"\"\n    Validate if a string is a correctly formatted UUID.\n    This function attempts to parse the provided string as a UUID and then\n    compares the resulting string representation to ensure it matches the\n    original input. This approach catches malformed UUIDs as well as\n    strings that might parse but don't strictly follow UUID format.\n    Args:\n        uuid_string (str): The UUID string to validate\n    Returns:\n        bool: True if the string is a valid UUID, False otherwise\n    Example:\n        &gt;&gt;&gt; validate_uuid(\"123e4567-e89b-12d3-a456-426614174000\")\n        True\n        &gt;&gt;&gt; validate_uuid(\"invalid-uuid\")\n        False\n        &gt;&gt;&gt; validate_uuid(None)\n        False\n    \"\"\"\n    if uuid_string is None:\n        return False\n    try:\n        uuid_obj = uuid.UUID(uuid_string)\n        return str(uuid_obj) == uuid_string\n    except (ValueError, AttributeError, TypeError):\n        return False\n</code></pre>"},{"location":"modules/utils.html#app.utils.parse_date","title":"<code>parse_date(date_string)</code>","text":"<p>Parse a date string in YYYY-MM-DD format to a date object. This function converts a string representation of a date in YYYY-MM-DD format to a Python date object. If the string cannot be parsed in the expected format, it raises a ValueError with a user-friendly message. Args:     date_string (str): The date string in YYYY-MM-DD format Returns:     date: A Python date object representing the parsed date Raises:     ValueError: If the date string is not in the expected format or is None Example:     &gt;&gt;&gt; parse_date(\"2023-05-15\")     datetime.date(2023, 5, 15)     &gt;&gt;&gt; parse_date(\"15/05/2023\")     ValueError: Invalid date format. Please use YYYY-MM-DD     &gt;&gt;&gt; parse_date(None)     ValueError: Invalid date format. Please use YYYY-MM-DD</p> Source code in <code>app/utils.py</code> <pre><code>def parse_date(date_string):\n    \"\"\"\n    Parse a date string in YYYY-MM-DD format to a date object.\n    This function converts a string representation of a date in YYYY-MM-DD\n    format to a Python date object. If the string cannot be parsed in the\n    expected format, it raises a ValueError with a user-friendly message.\n    Args:\n        date_string (str): The date string in YYYY-MM-DD format\n    Returns:\n        date: A Python date object representing the parsed date\n    Raises:\n        ValueError: If the date string is not in the expected format or is None\n    Example:\n        &gt;&gt;&gt; parse_date(\"2023-05-15\")\n        datetime.date(2023, 5, 15)\n        &gt;&gt;&gt; parse_date(\"15/05/2023\")\n        ValueError: Invalid date format. Please use YYYY-MM-DD\n        &gt;&gt;&gt; parse_date(None)\n        ValueError: Invalid date format. Please use YYYY-MM-DD\n    \"\"\"\n    if date_string is None:\n        raise ValueError(_(\"Invalid date format. Please use YYYY-MM-DD\"))\n    try:\n        return datetime.strptime(date_string, '%Y-%m-%d').date()\n    except ValueError:\n        raise ValueError(_(\"Invalid date format. Please use YYYY-MM-DD\"))\n</code></pre>"},{"location":"modules/utils.html#app.utils.to_serializable_dict","title":"<code>to_serializable_dict(obj)</code>","text":"<p>Convert an object to a JSON serializable dictionary. This utility function recursively transforms complex objects into simple data types that can be safely serialized to JSON. It handles: - Dictionaries (recursively converts each value) - Lists (recursively converts each element) - Datetime objects (converts to ISO format strings) - Date objects (converts to ISO format strings YYYY-MM-DD) - Objects with to_dict() method (calls that method) - Other types are returned as-is Args:     obj: The object to convert to a serializable form Returns:     A JSON-serializable representation of the input object Example:     &gt;&gt;&gt; to_serializable_dict({'date': datetime(2023, 1, 1), 'values': [1, 2, 3]})     {'date': '2023-01-01T00:00:00', 'values': [1, 2, 3]}     &gt;&gt;&gt; to_serializable_dict(patient_obj)  # where patient_obj has a to_dict method     {'id': 1, 'name': 'John Smith', ...}</p> Source code in <code>app/utils.py</code> <pre><code>def to_serializable_dict(obj):\n    \"\"\"\n    Convert an object to a JSON serializable dictionary.\n    This utility function recursively transforms complex objects into simple\n    data types that can be safely serialized to JSON. It handles:\n    - Dictionaries (recursively converts each value)\n    - Lists (recursively converts each element)\n    - Datetime objects (converts to ISO format strings)\n    - Date objects (converts to ISO format strings YYYY-MM-DD)\n    - Objects with to_dict() method (calls that method)\n    - Other types are returned as-is\n    Args:\n        obj: The object to convert to a serializable form\n    Returns:\n        A JSON-serializable representation of the input object\n    Example:\n        &gt;&gt;&gt; to_serializable_dict({'date': datetime(2023, 1, 1), 'values': [1, 2, 3]})\n        {'date': '2023-01-01T00:00:00', 'values': [1, 2, 3]}\n        &gt;&gt;&gt; to_serializable_dict(patient_obj)  # where patient_obj has a to_dict method\n        {'id': 1, 'name': 'John Smith', ...}\n    \"\"\"\n    if isinstance(obj, dict):\n        return {k: to_serializable_dict(v) for k, v in obj.items()}\n    elif isinstance(obj, list):\n        return [to_serializable_dict(i) for i in obj]    \n    elif isinstance(obj, datetime):\n        return obj.isoformat()\n    elif isinstance(obj, date):\n        return obj.isoformat()\n    elif hasattr(obj, 'to_dict'):\n        return obj.to_dict()\n    else:\n        return obj\n</code></pre>"},{"location":"modules/views.html","title":"Views","text":"<p>Views Module. This module provides the main web interface routes for the VitaLink application. It includes routes for: 1. Dashboard and landing pages 2. Patient management (creation, viewing, editing, deletion) 3. Patient vital signs visualization 4. Medical notes management 5. Reports generation and export 6. Audit log viewing All routes in this module use templates for rendering HTML responses and integrate with the Flask-Login system for authentication.</p>"},{"location":"modules/views.html#app.views.views_bp","title":"<code>views_bp = Blueprint('views', __name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/views.html#app.views.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"modules/views.html#app.views.index","title":"<code>index()</code>","text":"<p>Landing page route. This route serves as the entry point to the application. Authenticated users are redirected to the dashboard. Unauthenticated users are redirected to the login page. Returns:     Response: Redirect to appropriate page based on authentication status</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/')\ndef index():\n    \"\"\"\n    Landing page route.\n    This route serves as the entry point to the application.\n    Authenticated users are redirected to the dashboard.\n    Unauthenticated users are redirected to the login page.\n    Returns:\n        Response: Redirect to appropriate page based on authentication status\n    \"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('views.dashboard'))\n    return redirect(url_for('auth.login'))\n</code></pre>"},{"location":"modules/views.html#app.views.dashboard","title":"<code>dashboard()</code>","text":"<p>Doctor dashboard route. Displays an overview of the doctor's patients, recent activities, and system statistics. This is the main landing page after authentication. Returns:     Response: Rendered dashboard template with context data</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/dashboard')\n@login_required\ndef dashboard():\n    \"\"\"\n    Doctor dashboard route.\n    Displays an overview of the doctor's patients, recent activities, and\n    system statistics. This is the main landing page after authentication.\n    Returns:\n        Response: Rendered dashboard template with context data\n    \"\"\"\n    # Get counts for dashboard\n    patient_count = current_user.patients.count()\n    # Get recent patients\n    recent_patients = current_user.patients.order_by(Patient.created_at.desc()).limit(5).all()\n    # Get recent audit logs\n    from .models import AuditLog\n    recent_audits = AuditLog.query.filter_by(doctor_id=current_user.id).order_by(\n        AuditLog.timestamp.desc()\n    ).limit(10).all()\n    # Get recent observations\n    recent_observations = VitalObservation.query.join(\n        DoctorPatient, VitalObservation.patient_id == DoctorPatient.patient_id\n    ).filter(\n        DoctorPatient.doctor_id == current_user.id\n    ).order_by(\n        VitalObservation.created_at.desc()\n    ).limit(10).all()\n    return render_template('dashboard.html', \n                          patient_count=patient_count,\n                          recent_patients=recent_patients,\n                          recent_observations=recent_observations,\n                          recent_audits=recent_audits,\n                          now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.patients","title":"<code>patients()</code>","text":"<p>Display list of all patients for the current doctor. This route retrieves and displays all patients associated with the  authenticated doctor. It provides an overview of the doctor's patient list and serves as the main patient management interface. The page includes functionality for: - Viewing patient details - Adding new patients - Importing existing patients by UUID - Searching and filtering patients Returns:     Response: Rendered template with list of all patients               associated with the current doctor</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients')\n@login_required\ndef patients():\n    \"\"\"\n    Display list of all patients for the current doctor.\n    This route retrieves and displays all patients associated with the \n    authenticated doctor. It provides an overview of the doctor's patient list\n    and serves as the main patient management interface.\n    The page includes functionality for:\n    - Viewing patient details\n    - Adding new patients\n    - Importing existing patients by UUID\n    - Searching and filtering patients\n    Returns:\n        Response: Rendered template with list of all patients \n                 associated with the current doctor\n    \"\"\"\n    # Get all patients for the current doctor\n    all_patients = current_user.patients.all()\n    return render_template('patients.html', patients=all_patients, now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.import_patient","title":"<code>import_patient()</code>","text":"<p>Import an existing patient into doctor's patient list by UUID. This endpoint allows doctors to associate themselves with existing patients in the system by providing the patient's UUID. This is useful when multiple doctors need to collaborate on patient care. Request Body JSON:     patient_uuid (str): UUID of the patient to import Returns:     JSON response with success message or error details Status Codes:     200: Patient imported successfully     400: Invalid request data or UUID format     404: Patient not found     409: Patient already associated with the doctor     500: Database or server error</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/import', methods=['POST'])\n@login_required\ndef import_patient():\n    \"\"\"\n    Import an existing patient into doctor's patient list by UUID.\n    This endpoint allows doctors to associate themselves with existing patients\n    in the system by providing the patient's UUID. This is useful when multiple\n    doctors need to collaborate on patient care.\n    Request Body JSON:\n        patient_uuid (str): UUID of the patient to import\n    Returns:\n        JSON response with success message or error details\n    Status Codes:\n        200: Patient imported successfully\n        400: Invalid request data or UUID format\n        404: Patient not found\n        409: Patient already associated with the doctor\n        500: Database or server error\n    \"\"\"\n    data = request.json\n    # Validate request data\n    if not data or 'patient_uuid' not in data:\n        return jsonify({\"error\": _(\"Patient UUID is required\")}), 400\n    patient_uuid = data['patient_uuid']\n    # Validate UUID format\n    if not validate_uuid(patient_uuid):\n        return jsonify({\"error\": _(\"Invalid UUID format\")}), 400\n    # Find the patient\n    patient = Patient.query.filter_by(uuid=patient_uuid).first()\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is already associated with this patient\n    if patient in current_user.patients.all():\n        return jsonify({\"error\": _(\"Patient is already associated with your account\")}), 409\n    try:\n        # Add patient to doctor's patients\n        doctor_patient = DoctorPatient(doctor_id=current_user.id, patient_id=patient.id)\n        db.session.add(doctor_patient)\n        db.session.commit()\n        # Log the import action\n        log_patient_import(current_user.id, patient)\n        return jsonify({\n            \"message\": _(\"Patient imported successfully\"),\n            \"patient\": patient.to_dict()\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Database error importing patient: {str(e)}\")\n        return jsonify({\"error\": _(\"A database error occurred while importing the patient\")}), 500\n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Error importing patient: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while importing the patient\")}), 500\n</code></pre>"},{"location":"modules/views.html#app.views.new_patient","title":"<code>new_patient()</code>","text":"<p>Create a new patient record. This route handles both displaying the new patient form (GET) and processing the form submission (POST). For GET requests:     Displays the form to enter patient information For POST requests:     Validates and processes form data     Creates a new patient record     Associates the patient with the current doctor     Logs the patient creation in the audit trail Returns:     GET: Rendered form template     POST (success): Redirect to patient's detail page     POST (failure): Redirect back to form with error message</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/new', methods=['GET', 'POST'])\n@login_required\ndef new_patient():\n    \"\"\"\n    Create a new patient record.\n    This route handles both displaying the new patient form (GET)\n    and processing the form submission (POST).\n    For GET requests:\n        Displays the form to enter patient information\n    For POST requests:\n        Validates and processes form data\n        Creates a new patient record\n        Associates the patient with the current doctor\n        Logs the patient creation in the audit trail\n    Returns:\n        GET: Rendered form template\n        POST (success): Redirect to patient's detail page\n        POST (failure): Redirect back to form with error message\n    \"\"\"\n    if request.method == 'POST':\n        first_name = request.form.get('first_name')\n        last_name = request.form.get('last_name')\n        date_of_birth = request.form.get('date_of_birth')\n        gender = request.form.get('gender')\n        contact_number = request.form.get('contact_number')\n        email = request.form.get('email')\n        address = request.form.get('address')\n        # Validate required fields\n        if not first_name or not last_name or not date_of_birth:\n            flash(_('Name, surname and date of birth are mandatory fields'), 'danger')\n            return redirect(url_for('views.new_patient'))\n        try:\n            # Parse date\n            dob = parse_date(date_of_birth)\n            # Create new patient\n            patient = Patient(\n                first_name=first_name,\n                last_name=last_name,\n                date_of_birth=dob,\n                gender=gender,\n                contact_number=contact_number,\n                email=email,\n                address=address\n            )\n            db.session.add(patient)\n            db.session.flush()  # Flush to get the patient ID\n            # Associate the patient with the current doctor\n            association = DoctorPatient(doctor_id=current_user.id, patient_id=patient.id)\n            db.session.add(association)\n            db.session.commit()\n            # Log the patient creation in the audit trail\n            log_patient_creation(current_user.id, patient)\n            flash(_('Patient %(first_name)s %(last_name)s successfully created with ID %(uuid)s') % {\n                'first_name': first_name,\n                'last_name': last_name,\n                'uuid': patient.uuid\n            }, 'success')\n            logger.info(f\"Doctor {current_user.id} created patient {patient.id}\")\n            return redirect(url_for('views.patient_detail', patient_id=patient.id))\n        except ValueError:\n            flash(_('Invalid date format. Use YYYY-MM-DD'), 'danger')\n        except SQLAlchemyError as e:\n            db.session.rollback()\n            logger.error(f\"Error creating patient: {str(e)}\")\n            flash(_('An error occurred while creating the patient'), 'danger')\n    return render_template('patients.html', mode='new', now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.patient_detail","title":"<code>patient_detail(patient_id)</code>","text":"<p>Display detailed information about a specific patient. This route shows comprehensive information about a patient, including personal details and medical notes. It also logs the view action in the audit trail for tracking purposes. Args:     patient_id (int): ID of the patient to display Returns:     Response: Rendered patient detail template or redirect              if unauthorized Security:     Verifies that the current doctor is associated with the patient     before displaying any information</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;')\n@login_required\ndef patient_detail(patient_id):\n    \"\"\"\n    Display detailed information about a specific patient.\n    This route shows comprehensive information about a patient,\n    including personal details and medical notes. It also logs\n    the view action in the audit trail for tracking purposes.\n    Args:\n        patient_id (int): ID of the patient to display\n    Returns:\n        Response: Rendered patient detail template or redirect\n                 if unauthorized\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before displaying any information\n    \"\"\"\n    # Get the patient\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not authorized to view this patient.'), 'danger')\n        return redirect(url_for('views.patients'))\n    # Get notes\n    notes = patient.notes.order_by(Note.created_at.desc()).all()\n    # Log patient view in the audit trail\n    log_patient_view(current_user.id, patient.id)\n    return render_template('patient_detail.html', \n                          patient=patient,\n                          notes=notes,\n                          now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.edit_patient","title":"<code>edit_patient(patient_id)</code>","text":"<p>Edit an existing patient's information. This route handles both displaying the patient edit form (GET) and processing form submissions to update patient data (POST). Changes are logged in the audit trail for accountability. Args:     patient_id (int): ID of the patient to edit Request Form Data (POST):     first_name (str): Patient's updated first name     last_name (str): Patient's updated last name     date_of_birth (str): Updated date of birth in YYYY-MM-DD format     gender (str): Updated gender     contact_number (str): Updated contact number     email (str): Updated email address     address (str): Updated address Returns:     GET: Rendered form template with patient data     POST (success): Redirect to patient's detail page     POST (failure): Redirect back to form with error message Security:     Verifies that the current doctor is associated with the patient     before allowing any modifications</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;/edit', methods=['GET', 'POST'])\n@login_required\ndef edit_patient(patient_id):\n    \"\"\"\n    Edit an existing patient's information.\n    This route handles both displaying the patient edit form (GET)\n    and processing form submissions to update patient data (POST).\n    Changes are logged in the audit trail for accountability.\n    Args:\n        patient_id (int): ID of the patient to edit\n    Request Form Data (POST):\n        first_name (str): Patient's updated first name\n        last_name (str): Patient's updated last name\n        date_of_birth (str): Updated date of birth in YYYY-MM-DD format\n        gender (str): Updated gender\n        contact_number (str): Updated contact number\n        email (str): Updated email address\n        address (str): Updated address\n    Returns:\n        GET: Rendered form template with patient data\n        POST (success): Redirect to patient's detail page\n        POST (failure): Redirect back to form with error message\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before allowing any modifications\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not authorized to modify this patient.'), 'danger')\n        return redirect(url_for('views.patients'))\n    if request.method == 'POST':\n        first_name = request.form.get('first_name')\n        last_name = request.form.get('last_name')\n        date_of_birth = request.form.get('date_of_birth')\n        gender = request.form.get('gender')\n        contact_number = request.form.get('contact_number')\n        email = request.form.get('email')\n        address = request.form.get('address')\n        # Validate required fields\n        if not first_name or not last_name or not date_of_birth:\n            flash(_('First name, second name and date of birth are mandatory fields'), 'danger')\n            return redirect(url_for('views.edit_patient', patient_id=patient_id))\n        try:\n            # Parse date\n            dob = parse_date(date_of_birth)\n            # Save original data for audit log\n            old_data = patient.to_dict()\n            # Update patient information\n            patient.first_name = first_name\n            patient.last_name = last_name\n            patient.date_of_birth = dob\n            patient.gender = gender\n            patient.contact_number = contact_number\n            patient.email = email\n            patient.address = address\n            patient.updated_at = datetime.utcnow()\n            db.session.commit()\n            # Log the patient update in the audit trail\n            log_patient_update(current_user.id, patient, old_data)\n            flash(_('Patient information updated successfully'), 'success')\n            logger.info(f\"Doctor {current_user.id} updated patient {patient.id}\")\n            return redirect(url_for('views.patient_detail', patient_id=patient_id))\n        except ValueError:\n            flash(_('Invalid date format. Use YYYY-MM-DD'), 'danger')\n        except SQLAlchemyError as e:\n            db.session.rollback()\n            logger.error(f\"Error updating patient: {str(e)}\")\n            flash(_('An error occurred while updating the patient'), 'danger')\n    return render_template('patients.html', mode='edit', patient=patient, now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.delete_patient","title":"<code>delete_patient(patient_id)</code>","text":"<p>Delete or disassociate a patient from the current doctor. This endpoint handles two scenarios: 1. If the patient is associated with other doctors, only the association    between the current doctor and patient is removed 2. If this is the last doctor associated with the patient, all patient data    (including notes) is completely removed from the system Args:     patient_id (int): ID of the patient to delete or disassociate Returns:     Response: Redirect to patients list with success or error message Security:     Verifies that the current doctor is associated with the patient     before allowing deletion or disassociation Notes:     This operation logs either a patient deletion or disassociation     in the audit trail for accountability</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;/delete', methods=['POST'])\n@login_required\ndef delete_patient(patient_id):\n    \"\"\"\n    Delete or disassociate a patient from the current doctor.\n    This endpoint handles two scenarios:\n    1. If the patient is associated with other doctors, only the association\n       between the current doctor and patient is removed\n    2. If this is the last doctor associated with the patient, all patient data\n       (including notes) is completely removed from the system\n    Args:\n        patient_id (int): ID of the patient to delete or disassociate\n    Returns:\n        Response: Redirect to patients list with success or error message\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before allowing deletion or disassociation\n    Notes:\n        This operation logs either a patient deletion or disassociation\n        in the audit trail for accountability\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not authorized to delete this patient.'), 'danger')\n        return redirect(url_for('views.patients'))\n    try:\n        # Store patient data for audit log before deletion\n        patient_data = patient.to_dict()\n        # Remove the association between doctor and patient\n        current_user.remove_patient(patient)\n        # If the patient has no other doctors, delete the patient (optional)\n        if patient.doctors.count() == 0:\n            # Delete all notes for the patient\n            for note in patient.notes.all():\n                db.session.delete(note)\n            # Log complete patient deletion in the audit trail before actually deleting\n            log_patient_delete(current_user.id, patient)\n            # Now delete the patient\n            db.session.delete(patient)\n        else:\n            # Log patient disassociation in the audit trail\n            log_action(\n                doctor_id=current_user.id,\n                action_type=ActionType.UPDATE,\n                entity_type=EntityType.PATIENT,\n                entity_id=patient.id,\n                details={\n                    'action': 'disassociate',\n                    'patient_data': patient_data\n                },\n                patient_id=patient.id\n            )\n        db.session.commit()\n        flash(_('Patient successfully removed'), 'success')\n        logger.info(f\"Doctor {current_user.id} removed patient {patient_id}\")\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error deleting patient: {str(e)}\")\n        flash(_('An error occurred while removing the patient'), 'danger')\n    return redirect(url_for('views.patients'))\n</code></pre>"},{"location":"modules/views.html#app.views.patient_vitals","title":"<code>patient_vitals(patient_id)</code>","text":"<p>Display vital signs data and observations for a patient. This route renders the vital signs visualization page for a specific patient. It displays charts, observations, and provides options for filtering and analyzing the patient's health data. Args:     patient_id (int): ID of the patient to display vital signs for Query Parameters:     period (int, optional): Time period in days for filtering data,                             defaults to 7 if not specified Returns:     Response: Rendered vitals template with patient data and observations              or redirect if unauthorized Security:     Verifies that the current doctor is associated with the patient     before displaying any information</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;/vitals', methods=['GET'])\n@login_required\ndef patient_vitals(patient_id):\n    \"\"\"\n    Display vital signs data and observations for a patient.\n    This route renders the vital signs visualization page for a specific patient.\n    It displays charts, observations, and provides options for filtering\n    and analyzing the patient's health data.\n    Args:\n        patient_id (int): ID of the patient to display vital signs for\n    Query Parameters:\n        period (int, optional): Time period in days for filtering data, \n                               defaults to 7 if not specified\n    Returns:\n        Response: Rendered vitals template with patient data and observations\n                 or redirect if unauthorized\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before displaying any information\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not authorized to view this patient'), 'danger')\n        return redirect(url_for('views.patients'))\n      # Get observations\n    observations = VitalObservation.query.filter_by(patient_id=patient_id).order_by(VitalObservation.created_at.desc()).all()\n    # Get current period from query parameters or default to 7\n    current_period = request.args.get('period', 7, type=int)\n    return render_template('vitals.html', \n                          patient=patient,\n                          observations=observations,\n                          vital_types=[type.value for type in VitalSignType],\n                          currentPeriod=current_period,\n                          now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.api_patient_vitals","title":"<code>api_patient_vitals(patient_id)</code>","text":"<p>API endpoint to retrieve patient vital sign data from health platforms. This endpoint fetches data from external health platforms (like Fitbit) that are connected to the patient's account. It returns the data in JSON format for use in charts, reports, and analysis. Args:     patient_id (int): ID of the patient to get vital signs for Query Parameters:     start_date (str, optional): ISO formatted start date to filter data     end_date (str, optional): ISO formatted end date to filter data     type (str): Type of vital sign to retrieve (heart_rate, steps, etc.) Returns:     JSON: Vital sign data organized by type or error message Status Codes:     200: Data retrieved successfully (even if empty)     403: Doctor not authorized to access this patient     404: Patient has no health platform connection     500: Error retrieving data from health platform Security:     Verifies that the current doctor is associated with the patient     Validates that the patient has a connected health platform</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/api/patients/&lt;int:patient_id&gt;/vitals')\n@login_required\ndef api_patient_vitals(patient_id):\n    \"\"\"\n    API endpoint to retrieve patient vital sign data from health platforms.\n    This endpoint fetches data from external health platforms (like Fitbit)\n    that are connected to the patient's account. It returns the data in JSON\n    format for use in charts, reports, and analysis.\n    Args:\n        patient_id (int): ID of the patient to get vital signs for\n    Query Parameters:\n        start_date (str, optional): ISO formatted start date to filter data\n        end_date (str, optional): ISO formatted end date to filter data\n        type (str): Type of vital sign to retrieve (heart_rate, steps, etc.)\n    Returns:\n        JSON: Vital sign data organized by type or error message\n    Status Codes:\n        200: Data retrieved successfully (even if empty)\n        403: Doctor not authorized to access this patient\n        404: Patient has no health platform connection\n        500: Error retrieving data from health platform\n    Security:\n        Verifies that the current doctor is associated with the patient\n        Validates that the patient has a connected health platform\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        return jsonify({'error': _('Not authorized')}), 403\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    vital_type = request.args.get('type')\n    # Check if patient has health platform connection\n    if not patient.platform_access_token:\n        return jsonify({'error': _('No health platform connection'), 'vital_type': vital_type}), 404\n    # Import health platform functionality\n    from .health_platforms import get_processed_fitbit_data\n    # Get data from Fitbit\n    try:\n        data = get_processed_fitbit_data(\n            patient,\n            vital_type,\n            start_date=start_date,\n            end_date=end_date\n        )\n        if not data:\n            return jsonify({vital_type: []}), 200\n        # Organize data by vital type\n        return jsonify({vital_type: data}), 200\n    except Exception as e:\n        logger.error(f\"Error getting data from health platform: {str(e)}\")\n        return jsonify({'error': _('Failed to retrieve health platform data'), 'message': str(e)}), 500\n</code></pre>"},{"location":"modules/views.html#app.views.add_note","title":"<code>add_note(patient_id)</code>","text":"<p>Add a new medical note for a specific patient. This route handles the creation of a new medical note associated with a patient. The note is created by the authenticated doctor and includes a timestamp. The action is logged in the audit trail for accountability. Args:     patient_id (int): ID of the patient to add a note for Request Form Data:     content (str): The text content of the medical note Returns:     Response: Redirect to patient detail page with success or error message Security:     Verifies that the current doctor is associated with the patient     before allowing note creation</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;/notes', methods=['POST'])\n@login_required\ndef add_note(patient_id):\n    \"\"\"\n    Add a new medical note for a specific patient.\n    This route handles the creation of a new medical note associated with a patient.\n    The note is created by the authenticated doctor and includes a timestamp.\n    The action is logged in the audit trail for accountability.\n    Args:\n        patient_id (int): ID of the patient to add a note for\n    Request Form Data:\n        content (str): The text content of the medical note\n    Returns:\n        Response: Redirect to patient detail page with success or error message\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before allowing note creation\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not allowed to add notes for this patient'), 'danger')\n        return redirect(url_for('views.patients'))\n    content = request.form.get('content')\n    if not content:\n        flash(_('Note content cannot be empty'), 'danger')\n        return redirect(url_for('views.patient_detail', patient_id=patient_id))\n    try:\n        note = Note(\n            patient_id=patient_id,\n            doctor_id=current_user.id,\n            content=content\n        )\n        db.session.add(note)\n        db.session.commit()\n        # Log the note creation in the audit trail\n        log_note_creation(current_user.id, note)\n        flash(_('Note added successfully'), 'success')\n        logger.info(f\"Doctor {current_user.id} added note for patient {patient_id}\")\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error adding note: {str(e)}\")\n        flash(_('An error occurred while adding the note'), 'danger')\n    return redirect(url_for('views.patient_detail', patient_id=patient_id))\n</code></pre>"},{"location":"modules/views.html#app.views.delete_note","title":"<code>delete_note(note_id)</code>","text":"<p>Delete a specific medical note. This API endpoint handles the deletion of medical notes. It implements several security checks to ensure that only authorized doctors can delete notes: 1. The doctor must be associated with the patient 2. The doctor must be the original author of the note The deletion is logged in the audit trail for accountability. Args:     note_id (int): ID of the note to delete Returns:     JSON: Success message and deleted note data or error message Status Codes:     200: Note deleted successfully     403: Not authorized to delete this note     404: Note or patient not found     500: Database error occurred</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/notes/&lt;int:note_id&gt;', methods=['DELETE'])\n@login_required\ndef delete_note(note_id):\n    \"\"\"\n    Delete a specific medical note.\n    This API endpoint handles the deletion of medical notes. It implements several\n    security checks to ensure that only authorized doctors can delete notes:\n    1. The doctor must be associated with the patient\n    2. The doctor must be the original author of the note\n    The deletion is logged in the audit trail for accountability.\n    Args:\n        note_id (int): ID of the note to delete\n    Returns:\n        JSON: Success message and deleted note data or error message\n    Status Codes:\n        200: Note deleted successfully\n        403: Not authorized to delete this note\n        404: Note or patient not found\n        500: Database error occurred\n    \"\"\"\n    # Find the note\n    note = Note.query.get_or_404(note_id)\n    # Find the patient\n    patient = Patient.query.get(note.patient_id)\n    if not patient:\n        return jsonify({\"error\": _(\"Patient not found\")}), 404\n    # Check if the doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        return jsonify({\"error\": _(\"You are not authorized to access this patient\")}), 403\n    # Check if the doctor is the author of the note\n    if note.doctor_id != current_user.id:\n        return jsonify({\"error\": _(\"You can only delete notes you have created\")}), 403\n    # Delete the note\n    try:\n        # Log the note deletion\n        from .audit import log_note_delete\n        log_note_delete(current_user.id, note)\n        # Store note details for response\n        note_dict = note.to_dict()\n        db.session.delete(note)\n        db.session.commit()\n        logger.info(f\"Note {note_id} deleted\")\n        return jsonify({\n            \"message\": _(\"Note deleted successfully\"),\n            \"note\": note_dict\n        }), 200\n    except SQLAlchemyError as e:\n        db.session.rollback()\n        logger.error(f\"Error deleting note: {str(e)}\")\n        return jsonify({\"error\": _(\"An error occurred while deleting the note\")}), 500\n</code></pre>"},{"location":"modules/views.html#app.views.profile","title":"<code>profile()</code>","text":"<p>Doctor profile management route. This route handles both displaying and updating the doctor's profile information: - For GET requests: Displays the doctor's current profile information and a form to update it - For POST requests: Processes form submissions to update the doctor's information The profile update functionality is divided into two parts: 1. Updating basic information (name, specialty) 2. Changing password (requires current password verification) Returns:     GET: Rendered profile template with doctor data     POST: Same template with success or error messages based on update result Security:     Uses login_required decorator to ensure only authenticated doctors can access     Verifies current password before allowing password changes</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/profile', methods=['GET', 'POST'])\n@login_required\ndef profile():\n    \"\"\"\n    Doctor profile management route.\n    This route handles both displaying and updating the doctor's profile information:\n    - For GET requests: Displays the doctor's current profile information and a form to update it\n    - For POST requests: Processes form submissions to update the doctor's information\n    The profile update functionality is divided into two parts:\n    1. Updating basic information (name, specialty)\n    2. Changing password (requires current password verification)\n    Returns:\n        GET: Rendered profile template with doctor data\n        POST: Same template with success or error messages based on update result\n    Security:\n        Uses login_required decorator to ensure only authenticated doctors can access\n        Verifies current password before allowing password changes\n    \"\"\"\n    if request.method == 'POST':\n        first_name = request.form.get('first_name')\n        last_name = request.form.get('last_name')\n        specialty = request.form.get('specialty')\n        current_password = request.form.get('current_password')\n        new_password = request.form.get('new_password')\n        confirm_password = request.form.get('confirm_password')\n        # Update basic information\n        if first_name and last_name:\n            current_user.first_name = first_name\n            current_user.last_name = last_name\n            current_user.specialty = specialty\n            current_user.updated_at = datetime.utcnow()\n            db.session.commit()\n            flash(_('Profile updated successfully'), 'success')\n        # Update password\n        if current_password and new_password and confirm_password:\n            if not current_user.check_password(current_password):\n                flash(_('The current password is incorrect'), 'danger')\n            elif new_password != confirm_password:\n                flash(_('New passwords do not match'), 'danger')\n            else:\n                current_user.set_password(new_password)\n                current_user.updated_at = datetime.utcnow()\n                db.session.commit()\n                flash(_('Password updated successfully'), 'success')\n    return render_template('profile.html', doctor=current_user, now=datetime.now())\n</code></pre>"},{"location":"modules/views.html#app.views.create_specific_patient_report","title":"<code>create_specific_patient_report(patient_id)</code>","text":"<p>Generate a customized medical report for a specific patient. This route provides a powerful reporting system that allows doctors to create comprehensive, tailored medical reports with selected: - Medical notes - Vital sign types - Data visualization charts with different time periods - Clinical observations - Custom summary text The generated report is provided as a downloadable PDF file, and the report generation action is logged in the audit trail. Args:     patient_id (int): ID of the patient to generate a report for Query Parameters (for GET):     vital_type (str, optional): Pre-select specific vital sign type     period (str, optional): Pre-select specific time period     select_all (bool, optional): Whether to pre-select all available options Request Form Data (for POST):     summary (str, optional): Doctor's summary text for the report     selected_notes (list): IDs of selected medical notes to include     selected_vital_types (list): Types of vital signs to include     charts_* (list): Time periods to include for each vital type's charts      selected_observations (list): IDs of observations to include Returns:     GET: Rendered report configuration form     POST: Downloadable PDF report or redirect with error message Security:     Verifies that the current doctor is associated with the patient     before allowing report generation</p> Source code in <code>app/views.py</code> <pre><code>@views_bp.route('/patients/&lt;int:patient_id&gt;/specific_report', methods=['GET', 'POST'])\n@login_required\ndef create_specific_patient_report(patient_id):\n    \"\"\"\n    Generate a customized medical report for a specific patient.\n    This route provides a powerful reporting system that allows doctors to create\n    comprehensive, tailored medical reports with selected:\n    - Medical notes\n    - Vital sign types\n    - Data visualization charts with different time periods\n    - Clinical observations\n    - Custom summary text\n    The generated report is provided as a downloadable PDF file, and the report\n    generation action is logged in the audit trail.\n    Args:\n        patient_id (int): ID of the patient to generate a report for\n    Query Parameters (for GET):\n        vital_type (str, optional): Pre-select specific vital sign type\n        period (str, optional): Pre-select specific time period\n        select_all (bool, optional): Whether to pre-select all available options\n    Request Form Data (for POST):\n        summary (str, optional): Doctor's summary text for the report\n        selected_notes (list): IDs of selected medical notes to include\n        selected_vital_types (list): Types of vital signs to include\n        charts_* (list): Time periods to include for each vital type's charts \n        selected_observations (list): IDs of observations to include\n    Returns:\n        GET: Rendered report configuration form\n        POST: Downloadable PDF report or redirect with error message\n    Security:\n        Verifies that the current doctor is associated with the patient\n        before allowing report generation\n    \"\"\"\n    patient = Patient.query.get_or_404(patient_id)\n    # Check if the current doctor is associated with this patient\n    if patient not in current_user.patients.all():\n        flash(_('You are not authorized to generate reports for this patient'), 'danger')\n        return redirect(url_for('views.patients'))\n    if request.method == 'POST':\n        try:\n            # Get summary\n            summary = request.form.get('summary')\n            # Parse selected notes\n            selected_note_ids = request.form.getlist('selected_notes')\n            selected_notes = []\n            if selected_note_ids:\n                selected_notes = Note.query.filter(Note.id.in_(selected_note_ids)).all()\n            # Parse selected vital types\n            selected_vital_types_values = request.form.getlist('selected_vital_types')\n            selected_vital_types = []\n            for value in selected_vital_types_values:\n                for enum_member in VitalSignType:\n                    if enum_member.value == value:\n                        selected_vital_types.append(enum_member)\n                        break\n            # Parse selected charts\n            selected_charts = {}\n            for vital_type in selected_vital_types_values:\n                charts_key = f\"charts_{vital_type}\"\n                selected_periods = request.form.getlist(charts_key)\n                # Convert period strings to days numbers\n                days_periods = []\n                for period in selected_periods:\n                    if period == '1d':\n                        days_periods.append(1)\n                    elif period == '7d':\n                        days_periods.append(7)\n                    elif period == '1m':\n                        days_periods.append(30)\n                    elif period == '3m':\n                        days_periods.append(90)\n                selected_charts[vital_type] = days_periods\n            # Parse selected observations\n            selected_observation_ids = request.form.getlist('selected_observations')\n            selected_observations = []\n            if selected_observation_ids:\n                selected_observations = VitalObservation.query.filter(VitalObservation.id.in_(selected_observation_ids)).all()\n            # Use the current session language if available\n            current_language = session.get('language', 'en')\n            logger.debug(f\"Generating specific report with language: {current_language}\")\n            # Generate the PDF report\n            from .reports import generate_specific_report\n            pdf_buffer = generate_specific_report(\n                patient, \n                current_user, \n                selected_notes, \n                selected_vital_types,\n                selected_charts,\n                selected_observations,\n                summary=summary,\n                language=current_language\n            )\n            # Generate a filename for the report\n            filename = f\"specific_report_{patient.last_name}_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf\"\n              # Log the report generation\n            log_report_generation(\n                current_user.id, \n                patient.id, \n                \"specific\", \n                {\n                    \"notes_count\": len(selected_notes),\n                    \"vital_types\": [vt.value for vt in selected_vital_types],\n                    \"charts_count\": sum(len(periods) for periods in selected_charts.values()),\n                    \"observations_count\": len(selected_observations),\n                    \"has_summary\": summary is not None\n                }\n            )\n            logger.info(f\"Doctor {current_user.id} generated specific report for patient {patient_id}\")\n            # Check if the report should be sent via email\n            send_via_email = request.form.get('send_via_email') == '1'\n            if send_via_email and patient.email:\n                # Import email utilities\n                from .email_utils import send_report_email\n                # Send the email with the report\n                success, message = send_report_email(\n                    current_user, \n                    patient,\n                    pdf_buffer,\n                    filename,\n                    language=current_language\n                )\n                # Seek back to the beginning of the buffer after it's been read\n                pdf_buffer.seek(0)\n                # Show feedback to the doctor about the email status\n                if success:\n                    flash(message, 'success')\n                else:\n                    flash(message, 'warning')\n            # Return the PDF as a downloadable file\n            return send_file(\n                pdf_buffer,\n                as_attachment=True,\n                download_name=filename,\n                mimetype='application/pdf'\n            )\n        except Exception as e:\n            logger.exception(f\"Error generating specific report: {str(e)}\")\n            flash(_('Error generating specific report: %(error)s', error=str(e)), 'danger')\n            return redirect(url_for('views.patient_vitals', patient_id=patient_id))\n      # GET request - load data for the form\n    notes = patient.notes.order_by(Note.created_at.desc()).all()\n    observations = VitalObservation.query.filter_by(patient_id=patient_id).all()\n    # Group observations by vital type\n    observations_by_type = {}\n    for obs in observations:\n        vital_type = obs.vital_type.value\n        if vital_type not in observations_by_type:\n            observations_by_type[vital_type] = []\n        observations_by_type[vital_type].append(obs)\n      # Check for specific vital type in query parameters\n    vital_type_param = request.args.get('vital_type')\n    period_param = request.args.get('period')\n    select_all_param = request.args.get('select_all')\n    logger.info(f\"Loading report form with parameters: vital_type={vital_type_param}, period={period_param}, select_all={select_all_param}\")\n    return render_template(\n        'specific_report_form.html',  # We use the updated template\n        patient=patient,\n        notes=notes,\n        vital_types=list(VitalSignType),\n        observations_by_type=observations_by_type,\n        vital_type_param=vital_type_param,\n        period_param=period_param,\n        select_all_param=select_all_param,\n        now=datetime.now()\n    )\n</code></pre>"}]}