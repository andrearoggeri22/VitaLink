{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"VitaLink Documentation","text":"<p>Welcome to the VitaLink documentation\u2014a comprehensive guide to my platform for managing health data.</p>"},{"location":"index.html#project-overview","title":"Project Overview","text":"<p>VitaLink is designed to make it easy for both doctors and patients to manage and monitor health information. With VitaLink, you can track vital signs, generate detailed reports, and connect with various health platforms\u2014all in one place.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Patient Management: Register and manage patient profiles with ease</li> <li>Vital Signs Monitoring: Track and visualize vital parameters over time</li> <li>Report Generation: Create personalized reports for patients</li> <li>Health Platform Integration: Connect with platforms like Fitbit and other health monitoring devices</li> <li>Secure Authentication: Robust authentication system to keep your data safe</li> </ul>"},{"location":"index.html#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Tests: Details about the test cases and their implementation</li> </ul>"},{"location":"index.html#get-started","title":"Get Started","text":"<p>To begin using VitaLink, check out the API and module documentation to understand how the system works and how you can integrate it into your applications.</p>"},{"location":"tests/conftest.html","title":"Test Configurations","text":"<p>Test configuration file for VitaLink application.</p> <p>This module provides fixtures and setup for testing the VitaLink application. It configures the test environment, initializes the test database, and provides utility fixtures for the tests.</p>"},{"location":"tests/conftest.html#conftest.app_context","title":"<code>app_context()</code>","text":"<p>Create an application context for the tests.</p> <p>This fixture creates a Flask application context with an in-memory SQLite database that persists for the entire test session. It creates all database tables at the start of testing and drops them at the end.</p> <p>Returns:</p> Type Description <p>Flask application context that yields control back to the tests.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture(scope='session')\ndef app_context():\n    \"\"\"Create an application context for the tests.\n\n    This fixture creates a Flask application context with an in-memory SQLite database\n    that persists for the entire test session. It creates all database tables at the start\n    of testing and drops them at the end.\n\n    Returns:\n        Flask application context that yields control back to the tests.\n    \"\"\"\n    with app.app_context():\n        # Create tables at the session level\n        db.create_all()\n        yield\n        db.session.remove()\n        db.drop_all()\n</code></pre>"},{"location":"tests/conftest.html#conftest.client","title":"<code>client(app_context)</code>","text":"<p>Create a test client for the app.</p> <p>This fixture provides a Flask test client that can be used to send requests to the application. It ensures each test starts with a clean session and logs out any authenticated users both before and after the test.</p> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <p>The Flask application context fixture.</p> required <p>Returns:</p> Type Description <p>Flask test client for making requests to the application.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef client(app_context):\n    \"\"\"Create a test client for the app.\n\n    This fixture provides a Flask test client that can be used to send requests to the application.\n    It ensures each test starts with a clean session and logs out any authenticated users\n    both before and after the test.\n\n    Args:\n        app_context: The Flask application context fixture.\n\n    Returns:\n        Flask test client for making requests to the application.\n    \"\"\"\n    with app.test_client() as client:\n        # Tables are created in the app_context fixture\n        # Ensure the session is clean at the start of each test\n        db.session.begin_nested()\n\n        # Logout before each test to ensure a clean state\n        client.get('/logout', follow_redirects=True)\n\n        yield client\n\n        # Logout after each test to ensure the session is clean\n        client.get('/logout', follow_redirects=True)\n\n        # Rollback any changes made during the test\n        db.session.rollback()\n        # Clear the session cache\n        db.session.expire_all()\n        # Keep an active session\n        db.session.begin()\n</code></pre>"},{"location":"tests/conftest.html#conftest.doctor_factory","title":"<code>doctor_factory(app_context)</code>","text":"<p>Factory to create test doctors with random data.</p> <p>This fixture returns a function that can create Doctor instances with random or specified data. It handles creating the doctor, setting a password, and committing to the database.</p> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <p>The Flask application context fixture.</p> required <p>Returns:</p> Type Description <p>Function that creates and returns Doctor instances.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef doctor_factory(app_context):\n    \"\"\"Factory to create test doctors with random data.\n\n    This fixture returns a function that can create Doctor instances with random or\n    specified data. It handles creating the doctor, setting a password, and committing\n    to the database.\n\n    Args:\n        app_context: The Flask application context fixture.\n\n    Returns:\n        Function that creates and returns Doctor instances.\n    \"\"\"\n    def _create_doctor(email=None, password=\"Password123!\", first_name=None, last_name=None, specialty=None):\n        \"\"\"Create a test doctor with the given or random data.\n\n        Args:\n            email: Optional email address for the doctor.\n            password: Password for the doctor account (defaults to \"Password123!\").\n            first_name: Optional first name for the doctor.\n            last_name: Optional last name for the doctor.\n            specialty: Optional medical specialty for the doctor.\n\n        Returns:\n            Doctor: A new Doctor instance saved to the database.\n        \"\"\"\n        # Generate random data if not provided\n        random_str = ''.join(random.choices(string.ascii_lowercase, k=8))\n        if not email:\n            email = f\"doctor_{random_str}@example.com\"\n        if not first_name:\n            first_name = f\"Doctor_{random_str}\"\n        if not last_name:\n            last_name = f\"Test_{random_str}\"\n        if not specialty:\n            specialty = \"General Medicine\"\n\n        # Create doctor\n        doctor = Doctor(\n            email=email,\n            first_name=first_name,\n            last_name=last_name,\n            specialty=specialty\n        )\n        doctor.set_password(password)\n\n        # Save to database\n        db.session.add(doctor)\n        db.session.commit()\n\n        return doctor\n\n    return _create_doctor\n</code></pre>"},{"location":"tests/conftest.html#conftest.patient_factory","title":"<code>patient_factory(app_context)</code>","text":"<p>Factory to create test patients with random data.</p> <p>This fixture returns a function that can create Patient instances with random or specified data. It handles creating the patient and committing to the database.</p> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <p>The Flask application context fixture.</p> required <p>Returns:</p> Type Description <p>Function that creates and returns Patient instances.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef patient_factory(app_context):\n    \"\"\"Factory to create test patients with random data.\n\n    This fixture returns a function that can create Patient instances with random or\n    specified data. It handles creating the patient and committing to the database.\n\n    Args:\n        app_context: The Flask application context fixture.\n\n    Returns:\n        Function that creates and returns Patient instances.\n    \"\"\"\n    def _create_patient(first_name=None, last_name=None, email=None, date_of_birth=None, gender=None,\n                        contact_number=None, address=None):\n        \"\"\"Create a test patient with the given or random data.\n\n        Args:\n            first_name: Optional first name for the patient.\n            last_name: Optional last name for the patient.\n            email: Optional email address for the patient.\n            date_of_birth: Optional date of birth (defaults to 1980-01-01).\n            gender: Optional gender (randomly chosen if not provided).\n            contact_number: Optional contact number for the patient.\n            address: Optional address for the patient.\n\n        Returns:\n            Patient: A new Patient instance saved to the database.\n        \"\"\"\n        # Generate random data if not provided\n        random_str = ''.join(random.choices(string.ascii_lowercase, k=8))\n        if not first_name:\n            first_name = f\"Patient_{random_str}\"\n        if not last_name:\n            last_name = f\"Test_{random_str}\"\n        if not email:\n            email = f\"patient_{random_str}@example.com\"\n        if not date_of_birth:\n            date_of_birth = date(1980, 1, 1)\n        if not gender:\n            gender = random.choice([\"Male\", \"Female\", \"Non-binary\"])\n        if not contact_number:\n            contact_number = f\"+39{random.randint(300000000, 399999999)}\"\n        if not address:\n            address = f\"{random.randint(1, 100)} Test Street, Test City\"\n\n        # Create patient\n        patient = Patient(\n            first_name=first_name,\n            last_name=last_name,\n            email=email,\n            date_of_birth=date_of_birth,\n            gender=gender,\n            contact_number=contact_number,\n            address=address\n        )\n\n        # Save to database\n        db.session.add(patient)\n        db.session.commit()\n\n        return patient\n\n    return _create_patient\n</code></pre>"},{"location":"tests/conftest.html#conftest.authenticated_doctor","title":"<code>authenticated_doctor(client, doctor_factory)</code>","text":"<p>Create a doctor and authenticate as that doctor.</p> <p>This fixture creates a doctor, performs a login with their credentials, and returns the authenticated doctor instance. It verifies the authentication was successful by checking access to the dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client fixture.</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances.</p> required <p>Returns:</p> Name Type Description <code>Doctor</code> <p>An authenticated doctor instance.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef authenticated_doctor(client, doctor_factory):\n    \"\"\"Create a doctor and authenticate as that doctor.\n\n    This fixture creates a doctor, performs a login with their credentials, and returns\n    the authenticated doctor instance. It verifies the authentication was successful\n    by checking access to the dashboard.\n\n    Args:\n        client: Flask test client fixture.\n        doctor_factory: Factory fixture to create doctor instances.\n\n    Returns:\n        Doctor: An authenticated doctor instance.\n    \"\"\"\n    # Cleanup: ensure no active sessions\n    client.get('/logout', follow_redirects=True)\n\n    doctor = doctor_factory()\n    # Commit to ensure the doctor is saved in the database\n    db.session.flush()\n    db.session.commit()\n\n    doctor_id = doctor.id  # Save the ID before closing the session\n\n    # Most reliable way to authenticate: perform an actual login via form\n    response = client.post('/login', data={\n        'email': doctor.email,\n        'password': 'Password123!'  # Standard password used in doctor_factory\n    }, follow_redirects=True)\n\n    # Verify authentication was successful\n    assert response.status_code == 200, \"Login failed\"\n    assert b'Dashboard' in response.data, \"Login didn't redirect to dashboard\"\n\n    # Reload the doctor instance from the database to ensure it's connected to the session\n    # Use db.session.get to ensure we have the most recent instance\n    doctor = db.session.get(Doctor, doctor_id)\n    assert doctor is not None, \"Could not retrieve doctor from database\"\n\n    # Verify authentication works by trying to access the dashboard\n    dashboard_response = client.get('/dashboard')\n    assert dashboard_response.status_code == 200, \"Authentication is not persistent\"\n\n    # Ensure the object is connected to the session\n    doctor = db.session.merge(doctor)\n\n    return doctor\n</code></pre>"},{"location":"tests/conftest.html#conftest.doctor_with_patient","title":"<code>doctor_with_patient(client, doctor_factory, patient_factory)</code>","text":"<p>Create a doctor with an associated patient.</p> <p>This fixture creates a doctor and patient, associates them, and authenticates as the doctor. It returns both objects in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client fixture.</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances.</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing the authenticated doctor and associated patient.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef doctor_with_patient(client, doctor_factory, patient_factory):\n    \"\"\"Create a doctor with an associated patient.\n\n    This fixture creates a doctor and patient, associates them, and authenticates\n    as the doctor. It returns both objects in a dictionary.\n\n    Args:\n        client: Flask test client fixture.\n        doctor_factory: Factory fixture to create doctor instances.\n        patient_factory: Factory fixture to create patient instances.\n\n    Returns:\n        dict: Dictionary containing the authenticated doctor and associated patient.\n    \"\"\"\n    # Cleanup: ensure no active sessions\n    client.get('/logout', follow_redirects=True)\n\n    doctor = doctor_factory()\n    db.session.flush()  # Ensure doctor has an ID\n\n    patient = patient_factory()\n    db.session.flush()  # Ensure patient has an ID\n\n    # Reload entities from database to ensure they are attached\n    doctor = db.session.get(Doctor, doctor.id)\n    patient = db.session.get(Patient, patient.id)\n\n    # Create a new association between doctor and patient\n    # Instead of using the model method, create the association directly\n    association = DoctorPatient(doctor_id=doctor.id, patient_id=patient.id)\n    db.session.add(association)\n    db.session.commit()\n\n    # Most reliable way to authenticate: perform an actual login via form\n    response = client.post('/login', data={\n        'email': doctor.email,\n        'password': 'Password123!'  # Standard password used in doctor_factory\n    }, follow_redirects=True)\n\n    # Verify authentication was successful\n    assert response.status_code == 200, \"Login failed\"\n    assert b'Dashboard' in response.data, \"Login didn't redirect to dashboard\"\n\n    # Reattach objects to current database session to avoid detached instance errors\n    doctor = db.session.merge(doctor)\n    patient = db.session.merge(patient)\n\n    # Verify the association was made correctly\n    assert patient in doctor.patients.all(), \"Problem with doctor-patient association\"\n\n    return {'doctor': doctor, 'patient': patient}\n</code></pre>"},{"location":"tests/conftest.html#conftest.api_auth_headers","title":"<code>api_auth_headers(client, doctor_factory)</code>","text":"<p>Get authentication headers with JWT token for API requests.</p> <p>This fixture creates a doctor, obtains a JWT token by making an API login request, and returns the authentication headers along with doctor and token information.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client fixture.</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing authorization headers, doctor instance, and tokens.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef api_auth_headers(client, doctor_factory):\n    \"\"\"Get authentication headers with JWT token for API requests.\n\n    This fixture creates a doctor, obtains a JWT token by making an API login request,\n    and returns the authentication headers along with doctor and token information.\n\n    Args:\n        client: Flask test client fixture.\n        doctor_factory: Factory fixture to create doctor instances.\n\n    Returns:\n        dict: Dictionary containing authorization headers, doctor instance, and tokens.\n    \"\"\"\n    doctor = doctor_factory()\n\n    # Set a known password\n    doctor.set_password(\"Password123!\")\n    db.session.commit()\n\n    # The simplest way: get the token via a direct request\n    response = client.post('/api/login', json={\n        'email': doctor.email,\n        'password': \"Password123!\"\n    })\n\n    # Make sure doctor is attached to the session\n    doctor = db.session.merge(doctor)\n\n    # Parse the response\n    data = json.loads(response.data)\n\n    assert response.status_code == 200, f\"Login API failed with response: {response.data.decode()}\"\n    assert 'access_token' in data, \"Access token not found in response\"\n\n    headers = {\n        'Authorization': f\"Bearer {data['access_token']}\"\n    }\n\n    return {'headers': headers, 'doctor': doctor, 'access_token': data['access_token'], 'refresh_token': data['refresh_token']}\n</code></pre>"},{"location":"tests/conftest.html#conftest.note_factory","title":"<code>note_factory(app_context)</code>","text":"<p>Factory to create test notes.</p> <p>This fixture returns a function that can create Note instances for a doctor and patient.</p> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <p>Flask application context fixture.</p> required <p>Returns:</p> Type Description <p>Function that creates and returns Note instances.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef note_factory(app_context):\n    \"\"\"Factory to create test notes.\n\n    This fixture returns a function that can create Note instances for a doctor and patient.\n\n    Args:\n        app_context: Flask application context fixture.\n\n    Returns:\n        Function that creates and returns Note instances.\n    \"\"\"\n    def _create_note(doctor, patient, content=None):\n        \"\"\"Create a test note with the given or random data.\n\n        Args:\n            doctor: Doctor who creates the note.\n            patient: Patient the note is about.\n            content: Optional note content (random if not provided).\n\n        Returns:\n            Note: A new Note instance saved to the database.\n        \"\"\"\n        # Ensure doctor and patient are attached to the session\n        doctor = db.session.merge(doctor)\n        patient = db.session.merge(patient)\n\n        if not content:\n            content = f\"Test note created at {datetime.utcnow().isoformat()}\"\n\n        # Create note\n        note = Note(\n            doctor_id=doctor.id,\n            patient_id=patient.id,\n            content=content\n        )\n\n        # Save to database\n        db.session.add(note)\n        db.session.commit()\n\n        # Ensure note is attached to the session\n        note = db.session.merge(note)\n\n        return note\n\n    return _create_note\n</code></pre>"},{"location":"tests/conftest.html#conftest.observation_factory","title":"<code>observation_factory(app_context)</code>","text":"<p>Factory to create test vital sign observations.</p> <p>This fixture returns a function that can create VitalObservation instances for a doctor and patient.</p> <p>Parameters:</p> Name Type Description Default <code>app_context</code> <p>Flask application context fixture.</p> required <p>Returns:</p> Type Description <p>Function that creates and returns VitalObservation instances.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef observation_factory(app_context):\n    \"\"\"Factory to create test vital sign observations.\n\n    This fixture returns a function that can create VitalObservation instances\n    for a doctor and patient.\n\n    Args:\n        app_context: Flask application context fixture.\n\n    Returns:\n        Function that creates and returns VitalObservation instances.\n    \"\"\"\n    def _create_observation(doctor, patient, vital_type=None, content=None, \n                           start_date=None, end_date=None):\n        \"\"\"Create a test observation with the given or random data.\n\n        Args:\n            doctor: Doctor who creates the observation.\n            patient: Patient the observation is about.\n            vital_type: Type of vital sign (defaults to HEART_RATE).\n            content: Optional observation content.\n            start_date: Start date for the observation period.\n            end_date: End date for the observation period.\n\n        Returns:\n            VitalObservation: A new VitalObservation instance saved to the database.\n        \"\"\"\n        # Ensure doctor and patient are attached to the session\n        doctor = db.session.merge(doctor)\n        patient = db.session.merge(patient)\n\n        if not vital_type:\n            vital_type = VitalSignType.HEART_RATE\n        if not content:\n            content = f\"Test observation for {vital_type.value} created at {datetime.utcnow().isoformat()}\"\n        if not start_date:\n            start_date = datetime.utcnow() - timedelta(days=7)\n        if not end_date:\n            end_date = datetime.utcnow()\n\n        # Create observation\n        observation = VitalObservation(\n            doctor_id=doctor.id,\n            patient_id=patient.id,\n            vital_type=vital_type,\n            content=content,\n            start_date=start_date,\n            end_date=end_date\n        )\n\n        # Save to database\n        db.session.add(observation)\n        db.session.commit()\n\n        # Ensure the observation is attached to the session\n        observation = db.session.merge(observation)\n\n        return observation\n\n    return _create_observation\n</code></pre>"},{"location":"tests/conftest.html#conftest.reattach_objects","title":"<code>reattach_objects(objects)</code>","text":"<p>Reattach SQLAlchemy objects to the current session.</p> <p>Takes a single object or a list of objects and reattaches them to the current database session using db.session.merge().</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <p>A single SQLAlchemy object or a list of objects.</p> required <p>Returns:</p> Type Description <p>The object or list of objects reattached to the session.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object cannot be reattached and has no ID.</p> Source code in <code>tests/conftest.py</code> <pre><code>def reattach_objects(objects):\n    \"\"\"\n    Reattach SQLAlchemy objects to the current session.\n\n    Takes a single object or a list of objects and reattaches them\n    to the current database session using db.session.merge().\n\n    Args:\n        objects: A single SQLAlchemy object or a list of objects.\n\n    Returns:\n        The object or list of objects reattached to the session.\n\n    Raises:\n        Exception: If the object cannot be reattached and has no ID.\n    \"\"\"\n    try:\n        if isinstance(objects, list):\n            return [db.session.merge(obj) if obj is not None else None for obj in objects]\n        else:\n            return db.session.merge(objects) if objects is not None else None\n    except Exception as e:\n        # In case of error, try to reload the object using its ID\n        if hasattr(objects, 'id') and objects.id is not None:\n            obj_class = type(objects)\n            return db.session.get(obj_class, objects.id)\n        else:\n            # If reattachment is not possible, raise the original exception\n            raise e\n</code></pre>"},{"location":"tests/conftest.html#conftest.attach_to_session","title":"<code>attach_to_session()</code>","text":"<p>Fixture that provides the reattach_objects function to tests.</p> <p>This fixture makes the reattach_objects function available to tests so they can ensure their SQLAlchemy objects are properly attached to the current database session.</p> <p>Returns:</p> Name Type Description <code>Function</code> <p>The reattach_objects function.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef attach_to_session():\n    \"\"\"Fixture that provides the reattach_objects function to tests.\n\n    This fixture makes the reattach_objects function available to tests\n    so they can ensure their SQLAlchemy objects are properly attached to\n    the current database session.\n\n    Returns:\n        Function: The reattach_objects function.\n    \"\"\"\n    return reattach_objects\n</code></pre>"},{"location":"tests/test_api.html","title":"Test API","text":"<p>Test module for the API functionality.</p> <p>This module tests the REST API endpoints including: - Patient data access and management - Vital sign retrieval - Notes creation and management - Observations handling - Patient import functionality</p>"},{"location":"tests/test_api.html#test_api.TestAPI","title":"<code>TestAPI</code>","text":"<p>Test class for API functionality.</p> <p>This class contains test cases for all the API endpoints including patient management, notes, observations, and patient import functionality.</p> Source code in <code>tests/test_api.py</code> <pre><code>class TestAPI:\n    \"\"\"Test class for API functionality.\n\n    This class contains test cases for all the API endpoints including patient management,\n    notes, observations, and patient import functionality.\n    \"\"\"    \n    def test_get_patients(self, client, api_auth_headers, patient_factory):\n        \"\"\"Test GET /api/patients endpoint.\n\n        Verifies that the endpoint returns all patients associated with the authenticated doctor.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patients and associate with doctor\n        patient1 = patient_factory(first_name=\"Patient\", last_name=\"One\")\n        patient2 = patient_factory(first_name=\"Patient\", last_name=\"Two\")\n\n        doctor.add_patient(patient1)\n        doctor.add_patient(patient2)        # Test endpoint\n        response = client.get('/api/patients', headers=headers)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'patients' in data\n        assert len(data['patients']) == 2\n\n        # Verify patient data\n        patient_ids = [p['id'] for p in data['patients']]\n        assert patient1.id in patient_ids\n        assert patient2.id in patient_ids\n\n    def test_get_patient(self, client, api_auth_headers, patient_factory):\n        \"\"\"Test GET /api/patients/&lt;uuid&gt; endpoint.\n\n        Verifies that the endpoint returns the specific patient information when requested with a valid UUID.\n        Also tests error cases for invalid UUID, non-existent UUID, and accessing a patient \n        not associated with the doctor.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient and associate with doctor\n        patient = patient_factory(first_name=\"Test\", last_name=\"Patient\")\n        doctor.add_patient(patient)\n\n        # Test endpoint with valid UUID\n        response = client.get(f'/api/patients/{patient.uuid}', headers=headers)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'patient' in data\n        assert data['patient']['id'] == patient.id\n        assert data['patient']['first_name'] == \"Test\"\n        assert data['patient']['last_name'] == \"Patient\"\n\n        # Test with invalid UUID\n        response = client.get('/api/patients/invalid-uuid', headers=headers)\n        assert response.status_code == 400\n\n        # Test with non-existent UUID\n        random_uuid = str(uuid4())\n        response = client.get(f'/api/patients/{random_uuid}', headers=headers)\n        assert response.status_code == 404\n\n        # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.get(f'/api/patients/{unassociated_patient.uuid}', headers=headers)\n        assert response.status_code == 403\n\n    def test_get_notes(self, client, api_auth_headers, patient_factory, note_factory):\n        \"\"\"Test GET /api/patients/&lt;uuid&gt;/notes endpoint.\n\n        Verifies that the endpoint returns all notes for a specific patient.\n        Also tests error cases for invalid UUID, non-existent patient, and accessing\n        a patient not associated with the doctor.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n            note_factory: Factory to create test notes\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient with notes\n        patient = patient_factory()\n        doctor.add_patient(patient)\n\n        # Add multiple notes\n        note1 = note_factory(doctor, patient, \"First test note\")\n        note2 = note_factory(doctor, patient, \"Second test note\")\n\n        # Test endpoint\n        response = client.get(f'/api/patients/{patient.uuid}/notes', headers=headers)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'notes' in data\n        assert len(data['notes']) == 2\n\n        # Notes should be ordered by creation date (newest first)\n        assert data['notes'][0]['id'] == note2.id\n        assert data['notes'][1]['id'] == note1.id\n\n        # Test with invalid UUID\n        response = client.get('/api/patients/invalid-uuid/notes', headers=headers)\n        assert response.status_code == 400\n\n        # Test with non-existent patient\n        random_uuid = str(uuid4())\n        response = client.get(f'/api/patients/{random_uuid}/notes', headers=headers)\n        assert response.status_code == 404\n\n        # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.get(f'/api/patients/{unassociated_patient.uuid}/notes', headers=headers)\n        assert response.status_code == 403\n\n    def test_add_note(self, client, api_auth_headers, patient_factory):\n        \"\"\"Test POST /api/patients/&lt;uuid&gt;/notes endpoint.\n\n        Verifies that notes can be added to a patient through the API.\n        Also tests error cases for empty content, missing content, invalid UUID,\n        and adding a note to a patient not associated with the doctor.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient\n        patient = patient_factory()\n        doctor.add_patient(patient)\n\n        # Test adding a note\n        note_content = \"API test note content\"\n        response = client.post(\n            f'/api/patients/{patient.uuid}/notes',\n            headers=headers,\n            json={\"content\": note_content}\n        )\n\n        # Check response\n        assert response.status_code == 201\n        data = json.loads(response.data)\n        assert 'note' in data\n        assert data['note']['content'] == note_content\n\n        # Verify note was added to database\n        assert Note.query.filter_by(content=note_content, patient_id=patient.id).first() is not None\n\n        # Test with empty content\n        response = client.post(\n            f'/api/patients/{patient.uuid}/notes',\n            headers=headers,\n            json={\"content\": \"\"}\n        )\n        assert response.status_code == 400\n\n        # Test without content\n        response = client.post(\n            f'/api/patients/{patient.uuid}/notes',\n            headers=headers,\n            json={}\n        )\n        assert response.status_code == 400\n\n        # Test with invalid UUID\n        response = client.post(\n            '/api/patients/invalid-uuid/notes',\n            headers=headers,\n            json={\"content\": \"Test content\"}\n        )\n        assert response.status_code == 400\n\n        # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.post(\n            f'/api/patients/{unassociated_patient.uuid}/notes',\n            headers=headers,\n            json={\"content\": \"Test content\"}\n        )\n        assert response.status_code == 403\n\n    def test_delete_note(self, client, api_auth_headers, patient_factory, note_factory):\n        \"\"\"Test DELETE /api/notes/&lt;note_id&gt; endpoint.\n\n        Verifies that notes can be deleted through the API.\n        Also tests error cases for non-existent notes and unauthorized deletion attempts.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n            note_factory: Factory to create test notes\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient\n        patient = patient_factory()\n        doctor.add_patient(patient)\n\n        # Add a note\n        note = note_factory(doctor, patient, \"Note to be deleted\")\n\n        # Test deleting the note\n        response = client.delete(f'/api/notes/{note.id}', headers=headers)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert 'Note deleted successfully' in data['message']\n\n        # Verify note was deleted from database\n        assert Note.query.get(note.id) is None\n\n        # Test with non-existent note\n        response = client.delete('/api/notes/9999', headers=headers)\n        assert response.status_code == 404\n\n        # Create another doctor and note to test authorization\n        from app.models import Doctor\n        from app.app import db\n\n        # Create a new doctor\n        another_doctor = Doctor(email=\"another.doctor@example.com\", first_name=\"Another\", last_name=\"Doctor\")\n        another_doctor.set_password(\"Password123!\")\n        db.session.add(another_doctor)\n        db.session.commit()\n\n        # Create a patient and note for this new doctor\n        another_patient = patient_factory()\n        another_doctor.add_patient(another_patient)\n        another_note = note_factory(another_doctor, another_patient, \"Note from another doctor\")\n\n        # Login with the new doctor to get a token\n        another_login_response = client.post('/api/login', json={\n            'email': \"another.doctor@example.com\",\n            'password': \"Password123!\"\n        })\n        another_auth_token = json.loads(another_login_response.data)['access_token']\n        another_headers = {'Authorization': f'Bearer {another_auth_token}'}\n\n        # Attempt to delete the note using the original doctor's token\n        response = client.delete(f'/api/notes/{another_note.id}', headers=headers)\n        assert response.status_code == 403\n\n    def test_get_observations(self, client, api_auth_headers, patient_factory, observation_factory):\n        \"\"\"Test GET /api/patients/&lt;patient_id&gt;/observations endpoint.\n\n        Verifies that observations can be retrieved for a patient through the API.\n        Tests retrieving all observations and filtering by vital type and date range.\n        Also tests error cases for non-existent patient and unauthorized access.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n            observation_factory: Factory to create test observations\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient and observations\n        patient = patient_factory()\n        doctor.add_patient(patient)\n\n        # Create observations with different vital types\n        observation_factory(doctor, patient, VitalSignType.HEART_RATE)\n        observation_factory(doctor, patient, VitalSignType.STEPS)\n          # Test endpoint without filters\n        response = client.get(f'/api/observations/{patient.id}', headers=headers)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data) == 2\n\n        # Test with vital type filter\n        response = client.get(\n            f'/api/observations/{patient.id}?vital_type=heart_rate',\n            headers=headers\n        )\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data) == 1\n        assert data[0]['vital_type'] == 'heart_rate'        # Test with date range filter\n        start_date = (datetime.utcnow() - timedelta(days=10)).strftime('%Y-%m-%d')\n        end_date = datetime.utcnow().strftime('%Y-%m-%d')\n        response = client.get(\n            f'/api/observations/{patient.id}?start_date={start_date}&amp;end_date={end_date}',\n            headers=headers\n        )\n          # Check response - results may be empty depending on the date\n        assert response.status_code == 200\n        # We don't verify the number of results since it depends on the date\n\n        # Test with non-existent patient\n        response = client.get('/api/patients/9999/observations', headers=headers)\n        assert response.status_code == 404\n\n        # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.get(f'/api/observations/{unassociated_patient.id}', headers=headers)\n        assert response.status_code == 403  # HTTP 403 when patient is not associated with the doctor\n\n    def test_add_observation(self, client, api_auth_headers, patient_factory):\n        \"\"\"Test POST /api/observations endpoint.\n\n        Verifies that observations can be added through the API.\n        Also tests error cases for missing required fields, invalid vital type,\n        and adding an observation to a patient not associated with the doctor.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient\n        patient = patient_factory()\n        doctor.add_patient(patient)\n\n        # Test creating an observation\n        start_date = (datetime.utcnow() - timedelta(days=7)).isoformat()\n        end_date = datetime.utcnow().isoformat()\n\n        observation_data = {\n            \"patient_id\": patient.id,\n            \"vital_type\": \"heart_rate\",\n            \"content\": \"Heart rate has been stable within normal range\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n\n        response = client.post('/api/observations', headers=headers, json=observation_data)\n\n        # Check response\n        assert response.status_code == 201\n        data = json.loads(response.data)\n        assert 'observation' in data\n        assert data['observation']['vital_type'] == 'heart_rate'\n        assert data['observation']['content'] == observation_data['content']\n\n        # Verify observation was added to database\n        observation_id = data['observation']['id']\n        assert VitalObservation.query.get(observation_id) is not None\n\n        # Test with missing required fields\n        response = client.post('/api/observations', headers=headers, json={\n            \"patient_id\": patient.id,\n            \"content\": \"Incomplete observation\"\n        })\n        assert response.status_code == 400\n\n        # Test with invalid vital type\n        response = client.post('/api/observations', headers=headers, json={\n            \"patient_id\": patient.id,\n            \"vital_type\": \"invalid_type\",\n            \"content\": \"Invalid vital type\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        })\n        assert response.status_code == 400\n\n        # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.post('/api/observations', headers=headers, json={\n            \"patient_id\": unassociated_patient.id,\n            \"vital_type\": \"heart_rate\",\n            \"content\": \"Unauthorized\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        })\n        assert response.status_code == 403\n\n    def test_update_observation(self, client, api_auth_headers, patient_factory, observation_factory):\n        \"\"\"Test PUT /api/observations/&lt;observation_id&gt; endpoint.\n\n        Verifies that observations can be updated through the API.\n        Also tests error cases for non-existent observation and unauthorized update attempts.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n            observation_factory: Factory to create test observations\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient and observation\n        patient = patient_factory()\n        doctor.add_patient(patient)\n        observation = observation_factory(doctor, patient)\n\n        # Test updating observation\n        update_data = {\n            \"content\": \"Updated observation content\",\n            \"vital_type\": \"steps\"\n        }\n\n        # Use the correct endpoint format\n        response = client.put(\n            f'/api/observations/{observation.id}',\n            headers=headers, \n            json=update_data,\n            content_type='application/json'  # Ensure proper content type\n        )\n\n        # Check response\n        assert response.status_code == 200\n\n        # More robust JSON handling\n        if response.data:\n            try:\n                data = json.loads(response.data)\n                if 'observation' in data:\n                    assert data['observation']['content'] == update_data['content']\n                    assert data['observation']['vital_type'] == update_data['vital_type']\n            except json.JSONDecodeError:\n                pass  # If we can't decode JSON, we'll rely on status code check only\n\n        # Verify observation was updated in database\n        updated_observation = VitalObservation.query.get(observation.id)\n        assert updated_observation.content == update_data['content']\n        assert updated_observation.vital_type.value == update_data['vital_type']\n\n        # Test with non-existent observation\n        response = client.put('/api/observations/9999', headers=headers, json=update_data)\n        assert response.status_code == 404\n\n        # Test with observation not created by this doctor\n        from app.models import Doctor\n        from app.app import db\n\n        # Create a new doctor for authorization testing\n        other_doctor = Doctor(email=\"test_update_other@example.com\", first_name=\"Other\", last_name=\"Doctor\")\n        other_doctor.set_password(\"Password123!\")\n        db.session.add(other_doctor)\n        db.session.commit()\n\n        # Create a patient and observation owned by the other doctor\n        other_patient = patient_factory()\n        other_doctor.add_patient(other_patient)\n        other_observation = observation_factory(other_doctor, other_patient)\n\n        # Try to update the other doctor's observation with the original doctor's credentials\n        response = client.put(\n            f'/api/observations/{other_observation.id}',\n            headers=headers,\n            json=update_data\n        )\n        assert response.status_code == 403\n\n    def test_delete_observation(self, client, api_auth_headers, patient_factory, observation_factory):\n        \"\"\"Test DELETE /api/observations/&lt;observation_id&gt; endpoint.\n\n        Verifies that observations can be deleted through the API.\n        Also tests error cases for non-existent observation and unauthorized deletion attempts.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n            observation_factory: Factory to create test observations\n        \"\"\"\n        doctor = api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create patient and observation\n        patient = patient_factory()\n        doctor.add_patient(patient)\n        observation = observation_factory(doctor, patient)\n\n        # Test deleting observation\n        response = client.delete(f'/api/observations/{observation.id}', headers=headers)\n\n        # Check response - just verify status code since response might not be JSON\n        assert response.status_code == 200\n\n        # Try to parse JSON response if available\n        if response.data:\n            try:\n                data = json.loads(response.data)\n                if 'message' in data:\n                    assert 'successfully' in data['message'].lower()\n            except json.JSONDecodeError:\n                # If not JSON, that's okay - just check the status code\n                pass\n\n        # Verify observation was deleted from database\n        assert VitalObservation.query.get(observation.id) is None\n\n        # Test with non-existent observation\n        response = client.delete('/api/observations/9999', headers=headers)\n        assert response.status_code == 404\n\n        # Test with observation not created by this doctor\n        from app.models import Doctor\n        from app.app import db\n\n        # Create a new doctor for authorization testing\n        other_doctor = Doctor(email=\"test_delete_other@example.com\", first_name=\"Other\", last_name=\"Doctor\")\n        other_doctor.set_password(\"Password123!\")\n        db.session.add(other_doctor)\n        db.session.commit()\n\n        # Create a patient and observation owned by the other doctor\n        other_patient = patient_factory()\n        other_doctor.add_patient(other_patient)\n        other_observation = observation_factory(other_doctor, other_patient)\n\n        # Try to delete the other doctor's observation with the original doctor's credentials\n        response = client.delete(f'/api/observations/{other_observation.id}', headers=headers)\n        assert response.status_code == 403\n\n    def test_import_patient(self, client, api_auth_headers, patient_factory):\n        \"\"\"Test POST /api/patients/import endpoint.\n\n        Verifies that a patient can be imported/associated with a doctor through the API.\n        Also tests error cases for already associated patient, invalid UUID, and non-existent patient.\n\n        Args:\n            client: Flask test client\n            api_auth_headers: Authentication headers fixture\n            patient_factory: Factory to create test patients\n        \"\"\"\n        api_auth_headers['doctor']\n        headers = api_auth_headers['headers']\n\n        # Create a patient that isn't associated with the doctor\n        patient = patient_factory()\n\n        # Test importing patient\n        response = client.post(\n            '/api/patients/import',\n            headers=headers,\n            json={\"patient_uuid\": patient.uuid}\n        )\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert 'Patient imported successfully' in data['message']\n\n        # Verify patient is now associated with doctor\n        doctor_patient = Patient.query.join(\n            Patient.doctors\n        ).filter(\n            Patient.id == patient.id\n        ).count()\n        assert doctor_patient &gt; 0\n\n        # Test importing already associated patient\n        response = client.post(\n            '/api/patients/import',\n            headers=headers,\n            json={\"patient_uuid\": patient.uuid}\n        )\n        assert response.status_code == 409  # Conflict\n\n        # Test with invalid UUID\n        response = client.post(\n            '/api/patients/import',\n            headers=headers,\n            json={\"patient_uuid\": \"invalid-uuid\"}\n        )\n        assert response.status_code == 400\n\n        # Test with non-existent UUID\n        random_uuid = str(uuid4())\n        response = client.post(\n            '/api/patients/import',\n            headers=headers,\n            json={\"patient_uuid\": random_uuid}\n        )\n        assert response.status_code == 404\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_get_patients","title":"<code>test_get_patients(client, api_auth_headers, patient_factory)</code>","text":"<p>Test GET /api/patients endpoint.</p> <p>Verifies that the endpoint returns all patients associated with the authenticated doctor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_get_patients(self, client, api_auth_headers, patient_factory):\n    \"\"\"Test GET /api/patients endpoint.\n\n    Verifies that the endpoint returns all patients associated with the authenticated doctor.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patients and associate with doctor\n    patient1 = patient_factory(first_name=\"Patient\", last_name=\"One\")\n    patient2 = patient_factory(first_name=\"Patient\", last_name=\"Two\")\n\n    doctor.add_patient(patient1)\n    doctor.add_patient(patient2)        # Test endpoint\n    response = client.get('/api/patients', headers=headers)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'patients' in data\n    assert len(data['patients']) == 2\n\n    # Verify patient data\n    patient_ids = [p['id'] for p in data['patients']]\n    assert patient1.id in patient_ids\n    assert patient2.id in patient_ids\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_get_patient","title":"<code>test_get_patient(client, api_auth_headers, patient_factory)</code>","text":"<p>Test GET /api/patients/ endpoint. <p>Verifies that the endpoint returns the specific patient information when requested with a valid UUID. Also tests error cases for invalid UUID, non-existent UUID, and accessing a patient  not associated with the doctor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_get_patient(self, client, api_auth_headers, patient_factory):\n    \"\"\"Test GET /api/patients/&lt;uuid&gt; endpoint.\n\n    Verifies that the endpoint returns the specific patient information when requested with a valid UUID.\n    Also tests error cases for invalid UUID, non-existent UUID, and accessing a patient \n    not associated with the doctor.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient and associate with doctor\n    patient = patient_factory(first_name=\"Test\", last_name=\"Patient\")\n    doctor.add_patient(patient)\n\n    # Test endpoint with valid UUID\n    response = client.get(f'/api/patients/{patient.uuid}', headers=headers)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'patient' in data\n    assert data['patient']['id'] == patient.id\n    assert data['patient']['first_name'] == \"Test\"\n    assert data['patient']['last_name'] == \"Patient\"\n\n    # Test with invalid UUID\n    response = client.get('/api/patients/invalid-uuid', headers=headers)\n    assert response.status_code == 400\n\n    # Test with non-existent UUID\n    random_uuid = str(uuid4())\n    response = client.get(f'/api/patients/{random_uuid}', headers=headers)\n    assert response.status_code == 404\n\n    # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.get(f'/api/patients/{unassociated_patient.uuid}', headers=headers)\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_get_notes","title":"<code>test_get_notes(client, api_auth_headers, patient_factory, note_factory)</code>","text":"<p>Test GET /api/patients//notes endpoint. <p>Verifies that the endpoint returns all notes for a specific patient. Also tests error cases for invalid UUID, non-existent patient, and accessing a patient not associated with the doctor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required <code>note_factory</code> <p>Factory to create test notes</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_get_notes(self, client, api_auth_headers, patient_factory, note_factory):\n    \"\"\"Test GET /api/patients/&lt;uuid&gt;/notes endpoint.\n\n    Verifies that the endpoint returns all notes for a specific patient.\n    Also tests error cases for invalid UUID, non-existent patient, and accessing\n    a patient not associated with the doctor.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n        note_factory: Factory to create test notes\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient with notes\n    patient = patient_factory()\n    doctor.add_patient(patient)\n\n    # Add multiple notes\n    note1 = note_factory(doctor, patient, \"First test note\")\n    note2 = note_factory(doctor, patient, \"Second test note\")\n\n    # Test endpoint\n    response = client.get(f'/api/patients/{patient.uuid}/notes', headers=headers)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'notes' in data\n    assert len(data['notes']) == 2\n\n    # Notes should be ordered by creation date (newest first)\n    assert data['notes'][0]['id'] == note2.id\n    assert data['notes'][1]['id'] == note1.id\n\n    # Test with invalid UUID\n    response = client.get('/api/patients/invalid-uuid/notes', headers=headers)\n    assert response.status_code == 400\n\n    # Test with non-existent patient\n    random_uuid = str(uuid4())\n    response = client.get(f'/api/patients/{random_uuid}/notes', headers=headers)\n    assert response.status_code == 404\n\n    # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.get(f'/api/patients/{unassociated_patient.uuid}/notes', headers=headers)\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_add_note","title":"<code>test_add_note(client, api_auth_headers, patient_factory)</code>","text":"<p>Test POST /api/patients//notes endpoint. <p>Verifies that notes can be added to a patient through the API. Also tests error cases for empty content, missing content, invalid UUID, and adding a note to a patient not associated with the doctor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_add_note(self, client, api_auth_headers, patient_factory):\n    \"\"\"Test POST /api/patients/&lt;uuid&gt;/notes endpoint.\n\n    Verifies that notes can be added to a patient through the API.\n    Also tests error cases for empty content, missing content, invalid UUID,\n    and adding a note to a patient not associated with the doctor.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient\n    patient = patient_factory()\n    doctor.add_patient(patient)\n\n    # Test adding a note\n    note_content = \"API test note content\"\n    response = client.post(\n        f'/api/patients/{patient.uuid}/notes',\n        headers=headers,\n        json={\"content\": note_content}\n    )\n\n    # Check response\n    assert response.status_code == 201\n    data = json.loads(response.data)\n    assert 'note' in data\n    assert data['note']['content'] == note_content\n\n    # Verify note was added to database\n    assert Note.query.filter_by(content=note_content, patient_id=patient.id).first() is not None\n\n    # Test with empty content\n    response = client.post(\n        f'/api/patients/{patient.uuid}/notes',\n        headers=headers,\n        json={\"content\": \"\"}\n    )\n    assert response.status_code == 400\n\n    # Test without content\n    response = client.post(\n        f'/api/patients/{patient.uuid}/notes',\n        headers=headers,\n        json={}\n    )\n    assert response.status_code == 400\n\n    # Test with invalid UUID\n    response = client.post(\n        '/api/patients/invalid-uuid/notes',\n        headers=headers,\n        json={\"content\": \"Test content\"}\n    )\n    assert response.status_code == 400\n\n    # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.post(\n        f'/api/patients/{unassociated_patient.uuid}/notes',\n        headers=headers,\n        json={\"content\": \"Test content\"}\n    )\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_delete_note","title":"<code>test_delete_note(client, api_auth_headers, patient_factory, note_factory)</code>","text":"<p>Test DELETE /api/notes/ endpoint. <p>Verifies that notes can be deleted through the API. Also tests error cases for non-existent notes and unauthorized deletion attempts.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required <code>note_factory</code> <p>Factory to create test notes</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_delete_note(self, client, api_auth_headers, patient_factory, note_factory):\n    \"\"\"Test DELETE /api/notes/&lt;note_id&gt; endpoint.\n\n    Verifies that notes can be deleted through the API.\n    Also tests error cases for non-existent notes and unauthorized deletion attempts.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n        note_factory: Factory to create test notes\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient\n    patient = patient_factory()\n    doctor.add_patient(patient)\n\n    # Add a note\n    note = note_factory(doctor, patient, \"Note to be deleted\")\n\n    # Test deleting the note\n    response = client.delete(f'/api/notes/{note.id}', headers=headers)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert 'Note deleted successfully' in data['message']\n\n    # Verify note was deleted from database\n    assert Note.query.get(note.id) is None\n\n    # Test with non-existent note\n    response = client.delete('/api/notes/9999', headers=headers)\n    assert response.status_code == 404\n\n    # Create another doctor and note to test authorization\n    from app.models import Doctor\n    from app.app import db\n\n    # Create a new doctor\n    another_doctor = Doctor(email=\"another.doctor@example.com\", first_name=\"Another\", last_name=\"Doctor\")\n    another_doctor.set_password(\"Password123!\")\n    db.session.add(another_doctor)\n    db.session.commit()\n\n    # Create a patient and note for this new doctor\n    another_patient = patient_factory()\n    another_doctor.add_patient(another_patient)\n    another_note = note_factory(another_doctor, another_patient, \"Note from another doctor\")\n\n    # Login with the new doctor to get a token\n    another_login_response = client.post('/api/login', json={\n        'email': \"another.doctor@example.com\",\n        'password': \"Password123!\"\n    })\n    another_auth_token = json.loads(another_login_response.data)['access_token']\n    another_headers = {'Authorization': f'Bearer {another_auth_token}'}\n\n    # Attempt to delete the note using the original doctor's token\n    response = client.delete(f'/api/notes/{another_note.id}', headers=headers)\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_get_observations","title":"<code>test_get_observations(client, api_auth_headers, patient_factory, observation_factory)</code>","text":"<p>Test GET /api/patients//observations endpoint. <p>Verifies that observations can be retrieved for a patient through the API. Tests retrieving all observations and filtering by vital type and date range. Also tests error cases for non-existent patient and unauthorized access.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required <code>observation_factory</code> <p>Factory to create test observations</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_get_observations(self, client, api_auth_headers, patient_factory, observation_factory):\n    \"\"\"Test GET /api/patients/&lt;patient_id&gt;/observations endpoint.\n\n    Verifies that observations can be retrieved for a patient through the API.\n    Tests retrieving all observations and filtering by vital type and date range.\n    Also tests error cases for non-existent patient and unauthorized access.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n        observation_factory: Factory to create test observations\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient and observations\n    patient = patient_factory()\n    doctor.add_patient(patient)\n\n    # Create observations with different vital types\n    observation_factory(doctor, patient, VitalSignType.HEART_RATE)\n    observation_factory(doctor, patient, VitalSignType.STEPS)\n      # Test endpoint without filters\n    response = client.get(f'/api/observations/{patient.id}', headers=headers)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data) == 2\n\n    # Test with vital type filter\n    response = client.get(\n        f'/api/observations/{patient.id}?vital_type=heart_rate',\n        headers=headers\n    )\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data) == 1\n    assert data[0]['vital_type'] == 'heart_rate'        # Test with date range filter\n    start_date = (datetime.utcnow() - timedelta(days=10)).strftime('%Y-%m-%d')\n    end_date = datetime.utcnow().strftime('%Y-%m-%d')\n    response = client.get(\n        f'/api/observations/{patient.id}?start_date={start_date}&amp;end_date={end_date}',\n        headers=headers\n    )\n      # Check response - results may be empty depending on the date\n    assert response.status_code == 200\n    # We don't verify the number of results since it depends on the date\n\n    # Test with non-existent patient\n    response = client.get('/api/patients/9999/observations', headers=headers)\n    assert response.status_code == 404\n\n    # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.get(f'/api/observations/{unassociated_patient.id}', headers=headers)\n    assert response.status_code == 403  # HTTP 403 when patient is not associated with the doctor\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_add_observation","title":"<code>test_add_observation(client, api_auth_headers, patient_factory)</code>","text":"<p>Test POST /api/observations endpoint.</p> <p>Verifies that observations can be added through the API. Also tests error cases for missing required fields, invalid vital type, and adding an observation to a patient not associated with the doctor.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_add_observation(self, client, api_auth_headers, patient_factory):\n    \"\"\"Test POST /api/observations endpoint.\n\n    Verifies that observations can be added through the API.\n    Also tests error cases for missing required fields, invalid vital type,\n    and adding an observation to a patient not associated with the doctor.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient\n    patient = patient_factory()\n    doctor.add_patient(patient)\n\n    # Test creating an observation\n    start_date = (datetime.utcnow() - timedelta(days=7)).isoformat()\n    end_date = datetime.utcnow().isoformat()\n\n    observation_data = {\n        \"patient_id\": patient.id,\n        \"vital_type\": \"heart_rate\",\n        \"content\": \"Heart rate has been stable within normal range\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    }\n\n    response = client.post('/api/observations', headers=headers, json=observation_data)\n\n    # Check response\n    assert response.status_code == 201\n    data = json.loads(response.data)\n    assert 'observation' in data\n    assert data['observation']['vital_type'] == 'heart_rate'\n    assert data['observation']['content'] == observation_data['content']\n\n    # Verify observation was added to database\n    observation_id = data['observation']['id']\n    assert VitalObservation.query.get(observation_id) is not None\n\n    # Test with missing required fields\n    response = client.post('/api/observations', headers=headers, json={\n        \"patient_id\": patient.id,\n        \"content\": \"Incomplete observation\"\n    })\n    assert response.status_code == 400\n\n    # Test with invalid vital type\n    response = client.post('/api/observations', headers=headers, json={\n        \"patient_id\": patient.id,\n        \"vital_type\": \"invalid_type\",\n        \"content\": \"Invalid vital type\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    })\n    assert response.status_code == 400\n\n    # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.post('/api/observations', headers=headers, json={\n        \"patient_id\": unassociated_patient.id,\n        \"vital_type\": \"heart_rate\",\n        \"content\": \"Unauthorized\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    })\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_update_observation","title":"<code>test_update_observation(client, api_auth_headers, patient_factory, observation_factory)</code>","text":"<p>Test PUT /api/observations/ endpoint. <p>Verifies that observations can be updated through the API. Also tests error cases for non-existent observation and unauthorized update attempts.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required <code>observation_factory</code> <p>Factory to create test observations</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_update_observation(self, client, api_auth_headers, patient_factory, observation_factory):\n    \"\"\"Test PUT /api/observations/&lt;observation_id&gt; endpoint.\n\n    Verifies that observations can be updated through the API.\n    Also tests error cases for non-existent observation and unauthorized update attempts.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n        observation_factory: Factory to create test observations\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient and observation\n    patient = patient_factory()\n    doctor.add_patient(patient)\n    observation = observation_factory(doctor, patient)\n\n    # Test updating observation\n    update_data = {\n        \"content\": \"Updated observation content\",\n        \"vital_type\": \"steps\"\n    }\n\n    # Use the correct endpoint format\n    response = client.put(\n        f'/api/observations/{observation.id}',\n        headers=headers, \n        json=update_data,\n        content_type='application/json'  # Ensure proper content type\n    )\n\n    # Check response\n    assert response.status_code == 200\n\n    # More robust JSON handling\n    if response.data:\n        try:\n            data = json.loads(response.data)\n            if 'observation' in data:\n                assert data['observation']['content'] == update_data['content']\n                assert data['observation']['vital_type'] == update_data['vital_type']\n        except json.JSONDecodeError:\n            pass  # If we can't decode JSON, we'll rely on status code check only\n\n    # Verify observation was updated in database\n    updated_observation = VitalObservation.query.get(observation.id)\n    assert updated_observation.content == update_data['content']\n    assert updated_observation.vital_type.value == update_data['vital_type']\n\n    # Test with non-existent observation\n    response = client.put('/api/observations/9999', headers=headers, json=update_data)\n    assert response.status_code == 404\n\n    # Test with observation not created by this doctor\n    from app.models import Doctor\n    from app.app import db\n\n    # Create a new doctor for authorization testing\n    other_doctor = Doctor(email=\"test_update_other@example.com\", first_name=\"Other\", last_name=\"Doctor\")\n    other_doctor.set_password(\"Password123!\")\n    db.session.add(other_doctor)\n    db.session.commit()\n\n    # Create a patient and observation owned by the other doctor\n    other_patient = patient_factory()\n    other_doctor.add_patient(other_patient)\n    other_observation = observation_factory(other_doctor, other_patient)\n\n    # Try to update the other doctor's observation with the original doctor's credentials\n    response = client.put(\n        f'/api/observations/{other_observation.id}',\n        headers=headers,\n        json=update_data\n    )\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_delete_observation","title":"<code>test_delete_observation(client, api_auth_headers, patient_factory, observation_factory)</code>","text":"<p>Test DELETE /api/observations/ endpoint. <p>Verifies that observations can be deleted through the API. Also tests error cases for non-existent observation and unauthorized deletion attempts.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required <code>observation_factory</code> <p>Factory to create test observations</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_delete_observation(self, client, api_auth_headers, patient_factory, observation_factory):\n    \"\"\"Test DELETE /api/observations/&lt;observation_id&gt; endpoint.\n\n    Verifies that observations can be deleted through the API.\n    Also tests error cases for non-existent observation and unauthorized deletion attempts.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n        observation_factory: Factory to create test observations\n    \"\"\"\n    doctor = api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create patient and observation\n    patient = patient_factory()\n    doctor.add_patient(patient)\n    observation = observation_factory(doctor, patient)\n\n    # Test deleting observation\n    response = client.delete(f'/api/observations/{observation.id}', headers=headers)\n\n    # Check response - just verify status code since response might not be JSON\n    assert response.status_code == 200\n\n    # Try to parse JSON response if available\n    if response.data:\n        try:\n            data = json.loads(response.data)\n            if 'message' in data:\n                assert 'successfully' in data['message'].lower()\n        except json.JSONDecodeError:\n            # If not JSON, that's okay - just check the status code\n            pass\n\n    # Verify observation was deleted from database\n    assert VitalObservation.query.get(observation.id) is None\n\n    # Test with non-existent observation\n    response = client.delete('/api/observations/9999', headers=headers)\n    assert response.status_code == 404\n\n    # Test with observation not created by this doctor\n    from app.models import Doctor\n    from app.app import db\n\n    # Create a new doctor for authorization testing\n    other_doctor = Doctor(email=\"test_delete_other@example.com\", first_name=\"Other\", last_name=\"Doctor\")\n    other_doctor.set_password(\"Password123!\")\n    db.session.add(other_doctor)\n    db.session.commit()\n\n    # Create a patient and observation owned by the other doctor\n    other_patient = patient_factory()\n    other_doctor.add_patient(other_patient)\n    other_observation = observation_factory(other_doctor, other_patient)\n\n    # Try to delete the other doctor's observation with the original doctor's credentials\n    response = client.delete(f'/api/observations/{other_observation.id}', headers=headers)\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_api.html#test_api.TestAPI.test_import_patient","title":"<code>test_import_patient(client, api_auth_headers, patient_factory)</code>","text":"<p>Test POST /api/patients/import endpoint.</p> <p>Verifies that a patient can be imported/associated with a doctor through the API. Also tests error cases for already associated patient, invalid UUID, and non-existent patient.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>api_auth_headers</code> <p>Authentication headers fixture</p> required <code>patient_factory</code> <p>Factory to create test patients</p> required Source code in <code>tests/test_api.py</code> <pre><code>def test_import_patient(self, client, api_auth_headers, patient_factory):\n    \"\"\"Test POST /api/patients/import endpoint.\n\n    Verifies that a patient can be imported/associated with a doctor through the API.\n    Also tests error cases for already associated patient, invalid UUID, and non-existent patient.\n\n    Args:\n        client: Flask test client\n        api_auth_headers: Authentication headers fixture\n        patient_factory: Factory to create test patients\n    \"\"\"\n    api_auth_headers['doctor']\n    headers = api_auth_headers['headers']\n\n    # Create a patient that isn't associated with the doctor\n    patient = patient_factory()\n\n    # Test importing patient\n    response = client.post(\n        '/api/patients/import',\n        headers=headers,\n        json={\"patient_uuid\": patient.uuid}\n    )\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert 'Patient imported successfully' in data['message']\n\n    # Verify patient is now associated with doctor\n    doctor_patient = Patient.query.join(\n        Patient.doctors\n    ).filter(\n        Patient.id == patient.id\n    ).count()\n    assert doctor_patient &gt; 0\n\n    # Test importing already associated patient\n    response = client.post(\n        '/api/patients/import',\n        headers=headers,\n        json={\"patient_uuid\": patient.uuid}\n    )\n    assert response.status_code == 409  # Conflict\n\n    # Test with invalid UUID\n    response = client.post(\n        '/api/patients/import',\n        headers=headers,\n        json={\"patient_uuid\": \"invalid-uuid\"}\n    )\n    assert response.status_code == 400\n\n    # Test with non-existent UUID\n    random_uuid = str(uuid4())\n    response = client.post(\n        '/api/patients/import',\n        headers=headers,\n        json={\"patient_uuid\": random_uuid}\n    )\n    assert response.status_code == 404\n</code></pre>"},{"location":"tests/test_audit.html","title":"Test Audit","text":"<p>Test module for the audit functionality.</p> <p>This module tests the audit logging functionality including: - Audit log creation for various actions - Audit log retrieval and filtering - Audit stats generation - Convenience functions for common audit operations</p>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging","title":"<code>TestAuditLogging</code>","text":"<p>Test class for audit logging functionality.</p> <p>This class tests all aspects of the audit logging system including: - Base logging functionality - Entity-specific logging functions - API endpoints for retrieving audit data - Statistics generation for audit logs</p> Source code in <code>tests/test_audit.py</code> <pre><code>class TestAuditLogging:\n    \"\"\"Test class for audit logging functionality.\n\n    This class tests all aspects of the audit logging system including:\n    - Base logging functionality\n    - Entity-specific logging functions\n    - API endpoints for retrieving audit data\n    - Statistics generation for audit logs\n    \"\"\"\n\n    def test_log_action(self, doctor_factory, patient_factory):\n        \"\"\"Test log_action basic functionality.\n\n        Verifies that the core log_action function correctly creates audit logs\n        with the specified parameters, and that optional parameters are handled properly.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n        details = {\"test_key\": \"test_value\"}\n\n        # Create audit log\n        audit_log = log_action(\n            doctor_id=doctor.id,\n            action_type=ActionType.CREATE,\n            entity_type=EntityType.PATIENT,\n            entity_id=patient.id,\n            details=details,\n            patient_id=patient.id\n        )\n          # Verify audit log creation and properties\n        assert audit_log is not None\n        assert audit_log.doctor_id == doctor.id\n        assert audit_log.action_type == ActionType.CREATE\n        assert audit_log.entity_type == EntityType.PATIENT\n        assert audit_log.entity_id == patient.id\n        assert audit_log.patient_id == patient.id\n\n        # Check details were stored correctly\n        stored_details = audit_log.get_details()\n        assert stored_details['test_key'] == 'test_value'\n\n        # Test with missing optional parameters\n        audit_log = log_action(\n            doctor_id=doctor.id,\n            action_type=ActionType.VIEW,\n            entity_type=EntityType.NOTE,\n            entity_id=1\n        )\n\n        assert audit_log is not None\n        assert audit_log.doctor_id == doctor.id\n        assert audit_log.action_type == ActionType.VIEW\n        assert audit_log.entity_type == EntityType.NOTE\n        assert audit_log.entity_id == 1\n        assert audit_log.patient_id is None\n        assert audit_log.details is None\n\n    def test_patient_audit_logs(self, doctor_factory, patient_factory):\n        \"\"\"Test patient-related audit logging functions.\n\n        Verifies that all patient-related audit logging functions (creation, update,\n        delete, view, and import) correctly create audit logs with appropriate action types,\n        entity types, and details.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Test patient creation log\n        creation_log = log_patient_creation(doctor.id, patient)\n        assert creation_log is not None\n        assert creation_log.action_type == ActionType.CREATE\n        assert creation_log.entity_type == EntityType.PATIENT\n        assert creation_log.entity_id == patient.id\n\n        # Test patient update log\n        old_data = patient.to_dict()\n        patient.first_name = \"Updated\"\n        update_log = log_patient_update(doctor.id, patient, old_data)\n        assert update_log is not None\n        assert update_log.action_type == ActionType.UPDATE\n        assert update_log.entity_type == EntityType.PATIENT\n\n        # Verify update details contain old and new values\n        update_details = update_log.get_details()\n        assert 'old' in update_details\n        assert 'new' in update_details\n        assert update_details['old']['first_name'] == old_data['first_name']\n        assert update_details['new']['first_name'] == \"Updated\"\n\n        # Test patient delete log\n        delete_log = log_patient_delete(doctor.id, patient)\n        assert delete_log is not None\n        assert delete_log.action_type == ActionType.DELETE\n        assert delete_log.entity_type == EntityType.PATIENT\n\n        # Test patient view log\n        view_log = log_patient_view(doctor.id, patient.id)\n        assert view_log is not None\n        assert view_log.action_type == ActionType.VIEW\n        assert view_log.entity_type == EntityType.PATIENT\n\n        # Test patient import log\n        import_log = log_patient_import(doctor.id, patient)\n        assert import_log is not None\n        assert import_log.action_type == ActionType.IMPORT\n        assert import_log.entity_type == EntityType.PATIENT\n        assert import_log.entity_id == patient.id\n\n        # Verify import details contain patient UUID\n        import_details = import_log.get_details()\n        assert 'patient_uuid' in import_details\n        assert import_details['patient_uuid'] == patient.uuid\n\n    def test_note_audit_logs(self, doctor_factory, patient_factory):\n        \"\"\"Test note-related audit logging functions.\n\n        Verifies that note-related audit logging functions (creation and deletion)\n        correctly create audit logs with appropriate action types, entity types, and details.\n        Uses a mock Note object to simulate the database model.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create a test note\n        class MockNote:\n            def __init__(self):\n                self.id = 1\n                self.doctor_id = doctor.id\n                self.patient_id = patient.id\n                self.content = 'Test note content'\n                self.created_at = datetime.utcnow()\n                self.updated_at = datetime.utcnow()\n\n            def to_dict(self):\n                return {\n                    'id': self.id,\n                    'doctor_id': self.doctor_id, \n                    'patient_id': self.patient_id,\n                    'content': self.content,\n                    'created_at': self.created_at.isoformat(),\n                    'updated_at': self.updated_at.isoformat()\n                }\n\n        note = MockNote()\n\n        # Test note creation log\n        creation_log = log_note_creation(doctor.id, note)\n        assert creation_log is not None\n        assert creation_log.action_type == ActionType.CREATE\n        assert creation_log.entity_type == EntityType.NOTE\n        assert creation_log.entity_id == note.id\n        assert creation_log.patient_id == patient.id\n\n        # Test note deletion log\n        delete_log = log_note_delete(doctor.id, note)\n        assert delete_log is not None\n        assert delete_log.action_type == ActionType.DELETE\n        assert delete_log.entity_type == EntityType.NOTE\n        assert delete_log.entity_id == note.id\n        assert delete_log.patient_id == patient.id\n\n        # Verify deletion details contain note content\n        delete_details = delete_log.get_details()\n        assert 'content' in delete_details\n        assert delete_details['content'] == 'Test note content'\n\n    def test_observation_audit_logs(self, doctor_factory, patient_factory):\n        \"\"\"Test observation-related audit logging functions.\n\n        Verifies that observation-related audit logging functions (creation, update, \n        and deletion) correctly create audit logs with appropriate action types, \n        entity types, and details. Uses a mock Observation object to simulate\n        the database model.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create a test observation\n        class MockObservation:\n            def __init__(self):\n                self.id = 1\n                self.doctor_id = doctor.id\n                self.patient_id = patient.id\n                self.vital_type = VitalSignType.HEART_RATE\n                self.content = 'Heart rate observation'\n                self.start_date = datetime.utcnow() - timedelta(days=7)\n                self.end_date = datetime.utcnow()\n                self.created_at = datetime.utcnow()\n                self.updated_at = datetime.utcnow()\n\n            def to_dict(self):\n                return {\n                    'id': self.id,\n                    'doctor_id': self.doctor_id,\n                    'patient_id': self.patient_id,\n                    'vital_type': self.vital_type.value,\n                    'content': self.content,\n                    'start_date': self.start_date.isoformat(),\n                    'end_date': self.end_date.isoformat(),\n                    'created_at': self.created_at.isoformat(),\n                    'updated_at': self.updated_at.isoformat()\n                }\n\n        observation = MockObservation()\n\n        # Test observation creation log\n        creation_log = log_observation_creation(doctor.id, observation)\n        assert creation_log is not None\n        assert creation_log.action_type == ActionType.CREATE\n        assert creation_log.entity_type == EntityType.OBSERVATION\n        assert creation_log.entity_id == observation.id\n        assert creation_log.patient_id == patient.id\n\n        # Test observation update log\n        old_data = {'content': 'Old content'}\n        update_log = log_observation_update(doctor.id, observation, old_data)\n        assert update_log is not None\n        assert update_log.action_type == ActionType.UPDATE\n        assert update_log.entity_type == EntityType.OBSERVATION\n        assert update_log.entity_id == observation.id\n\n        # Test observation delete log\n        delete_log = log_observation_delete(doctor.id, observation)\n        assert delete_log is not None\n        assert delete_log.action_type == ActionType.DELETE\n        assert delete_log.entity_type == EntityType.OBSERVATION\n        assert delete_log.entity_id == observation.id\n\n    def test_vital_sign_audit_logs(self, doctor_factory, patient_factory):\n        \"\"\"Test vital sign-related audit logging functions.\n\n        Verifies that vital sign-related audit logging functions correctly \n        create audit logs with appropriate action types, entity types, and details.\n        Uses a mock VitalSign object to simulate the database model.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create a test vital sign\n        class MockVitalSign:\n            def __init__(self):\n                self.id = 1\n                self.patient_id = patient.id\n                self.type = VitalSignType.HEART_RATE\n                self.value = 72\n                self.timestamp = datetime.utcnow()\n\n            def to_dict(self):\n                return {\n                    'id': self.id,\n                    'patient_id': self.patient_id,\n                    'type': self.type.value,\n                    'value': self.value,\n                    'timestamp': self.timestamp.isoformat()\n                }\n\n        vital = MockVitalSign()\n\n        # Test vital sign creation log\n        creation_log = log_vital_creation(doctor.id, vital)\n        assert creation_log is not None\n        assert creation_log.action_type == ActionType.CREATE\n        assert creation_log.entity_type == EntityType.VITAL_SIGN\n        assert creation_log.entity_id == vital.id\n        assert creation_log.patient_id == patient.id\n\n        # Verify details contain vital type and value\n        creation_details = creation_log.get_details()\n        assert 'type' in creation_details\n        assert 'value' in creation_details\n        assert creation_details['type'] == 'heart_rate'\n        assert creation_details['value'] == 72\n\n    def test_report_generation_audit_log(self, doctor_factory, patient_factory):\n        \"\"\"Test report generation audit logging functions.\n\n        Verifies that report generation audit logging function correctly creates\n        audit logs with appropriate action types, entity types, and details including\n        report parameters.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n        report_params = {\n            'period': '7d',\n            'vital_types': ['heart_rate', 'steps']\n        }\n\n        # Test report generation log\n        report_log = log_report_generation(doctor.id, patient.id, 'Health Report', report_params)\n        assert report_log is not None\n        assert report_log.action_type == ActionType.EXPORT\n        assert report_log.entity_type == EntityType.REPORT\n        assert report_log.patient_id == patient.id\n\n        # Verify details contain report type and parameters\n        report_details = report_log.get_details()\n        assert 'report_type' in report_details\n        assert 'params' in report_details\n        assert report_details['report_type'] == 'Health Report'\n        assert report_details['params'] == report_params\n\n    def test_health_platform_audit_logs(self, doctor_factory, patient_factory):\n        \"\"\"Test health platform-related audit logging functions.\n\n        Verifies that health platform-related audit logging functions (link generation,\n        connection, disconnection, and data syncing) correctly create audit logs\n        with appropriate action types, entity types, and details.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n        platform_name = \"fitbit\"\n          # Create a mock health platform link using dynamic class\n        link = type('HealthPlatformLink', (), {\n            'id': 1,\n            'patient_id': patient.id,\n            'doctor_id': doctor.id,\n            'platform': 'fitbit',\n            'uuid': 'test-uuid',\n            'expires_at': datetime.utcnow() + timedelta(hours=24)\n        })\n\n        # Test health link creation log\n        link_log = log_health_link_creation(doctor.id, link)\n        assert link_log is not None\n        assert link_log.action_type == ActionType.GENERATE_LINK\n        assert link_log.entity_type == EntityType.HEALTH_LINK\n        assert link_log.entity_id == link.id\n        assert link_log.patient_id == patient.id\n\n        # Test platform connection log\n        connection_log = log_platform_connection(doctor.id, patient, platform_name)\n        assert connection_log is not None\n        assert connection_log.action_type == ActionType.CONNECT\n        assert connection_log.entity_type == EntityType.HEALTH_PLATFORM\n        assert connection_log.patient_id == patient.id\n\n        # Test platform disconnection log\n        disconnection_log = log_platform_disconnection(doctor.id, patient, platform_name)\n        assert disconnection_log is not None\n        assert disconnection_log.action_type == ActionType.DISCONNECT\n        assert disconnection_log.entity_type == EntityType.HEALTH_PLATFORM\n        assert disconnection_log.patient_id == patient.id\n\n        # Test data sync log\n        result_summary = {\n            'records': 150,\n            'timespan': '7 days',\n            'success': True\n        }\n          # Define data type and platform as strings\n        data_type = 'heart_rate'        \n        platform_name = 'fitbit'\n        sync_log = log_data_sync(doctor.id, patient, platform_name, data_type, result_summary)\n        assert sync_log is not None\n        assert sync_log.action_type == ActionType.SYNC\n        assert sync_log.entity_type == EntityType.HEALTH_PLATFORM\n        assert sync_log.patient_id == patient.id\n\n        # Verify sync details\n        sync_details = sync_log.get_details()\n        assert 'platform' in sync_details\n        assert 'data_type' in sync_details\n        assert 'result' in sync_details\n        assert sync_details['platform'] == platform_name\n        assert sync_details['data_type'] == 'heart_rate'\n        assert sync_details['result'] == result_summary\n\n    def test_audit_logs_api_endpoint(self, client, authenticated_doctor):\n        \"\"\"Test the API endpoint for retrieving audit logs.\n\n        Verifies that the audit logs API endpoint correctly returns audit logs\n        with various filters (action type, entity type, date range) and in different\n        formats (JSON, HTML).\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Fixture providing an authenticated doctor\n        \"\"\"\n        doctor = authenticated_doctor\n\n        # Create some audit logs\n        for i in range(5):\n            log_action(\n                doctor_id=doctor.id,\n                action_type=ActionType.VIEW,\n                entity_type=EntityType.PATIENT,\n                entity_id=i+1\n            )\n\n        # Test without filters, specifying JSON format and filtering by doctor_id\n        response = client.get(f'/audit/logs?format=json&amp;doctor_id={doctor.id}')\n\n        # Verify the endpoint is accessible\n        assert response.status_code == 200, \"Audit logs endpoint not accessible\"\n        data = json.loads(response.data)\n        # There should be exactly 5 logs created by the current doctor\n        assert len(data['logs']) == 5\n\n        # Test with action_type filter\n        log_action(\n            doctor_id=doctor.id,\n            action_type=ActionType.CREATE,\n            entity_type=EntityType.NOTE,\n            entity_id=1\n        )\n\n        # Filter by both action type and doctor ID\n        response = client.get(f'/audit/logs?action_type=CREATE&amp;doctor_id={doctor.id}&amp;format=json')\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data['logs']) == 1\n        assert data['logs'][0]['action_type'] == 'CREATE'\n\n        # Test with entity_type filter\n        response = client.get(f'/audit/logs?entity_type=note&amp;doctor_id={doctor.id}&amp;format=json')\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data['logs']) == 1\n        assert data['logs'][0]['entity_type'] == 'note'\n\n        # Test with date range filter\n        yesterday = (datetime.utcnow() - timedelta(days=1)).strftime('%Y-%m-%d')\n        tomorrow = (datetime.utcnow() + timedelta(days=1)).strftime('%Y-%m-%d')\n\n        response = client.get(f'/audit/logs?start_date={yesterday}&amp;end_date={tomorrow}&amp;doctor_id={doctor.id}&amp;format=json')\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data['logs']) == 6  # Verify that all created logs are within the date range\n\n        # Test HTML format vs JSON format\n        response = client.get('/audit/logs?format=html')\n        assert response.status_code == 200\n        assert response.content_type.startswith('text/html')\n\n        response = client.get('/audit/logs?format=json')\n        assert response.status_code == 200\n        assert response.content_type.startswith('application/json')\n\n    def test_audit_stats_api_endpoint(self, client, authenticated_doctor, patient_factory):\n        \"\"\"Test the API endpoint for retrieving audit statistics.\n\n        Verifies that the audit statistics API endpoint correctly returns\n        statistics about audit logs, including counts by action type, entity type,\n        and timeline data.\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Fixture providing an authenticated doctor\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = authenticated_doctor\n        patient = patient_factory()\n\n        # Create diverse audit logs\n        action_types = [\n            ActionType.CREATE, ActionType.UPDATE, ActionType.VIEW, \n            ActionType.DELETE, ActionType.EXPORT\n        ]\n\n        entity_types = [\n            EntityType.PATIENT, EntityType.NOTE, EntityType.OBSERVATION,\n            EntityType.REPORT, EntityType.VITAL_SIGN\n        ]\n\n        for action in action_types:\n            for entity in entity_types:\n                log_action(\n                    doctor_id=doctor.id,\n                    action_type=action,\n                    entity_type=entity,\n                    entity_id=1,\n                    patient_id=patient.id if entity != EntityType.PATIENT else None\n                )\n\n        # Test stats endpoint\n        response = client.get('/audit/logs/stats')\n        assert response.status_code == 200\n        data = json.loads(response.data)\n\n        # Verify presence of action_stats and entity_stats (updated structure)\n        assert 'action_stats' in data\n        assert 'entity_stats' in data\n        assert 'timeline' in data\n\n        # Check action counts - using action_stats instead of actions_by_type\n        assert len(data['action_stats']) &gt;= len(action_types)\n        for action_type in action_types:\n            found = False\n            for item in data['action_stats']:\n                if item['type'] == action_type.value:                    # Verify count is at least equal to the number of entity types we created\n                    assert item['count'] &gt;= len(entity_types)\n                    found = True\n                    break\n            assert found, f\"Action type {action_type.value} not found in results\"\n\n        # Check entity counts\n        assert len(data['entity_stats']) &gt;= len(entity_types)\n        for entity_type in entity_types:\n            found = False\n            for item in data['entity_stats']:\n                if item['type'] == entity_type.value.lower():\n                    # The count may vary due to other tests\n                    assert item['count'] &gt;= len(action_types)\n                    found = True\n                    break\n            assert found, f\"Entity type {entity_type.value} not found in results\"\n\n        # Check timeline data (updated structure)\n        assert 'timeline' in data\n        assert 'counts' in data['timeline']\n        assert 'labels' in data['timeline']\n        assert len(data['timeline']['counts']) == len(data['timeline']['labels'])\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_log_action","title":"<code>test_log_action(doctor_factory, patient_factory)</code>","text":"<p>Test log_action basic functionality.</p> <p>Verifies that the core log_action function correctly creates audit logs with the specified parameters, and that optional parameters are handled properly.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_log_action(self, doctor_factory, patient_factory):\n    \"\"\"Test log_action basic functionality.\n\n    Verifies that the core log_action function correctly creates audit logs\n    with the specified parameters, and that optional parameters are handled properly.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n    details = {\"test_key\": \"test_value\"}\n\n    # Create audit log\n    audit_log = log_action(\n        doctor_id=doctor.id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details=details,\n        patient_id=patient.id\n    )\n      # Verify audit log creation and properties\n    assert audit_log is not None\n    assert audit_log.doctor_id == doctor.id\n    assert audit_log.action_type == ActionType.CREATE\n    assert audit_log.entity_type == EntityType.PATIENT\n    assert audit_log.entity_id == patient.id\n    assert audit_log.patient_id == patient.id\n\n    # Check details were stored correctly\n    stored_details = audit_log.get_details()\n    assert stored_details['test_key'] == 'test_value'\n\n    # Test with missing optional parameters\n    audit_log = log_action(\n        doctor_id=doctor.id,\n        action_type=ActionType.VIEW,\n        entity_type=EntityType.NOTE,\n        entity_id=1\n    )\n\n    assert audit_log is not None\n    assert audit_log.doctor_id == doctor.id\n    assert audit_log.action_type == ActionType.VIEW\n    assert audit_log.entity_type == EntityType.NOTE\n    assert audit_log.entity_id == 1\n    assert audit_log.patient_id is None\n    assert audit_log.details is None\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_patient_audit_logs","title":"<code>test_patient_audit_logs(doctor_factory, patient_factory)</code>","text":"<p>Test patient-related audit logging functions.</p> <p>Verifies that all patient-related audit logging functions (creation, update, delete, view, and import) correctly create audit logs with appropriate action types, entity types, and details.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_patient_audit_logs(self, doctor_factory, patient_factory):\n    \"\"\"Test patient-related audit logging functions.\n\n    Verifies that all patient-related audit logging functions (creation, update,\n    delete, view, and import) correctly create audit logs with appropriate action types,\n    entity types, and details.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Test patient creation log\n    creation_log = log_patient_creation(doctor.id, patient)\n    assert creation_log is not None\n    assert creation_log.action_type == ActionType.CREATE\n    assert creation_log.entity_type == EntityType.PATIENT\n    assert creation_log.entity_id == patient.id\n\n    # Test patient update log\n    old_data = patient.to_dict()\n    patient.first_name = \"Updated\"\n    update_log = log_patient_update(doctor.id, patient, old_data)\n    assert update_log is not None\n    assert update_log.action_type == ActionType.UPDATE\n    assert update_log.entity_type == EntityType.PATIENT\n\n    # Verify update details contain old and new values\n    update_details = update_log.get_details()\n    assert 'old' in update_details\n    assert 'new' in update_details\n    assert update_details['old']['first_name'] == old_data['first_name']\n    assert update_details['new']['first_name'] == \"Updated\"\n\n    # Test patient delete log\n    delete_log = log_patient_delete(doctor.id, patient)\n    assert delete_log is not None\n    assert delete_log.action_type == ActionType.DELETE\n    assert delete_log.entity_type == EntityType.PATIENT\n\n    # Test patient view log\n    view_log = log_patient_view(doctor.id, patient.id)\n    assert view_log is not None\n    assert view_log.action_type == ActionType.VIEW\n    assert view_log.entity_type == EntityType.PATIENT\n\n    # Test patient import log\n    import_log = log_patient_import(doctor.id, patient)\n    assert import_log is not None\n    assert import_log.action_type == ActionType.IMPORT\n    assert import_log.entity_type == EntityType.PATIENT\n    assert import_log.entity_id == patient.id\n\n    # Verify import details contain patient UUID\n    import_details = import_log.get_details()\n    assert 'patient_uuid' in import_details\n    assert import_details['patient_uuid'] == patient.uuid\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_note_audit_logs","title":"<code>test_note_audit_logs(doctor_factory, patient_factory)</code>","text":"<p>Test note-related audit logging functions.</p> <p>Verifies that note-related audit logging functions (creation and deletion) correctly create audit logs with appropriate action types, entity types, and details. Uses a mock Note object to simulate the database model.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_note_audit_logs(self, doctor_factory, patient_factory):\n    \"\"\"Test note-related audit logging functions.\n\n    Verifies that note-related audit logging functions (creation and deletion)\n    correctly create audit logs with appropriate action types, entity types, and details.\n    Uses a mock Note object to simulate the database model.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create a test note\n    class MockNote:\n        def __init__(self):\n            self.id = 1\n            self.doctor_id = doctor.id\n            self.patient_id = patient.id\n            self.content = 'Test note content'\n            self.created_at = datetime.utcnow()\n            self.updated_at = datetime.utcnow()\n\n        def to_dict(self):\n            return {\n                'id': self.id,\n                'doctor_id': self.doctor_id, \n                'patient_id': self.patient_id,\n                'content': self.content,\n                'created_at': self.created_at.isoformat(),\n                'updated_at': self.updated_at.isoformat()\n            }\n\n    note = MockNote()\n\n    # Test note creation log\n    creation_log = log_note_creation(doctor.id, note)\n    assert creation_log is not None\n    assert creation_log.action_type == ActionType.CREATE\n    assert creation_log.entity_type == EntityType.NOTE\n    assert creation_log.entity_id == note.id\n    assert creation_log.patient_id == patient.id\n\n    # Test note deletion log\n    delete_log = log_note_delete(doctor.id, note)\n    assert delete_log is not None\n    assert delete_log.action_type == ActionType.DELETE\n    assert delete_log.entity_type == EntityType.NOTE\n    assert delete_log.entity_id == note.id\n    assert delete_log.patient_id == patient.id\n\n    # Verify deletion details contain note content\n    delete_details = delete_log.get_details()\n    assert 'content' in delete_details\n    assert delete_details['content'] == 'Test note content'\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_observation_audit_logs","title":"<code>test_observation_audit_logs(doctor_factory, patient_factory)</code>","text":"<p>Test observation-related audit logging functions.</p> <p>Verifies that observation-related audit logging functions (creation, update,  and deletion) correctly create audit logs with appropriate action types,  entity types, and details. Uses a mock Observation object to simulate the database model.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_observation_audit_logs(self, doctor_factory, patient_factory):\n    \"\"\"Test observation-related audit logging functions.\n\n    Verifies that observation-related audit logging functions (creation, update, \n    and deletion) correctly create audit logs with appropriate action types, \n    entity types, and details. Uses a mock Observation object to simulate\n    the database model.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create a test observation\n    class MockObservation:\n        def __init__(self):\n            self.id = 1\n            self.doctor_id = doctor.id\n            self.patient_id = patient.id\n            self.vital_type = VitalSignType.HEART_RATE\n            self.content = 'Heart rate observation'\n            self.start_date = datetime.utcnow() - timedelta(days=7)\n            self.end_date = datetime.utcnow()\n            self.created_at = datetime.utcnow()\n            self.updated_at = datetime.utcnow()\n\n        def to_dict(self):\n            return {\n                'id': self.id,\n                'doctor_id': self.doctor_id,\n                'patient_id': self.patient_id,\n                'vital_type': self.vital_type.value,\n                'content': self.content,\n                'start_date': self.start_date.isoformat(),\n                'end_date': self.end_date.isoformat(),\n                'created_at': self.created_at.isoformat(),\n                'updated_at': self.updated_at.isoformat()\n            }\n\n    observation = MockObservation()\n\n    # Test observation creation log\n    creation_log = log_observation_creation(doctor.id, observation)\n    assert creation_log is not None\n    assert creation_log.action_type == ActionType.CREATE\n    assert creation_log.entity_type == EntityType.OBSERVATION\n    assert creation_log.entity_id == observation.id\n    assert creation_log.patient_id == patient.id\n\n    # Test observation update log\n    old_data = {'content': 'Old content'}\n    update_log = log_observation_update(doctor.id, observation, old_data)\n    assert update_log is not None\n    assert update_log.action_type == ActionType.UPDATE\n    assert update_log.entity_type == EntityType.OBSERVATION\n    assert update_log.entity_id == observation.id\n\n    # Test observation delete log\n    delete_log = log_observation_delete(doctor.id, observation)\n    assert delete_log is not None\n    assert delete_log.action_type == ActionType.DELETE\n    assert delete_log.entity_type == EntityType.OBSERVATION\n    assert delete_log.entity_id == observation.id\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_vital_sign_audit_logs","title":"<code>test_vital_sign_audit_logs(doctor_factory, patient_factory)</code>","text":"<p>Test vital sign-related audit logging functions.</p> <p>Verifies that vital sign-related audit logging functions correctly  create audit logs with appropriate action types, entity types, and details. Uses a mock VitalSign object to simulate the database model.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_vital_sign_audit_logs(self, doctor_factory, patient_factory):\n    \"\"\"Test vital sign-related audit logging functions.\n\n    Verifies that vital sign-related audit logging functions correctly \n    create audit logs with appropriate action types, entity types, and details.\n    Uses a mock VitalSign object to simulate the database model.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create a test vital sign\n    class MockVitalSign:\n        def __init__(self):\n            self.id = 1\n            self.patient_id = patient.id\n            self.type = VitalSignType.HEART_RATE\n            self.value = 72\n            self.timestamp = datetime.utcnow()\n\n        def to_dict(self):\n            return {\n                'id': self.id,\n                'patient_id': self.patient_id,\n                'type': self.type.value,\n                'value': self.value,\n                'timestamp': self.timestamp.isoformat()\n            }\n\n    vital = MockVitalSign()\n\n    # Test vital sign creation log\n    creation_log = log_vital_creation(doctor.id, vital)\n    assert creation_log is not None\n    assert creation_log.action_type == ActionType.CREATE\n    assert creation_log.entity_type == EntityType.VITAL_SIGN\n    assert creation_log.entity_id == vital.id\n    assert creation_log.patient_id == patient.id\n\n    # Verify details contain vital type and value\n    creation_details = creation_log.get_details()\n    assert 'type' in creation_details\n    assert 'value' in creation_details\n    assert creation_details['type'] == 'heart_rate'\n    assert creation_details['value'] == 72\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_report_generation_audit_log","title":"<code>test_report_generation_audit_log(doctor_factory, patient_factory)</code>","text":"<p>Test report generation audit logging functions.</p> <p>Verifies that report generation audit logging function correctly creates audit logs with appropriate action types, entity types, and details including report parameters.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_report_generation_audit_log(self, doctor_factory, patient_factory):\n    \"\"\"Test report generation audit logging functions.\n\n    Verifies that report generation audit logging function correctly creates\n    audit logs with appropriate action types, entity types, and details including\n    report parameters.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n    report_params = {\n        'period': '7d',\n        'vital_types': ['heart_rate', 'steps']\n    }\n\n    # Test report generation log\n    report_log = log_report_generation(doctor.id, patient.id, 'Health Report', report_params)\n    assert report_log is not None\n    assert report_log.action_type == ActionType.EXPORT\n    assert report_log.entity_type == EntityType.REPORT\n    assert report_log.patient_id == patient.id\n\n    # Verify details contain report type and parameters\n    report_details = report_log.get_details()\n    assert 'report_type' in report_details\n    assert 'params' in report_details\n    assert report_details['report_type'] == 'Health Report'\n    assert report_details['params'] == report_params\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_health_platform_audit_logs","title":"<code>test_health_platform_audit_logs(doctor_factory, patient_factory)</code>","text":"<p>Test health platform-related audit logging functions.</p> <p>Verifies that health platform-related audit logging functions (link generation, connection, disconnection, and data syncing) correctly create audit logs with appropriate action types, entity types, and details.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_health_platform_audit_logs(self, doctor_factory, patient_factory):\n    \"\"\"Test health platform-related audit logging functions.\n\n    Verifies that health platform-related audit logging functions (link generation,\n    connection, disconnection, and data syncing) correctly create audit logs\n    with appropriate action types, entity types, and details.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n    platform_name = \"fitbit\"\n      # Create a mock health platform link using dynamic class\n    link = type('HealthPlatformLink', (), {\n        'id': 1,\n        'patient_id': patient.id,\n        'doctor_id': doctor.id,\n        'platform': 'fitbit',\n        'uuid': 'test-uuid',\n        'expires_at': datetime.utcnow() + timedelta(hours=24)\n    })\n\n    # Test health link creation log\n    link_log = log_health_link_creation(doctor.id, link)\n    assert link_log is not None\n    assert link_log.action_type == ActionType.GENERATE_LINK\n    assert link_log.entity_type == EntityType.HEALTH_LINK\n    assert link_log.entity_id == link.id\n    assert link_log.patient_id == patient.id\n\n    # Test platform connection log\n    connection_log = log_platform_connection(doctor.id, patient, platform_name)\n    assert connection_log is not None\n    assert connection_log.action_type == ActionType.CONNECT\n    assert connection_log.entity_type == EntityType.HEALTH_PLATFORM\n    assert connection_log.patient_id == patient.id\n\n    # Test platform disconnection log\n    disconnection_log = log_platform_disconnection(doctor.id, patient, platform_name)\n    assert disconnection_log is not None\n    assert disconnection_log.action_type == ActionType.DISCONNECT\n    assert disconnection_log.entity_type == EntityType.HEALTH_PLATFORM\n    assert disconnection_log.patient_id == patient.id\n\n    # Test data sync log\n    result_summary = {\n        'records': 150,\n        'timespan': '7 days',\n        'success': True\n    }\n      # Define data type and platform as strings\n    data_type = 'heart_rate'        \n    platform_name = 'fitbit'\n    sync_log = log_data_sync(doctor.id, patient, platform_name, data_type, result_summary)\n    assert sync_log is not None\n    assert sync_log.action_type == ActionType.SYNC\n    assert sync_log.entity_type == EntityType.HEALTH_PLATFORM\n    assert sync_log.patient_id == patient.id\n\n    # Verify sync details\n    sync_details = sync_log.get_details()\n    assert 'platform' in sync_details\n    assert 'data_type' in sync_details\n    assert 'result' in sync_details\n    assert sync_details['platform'] == platform_name\n    assert sync_details['data_type'] == 'heart_rate'\n    assert sync_details['result'] == result_summary\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_audit_logs_api_endpoint","title":"<code>test_audit_logs_api_endpoint(client, authenticated_doctor)</code>","text":"<p>Test the API endpoint for retrieving audit logs.</p> <p>Verifies that the audit logs API endpoint correctly returns audit logs with various filters (action type, entity type, date range) and in different formats (JSON, HTML).</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Fixture providing an authenticated doctor</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_audit_logs_api_endpoint(self, client, authenticated_doctor):\n    \"\"\"Test the API endpoint for retrieving audit logs.\n\n    Verifies that the audit logs API endpoint correctly returns audit logs\n    with various filters (action type, entity type, date range) and in different\n    formats (JSON, HTML).\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Fixture providing an authenticated doctor\n    \"\"\"\n    doctor = authenticated_doctor\n\n    # Create some audit logs\n    for i in range(5):\n        log_action(\n            doctor_id=doctor.id,\n            action_type=ActionType.VIEW,\n            entity_type=EntityType.PATIENT,\n            entity_id=i+1\n        )\n\n    # Test without filters, specifying JSON format and filtering by doctor_id\n    response = client.get(f'/audit/logs?format=json&amp;doctor_id={doctor.id}')\n\n    # Verify the endpoint is accessible\n    assert response.status_code == 200, \"Audit logs endpoint not accessible\"\n    data = json.loads(response.data)\n    # There should be exactly 5 logs created by the current doctor\n    assert len(data['logs']) == 5\n\n    # Test with action_type filter\n    log_action(\n        doctor_id=doctor.id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.NOTE,\n        entity_id=1\n    )\n\n    # Filter by both action type and doctor ID\n    response = client.get(f'/audit/logs?action_type=CREATE&amp;doctor_id={doctor.id}&amp;format=json')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data['logs']) == 1\n    assert data['logs'][0]['action_type'] == 'CREATE'\n\n    # Test with entity_type filter\n    response = client.get(f'/audit/logs?entity_type=note&amp;doctor_id={doctor.id}&amp;format=json')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data['logs']) == 1\n    assert data['logs'][0]['entity_type'] == 'note'\n\n    # Test with date range filter\n    yesterday = (datetime.utcnow() - timedelta(days=1)).strftime('%Y-%m-%d')\n    tomorrow = (datetime.utcnow() + timedelta(days=1)).strftime('%Y-%m-%d')\n\n    response = client.get(f'/audit/logs?start_date={yesterday}&amp;end_date={tomorrow}&amp;doctor_id={doctor.id}&amp;format=json')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data['logs']) == 6  # Verify that all created logs are within the date range\n\n    # Test HTML format vs JSON format\n    response = client.get('/audit/logs?format=html')\n    assert response.status_code == 200\n    assert response.content_type.startswith('text/html')\n\n    response = client.get('/audit/logs?format=json')\n    assert response.status_code == 200\n    assert response.content_type.startswith('application/json')\n</code></pre>"},{"location":"tests/test_audit.html#test_audit.TestAuditLogging.test_audit_stats_api_endpoint","title":"<code>test_audit_stats_api_endpoint(client, authenticated_doctor, patient_factory)</code>","text":"<p>Test the API endpoint for retrieving audit statistics.</p> <p>Verifies that the audit statistics API endpoint correctly returns statistics about audit logs, including counts by action type, entity type, and timeline data.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Fixture providing an authenticated doctor</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_audit.py</code> <pre><code>def test_audit_stats_api_endpoint(self, client, authenticated_doctor, patient_factory):\n    \"\"\"Test the API endpoint for retrieving audit statistics.\n\n    Verifies that the audit statistics API endpoint correctly returns\n    statistics about audit logs, including counts by action type, entity type,\n    and timeline data.\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Fixture providing an authenticated doctor\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = authenticated_doctor\n    patient = patient_factory()\n\n    # Create diverse audit logs\n    action_types = [\n        ActionType.CREATE, ActionType.UPDATE, ActionType.VIEW, \n        ActionType.DELETE, ActionType.EXPORT\n    ]\n\n    entity_types = [\n        EntityType.PATIENT, EntityType.NOTE, EntityType.OBSERVATION,\n        EntityType.REPORT, EntityType.VITAL_SIGN\n    ]\n\n    for action in action_types:\n        for entity in entity_types:\n            log_action(\n                doctor_id=doctor.id,\n                action_type=action,\n                entity_type=entity,\n                entity_id=1,\n                patient_id=patient.id if entity != EntityType.PATIENT else None\n            )\n\n    # Test stats endpoint\n    response = client.get('/audit/logs/stats')\n    assert response.status_code == 200\n    data = json.loads(response.data)\n\n    # Verify presence of action_stats and entity_stats (updated structure)\n    assert 'action_stats' in data\n    assert 'entity_stats' in data\n    assert 'timeline' in data\n\n    # Check action counts - using action_stats instead of actions_by_type\n    assert len(data['action_stats']) &gt;= len(action_types)\n    for action_type in action_types:\n        found = False\n        for item in data['action_stats']:\n            if item['type'] == action_type.value:                    # Verify count is at least equal to the number of entity types we created\n                assert item['count'] &gt;= len(entity_types)\n                found = True\n                break\n        assert found, f\"Action type {action_type.value} not found in results\"\n\n    # Check entity counts\n    assert len(data['entity_stats']) &gt;= len(entity_types)\n    for entity_type in entity_types:\n        found = False\n        for item in data['entity_stats']:\n            if item['type'] == entity_type.value.lower():\n                # The count may vary due to other tests\n                assert item['count'] &gt;= len(action_types)\n                found = True\n                break\n        assert found, f\"Entity type {entity_type.value} not found in results\"\n\n    # Check timeline data (updated structure)\n    assert 'timeline' in data\n    assert 'counts' in data['timeline']\n    assert 'labels' in data['timeline']\n    assert len(data['timeline']['counts']) == len(data['timeline']['labels'])\n</code></pre>"},{"location":"tests/test_auth.html","title":"Test Auth","text":"<p>Test module for authentication functionality.</p> <p>This module tests authentication functionalities including: - User registration  - Login and logout - JWT token authentication - Password validation - Protected route access</p>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication","title":"<code>TestAuthentication</code>","text":"<p>Test class for authentication functionality.</p> <p>This class tests various authentication features including user registration, login/logout functionality, API JWT token authentication, token refresh, and protected route access.</p> Source code in <code>tests/test_auth.py</code> <pre><code>class TestAuthentication:\n    \"\"\"Test class for authentication functionality.\n\n    This class tests various authentication features including user registration,\n    login/logout functionality, API JWT token authentication, token refresh, and\n    protected route access.\n    \"\"\"\n    def test_registration(self, client):\n        \"\"\"Test user registration process.\n\n        Verifies that a new doctor can successfully register with valid credentials,\n        and that duplicate email registration is properly rejected.\n\n        Args:\n            client: Flask test client\n        \"\"\"\n        email = 'new.doctor@example.com'\n\n        # Check that the doctor does not already exist\n        from app import db\n        existing = Doctor.query.filter_by(email=email).first()\n        if existing:\n            db.session.delete(existing)\n            db.session.commit()\n\n        # Test successful registration\n        response = client.post('/register', data={\n            'email': email,\n            'first_name': 'New',\n            'last_name': 'Doctor',\n            'specialty': 'Cardiology',\n            'password': 'Password123!',\n            'confirm_password': 'Password123!'\n        }, follow_redirects=True)\n          # Check response - look for success text\n        assert response.status_code == 200\n        # Check for registration success message in English or Italian\n        assert b'Registration completed' in response.data or b'Registrazione completata' in response.data\n\n        # Explicit database verification after registration\n        # Make a new query instead of closing the session\n        from sqlalchemy import text\n        result = db.session.execute(text(f\"SELECT * FROM doctor WHERE email = '{email}'\")).fetchone()\n        assert result is not None, \"Doctor was not created in database\"\n          # Verify doctor details using a separate query\n        doctor = db.session.execute(db.select(Doctor).filter_by(email=email)).scalar_one_or_none()\n        assert doctor is not None, \"Could not retrieve doctor from database\"\n        assert doctor.first_name == 'New'\n        assert doctor.last_name == 'Doctor'\n        assert doctor.specialty == 'Cardiology'\n\n        # Test duplicate email registration\n        response = client.post('/register', data={\n            'email': 'new.doctor@example.com',\n            'first_name': 'Another',\n            'last_name': 'Doctor',\n            'specialty': 'Neurology',\n            'password': 'Password123!',\n            'confirm_password': 'Password123!'\n        }, follow_redirects=True)\n\n        # Check response for duplicate email\n        assert response.status_code == 200\n        assert b'An account with this Email already exists' in response.data\n\n    def test_login_logout(self, client, doctor_factory):\n        \"\"\"Test login and logout functionality.\n\n        Verifies that a doctor can successfully log in with valid credentials\n        and log out. Also tests login failures with incorrect password and\n        non-existent account.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory to create test doctor instances\n        \"\"\"\n        from app import db\n\n        # Create a doctor for login testing\n        doctor = doctor_factory(email='login.test@example.com')\n\n        # Make sure the doctor is properly saved\n        db.session.flush()\n        db.session.refresh(doctor)\n\n        # Test login with correct credentials\n        response = client.post('/login', data={\n            'email': 'login.test@example.com',\n            'password': 'Password123!'\n        }, follow_redirects=True)\n\n        # Check successful login\n        assert response.status_code == 200\n        assert b'Dashboard' in response.data  # Successfully logged in users see the dashboard\n          # Test logout\n        response = client.get('/logout', follow_redirects=True)\n        assert response.status_code == 200\n        # Check for logout confirmation in English or Italian\n        assert b'You have been disconnected' in response.data or b'disconnesso' in response.data\n\n        # Test login with incorrect password\n        response = client.post('/login', data={\n            'email': 'login.test@example.com',\n            'password': 'WrongPassword!'\n        }, follow_redirects=True)\n\n        # Check failed login\n        assert response.status_code == 200\n        assert b'Invalid email or password' in response.data\n\n        # Test login with non-existent account\n        response = client.post('/login', data={\n            'email': 'nonexistent@example.com',\n            'password': 'Password123!'\n        }, follow_redirects=True)\n\n        # Check failed login\n        assert response.status_code == 200\n        assert b'Invalid email or password' in response.data\n\n    def test_api_login(self, client, doctor_factory):\n        \"\"\"Test API login endpoint and JWT token generation.\n\n        Verifies that the API login endpoint correctly generates JWT tokens\n        for valid credentials and returns appropriate errors for invalid credentials.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory to create test doctor instances\n        \"\"\"\n        # Create a doctor for API login testing\n        doctor = doctor_factory(email='api.login@example.com')\n\n        # Test successful API login\n        response = client.post('/api/login', json={\n            'email': 'api.login@example.com',\n            'password': 'Password123!'\n        })\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'access_token' in data\n        assert 'refresh_token' in data\n        assert 'doctor' in data\n        assert data['doctor']['email'] == 'api.login@example.com'\n\n        # Test API login with incorrect credentials\n        response = client.post('/api/login', json={\n            'email': 'api.login@example.com',\n            'password': 'WrongPassword!'\n        })\n\n        # Check response\n        assert response.status_code == 401\n        data = json.loads(response.data)\n        assert 'error' in data\n        assert 'Invalid email or password' in data['error']\n\n    def test_token_refresh(self, client, doctor_factory):\n        \"\"\"Test JWT token refresh endpoint.\n\n        Verifies that a valid refresh token can be used to obtain a new access token\n        and that invalid refresh tokens are properly rejected.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory to create test doctor instances\n        \"\"\"\n        # Create a doctor for API login testing\n        doctor = doctor_factory(email='refresh.test@example.com')\n\n        # Get initial tokens\n        response = client.post('/api/login', json={\n            'email': 'refresh.test@example.com',\n            'password': 'Password123!'\n        })\n\n        data = json.loads(response.data)\n        refresh_token = data['refresh_token']\n\n        # Use refresh token to get new access token\n        response = client.post('/api/refresh-token', headers={\n            'Authorization': f'Bearer {refresh_token}'\n        })\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'access_token' in data\n\n        # Test with invalid refresh token\n        response = client.post('/api/refresh-token', headers={\n            'Authorization': 'Bearer invalid_token'\n        })\n\n        # Check response\n        assert response.status_code == 422  # JWT extended returns 422 for invalid tokens\n\n    def test_protected_routes(self, client, doctor_factory):\n        \"\"\"Test access to protected routes with and without authentication.\n\n        Verifies that unauthenticated users are redirected to the login page when\n        trying to access protected routes, and that authenticated users can access\n        protected routes successfully.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory to create test doctor instances\n        \"\"\"\n        from app import db\n\n        # Try accessing protected route without login\n        response = client.get('/dashboard', follow_redirects=True)\n          # Should redirect to login page\n        assert response.status_code == 200\n        # Check for login form in English or Italian\n        assert b'login' in response.data.lower() or b'accedi' in response.data.lower()\n\n        # Login\n        doctor = doctor_factory(email='protected.test@example.com')\n\n        # Make sure the doctor is properly saved\n        db.session.flush()\n        db.session.refresh(doctor)\n\n        # Actual login with follow_redirects to reach the dashboard\n        login_response = client.post('/login', data={\n            'email': 'protected.test@example.com',\n            'password': 'Password123!'\n        }, follow_redirects=True)\n\n        # Verify that login was successful\n        assert login_response.status_code == 200\n        assert b'Dashboard' in login_response.data\n\n        # Try accessing protected route with login\n        response = client.get('/dashboard')\n\n        # Should allow access\n        assert response.status_code == 200\n        assert b'Dashboard' in response.data\n\n    def test_api_protected_routes(self, client, doctor_factory):\n        \"\"\"Test access to protected API routes with and without JWT tokens.\n\n        Verifies that unauthorized requests to protected API endpoints are rejected\n        with a 401 status code, and that requests with valid JWT tokens are accepted.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory to create test doctor instances\n        \"\"\"\n        # Try accessing protected API route without token\n        response = client.get('/api/patients')\n\n        # Should return 401 Unauthorized\n        assert response.status_code == 401\n\n        # Login to get token\n        doctor = doctor_factory(email='api.protected@example.com')\n        auth_response = client.post('/api/login', json={\n            'email': 'api.protected@example.com',\n            'password': 'Password123!'\n        })\n\n        data = json.loads(auth_response.data)\n        access_token = data['access_token']\n\n        # Access protected API route with token\n        response = client.get('/api/patients', headers={\n            'Authorization': f'Bearer {access_token}'\n        })\n\n        # Should allow access\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'patients' in data\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_registration","title":"<code>test_registration(client)</code>","text":"<p>Test user registration process.</p> <p>Verifies that a new doctor can successfully register with valid credentials, and that duplicate email registration is properly rejected.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_registration(self, client):\n    \"\"\"Test user registration process.\n\n    Verifies that a new doctor can successfully register with valid credentials,\n    and that duplicate email registration is properly rejected.\n\n    Args:\n        client: Flask test client\n    \"\"\"\n    email = 'new.doctor@example.com'\n\n    # Check that the doctor does not already exist\n    from app import db\n    existing = Doctor.query.filter_by(email=email).first()\n    if existing:\n        db.session.delete(existing)\n        db.session.commit()\n\n    # Test successful registration\n    response = client.post('/register', data={\n        'email': email,\n        'first_name': 'New',\n        'last_name': 'Doctor',\n        'specialty': 'Cardiology',\n        'password': 'Password123!',\n        'confirm_password': 'Password123!'\n    }, follow_redirects=True)\n      # Check response - look for success text\n    assert response.status_code == 200\n    # Check for registration success message in English or Italian\n    assert b'Registration completed' in response.data or b'Registrazione completata' in response.data\n\n    # Explicit database verification after registration\n    # Make a new query instead of closing the session\n    from sqlalchemy import text\n    result = db.session.execute(text(f\"SELECT * FROM doctor WHERE email = '{email}'\")).fetchone()\n    assert result is not None, \"Doctor was not created in database\"\n      # Verify doctor details using a separate query\n    doctor = db.session.execute(db.select(Doctor).filter_by(email=email)).scalar_one_or_none()\n    assert doctor is not None, \"Could not retrieve doctor from database\"\n    assert doctor.first_name == 'New'\n    assert doctor.last_name == 'Doctor'\n    assert doctor.specialty == 'Cardiology'\n\n    # Test duplicate email registration\n    response = client.post('/register', data={\n        'email': 'new.doctor@example.com',\n        'first_name': 'Another',\n        'last_name': 'Doctor',\n        'specialty': 'Neurology',\n        'password': 'Password123!',\n        'confirm_password': 'Password123!'\n    }, follow_redirects=True)\n\n    # Check response for duplicate email\n    assert response.status_code == 200\n    assert b'An account with this Email already exists' in response.data\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_login_logout","title":"<code>test_login_logout(client, doctor_factory)</code>","text":"<p>Test login and logout functionality.</p> <p>Verifies that a doctor can successfully log in with valid credentials and log out. Also tests login failures with incorrect password and non-existent account.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory to create test doctor instances</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_login_logout(self, client, doctor_factory):\n    \"\"\"Test login and logout functionality.\n\n    Verifies that a doctor can successfully log in with valid credentials\n    and log out. Also tests login failures with incorrect password and\n    non-existent account.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory to create test doctor instances\n    \"\"\"\n    from app import db\n\n    # Create a doctor for login testing\n    doctor = doctor_factory(email='login.test@example.com')\n\n    # Make sure the doctor is properly saved\n    db.session.flush()\n    db.session.refresh(doctor)\n\n    # Test login with correct credentials\n    response = client.post('/login', data={\n        'email': 'login.test@example.com',\n        'password': 'Password123!'\n    }, follow_redirects=True)\n\n    # Check successful login\n    assert response.status_code == 200\n    assert b'Dashboard' in response.data  # Successfully logged in users see the dashboard\n      # Test logout\n    response = client.get('/logout', follow_redirects=True)\n    assert response.status_code == 200\n    # Check for logout confirmation in English or Italian\n    assert b'You have been disconnected' in response.data or b'disconnesso' in response.data\n\n    # Test login with incorrect password\n    response = client.post('/login', data={\n        'email': 'login.test@example.com',\n        'password': 'WrongPassword!'\n    }, follow_redirects=True)\n\n    # Check failed login\n    assert response.status_code == 200\n    assert b'Invalid email or password' in response.data\n\n    # Test login with non-existent account\n    response = client.post('/login', data={\n        'email': 'nonexistent@example.com',\n        'password': 'Password123!'\n    }, follow_redirects=True)\n\n    # Check failed login\n    assert response.status_code == 200\n    assert b'Invalid email or password' in response.data\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_api_login","title":"<code>test_api_login(client, doctor_factory)</code>","text":"<p>Test API login endpoint and JWT token generation.</p> <p>Verifies that the API login endpoint correctly generates JWT tokens for valid credentials and returns appropriate errors for invalid credentials.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory to create test doctor instances</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_api_login(self, client, doctor_factory):\n    \"\"\"Test API login endpoint and JWT token generation.\n\n    Verifies that the API login endpoint correctly generates JWT tokens\n    for valid credentials and returns appropriate errors for invalid credentials.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory to create test doctor instances\n    \"\"\"\n    # Create a doctor for API login testing\n    doctor = doctor_factory(email='api.login@example.com')\n\n    # Test successful API login\n    response = client.post('/api/login', json={\n        'email': 'api.login@example.com',\n        'password': 'Password123!'\n    })\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'access_token' in data\n    assert 'refresh_token' in data\n    assert 'doctor' in data\n    assert data['doctor']['email'] == 'api.login@example.com'\n\n    # Test API login with incorrect credentials\n    response = client.post('/api/login', json={\n        'email': 'api.login@example.com',\n        'password': 'WrongPassword!'\n    })\n\n    # Check response\n    assert response.status_code == 401\n    data = json.loads(response.data)\n    assert 'error' in data\n    assert 'Invalid email or password' in data['error']\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_token_refresh","title":"<code>test_token_refresh(client, doctor_factory)</code>","text":"<p>Test JWT token refresh endpoint.</p> <p>Verifies that a valid refresh token can be used to obtain a new access token and that invalid refresh tokens are properly rejected.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory to create test doctor instances</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_token_refresh(self, client, doctor_factory):\n    \"\"\"Test JWT token refresh endpoint.\n\n    Verifies that a valid refresh token can be used to obtain a new access token\n    and that invalid refresh tokens are properly rejected.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory to create test doctor instances\n    \"\"\"\n    # Create a doctor for API login testing\n    doctor = doctor_factory(email='refresh.test@example.com')\n\n    # Get initial tokens\n    response = client.post('/api/login', json={\n        'email': 'refresh.test@example.com',\n        'password': 'Password123!'\n    })\n\n    data = json.loads(response.data)\n    refresh_token = data['refresh_token']\n\n    # Use refresh token to get new access token\n    response = client.post('/api/refresh-token', headers={\n        'Authorization': f'Bearer {refresh_token}'\n    })\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'access_token' in data\n\n    # Test with invalid refresh token\n    response = client.post('/api/refresh-token', headers={\n        'Authorization': 'Bearer invalid_token'\n    })\n\n    # Check response\n    assert response.status_code == 422  # JWT extended returns 422 for invalid tokens\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_protected_routes","title":"<code>test_protected_routes(client, doctor_factory)</code>","text":"<p>Test access to protected routes with and without authentication.</p> <p>Verifies that unauthenticated users are redirected to the login page when trying to access protected routes, and that authenticated users can access protected routes successfully.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory to create test doctor instances</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_protected_routes(self, client, doctor_factory):\n    \"\"\"Test access to protected routes with and without authentication.\n\n    Verifies that unauthenticated users are redirected to the login page when\n    trying to access protected routes, and that authenticated users can access\n    protected routes successfully.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory to create test doctor instances\n    \"\"\"\n    from app import db\n\n    # Try accessing protected route without login\n    response = client.get('/dashboard', follow_redirects=True)\n      # Should redirect to login page\n    assert response.status_code == 200\n    # Check for login form in English or Italian\n    assert b'login' in response.data.lower() or b'accedi' in response.data.lower()\n\n    # Login\n    doctor = doctor_factory(email='protected.test@example.com')\n\n    # Make sure the doctor is properly saved\n    db.session.flush()\n    db.session.refresh(doctor)\n\n    # Actual login with follow_redirects to reach the dashboard\n    login_response = client.post('/login', data={\n        'email': 'protected.test@example.com',\n        'password': 'Password123!'\n    }, follow_redirects=True)\n\n    # Verify that login was successful\n    assert login_response.status_code == 200\n    assert b'Dashboard' in login_response.data\n\n    # Try accessing protected route with login\n    response = client.get('/dashboard')\n\n    # Should allow access\n    assert response.status_code == 200\n    assert b'Dashboard' in response.data\n</code></pre>"},{"location":"tests/test_auth.html#test_auth.TestAuthentication.test_api_protected_routes","title":"<code>test_api_protected_routes(client, doctor_factory)</code>","text":"<p>Test access to protected API routes with and without JWT tokens.</p> <p>Verifies that unauthorized requests to protected API endpoints are rejected with a 401 status code, and that requests with valid JWT tokens are accepted.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory to create test doctor instances</p> required Source code in <code>tests/test_auth.py</code> <pre><code>def test_api_protected_routes(self, client, doctor_factory):\n    \"\"\"Test access to protected API routes with and without JWT tokens.\n\n    Verifies that unauthorized requests to protected API endpoints are rejected\n    with a 401 status code, and that requests with valid JWT tokens are accepted.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory to create test doctor instances\n    \"\"\"\n    # Try accessing protected API route without token\n    response = client.get('/api/patients')\n\n    # Should return 401 Unauthorized\n    assert response.status_code == 401\n\n    # Login to get token\n    doctor = doctor_factory(email='api.protected@example.com')\n    auth_response = client.post('/api/login', json={\n        'email': 'api.protected@example.com',\n        'password': 'Password123!'\n    })\n\n    data = json.loads(auth_response.data)\n    access_token = data['access_token']\n\n    # Access protected API route with token\n    response = client.get('/api/patients', headers={\n        'Authorization': f'Bearer {access_token}'\n    })\n\n    # Should allow access\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'patients' in data\n</code></pre>"},{"location":"tests/test_models.html","title":"Test Models","text":"<p>Test module for data models.</p> <p>This module tests the database models and their relationships: - Doctor model and authentication functions - Patient model and relationships - Notes and observations models - Audit log functionality - Health platform integration models</p>"},{"location":"tests/test_models.html#test_models.TestModels","title":"<code>TestModels</code>","text":"<p>Test class for database models.</p> <p>This class contains test cases for all database models in the application, including their relationships, methods, and validations.</p> Source code in <code>tests/test_models.py</code> <pre><code>class TestModels:\n    \"\"\"Test class for database models.\n\n    This class contains test cases for all database models in the application,\n    including their relationships, methods, and validations.\n    \"\"\"\n\n    def test_doctor_model(self, doctor_factory):\n        \"\"\"Test Doctor model creation and methods.\n\n        Verifies that a Doctor instance can be created with the correct attributes,\n        that passwords are properly hashed and can be verified, and that the to_dict\n        method returns the expected representation.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n        \"\"\"\n        # Test creation\n        doctor = doctor_factory(\n            email=\"test.doctor@example.com\",\n            first_name=\"Test\",\n            last_name=\"Doctor\",\n            specialty=\"General Medicine\"\n        )\n\n        # Verify doctor was created correctly\n        assert doctor.id is not None\n        assert doctor.email == \"test.doctor@example.com\"\n        assert doctor.first_name == \"Test\"\n        assert doctor.last_name == \"Doctor\"\n        assert doctor.specialty == \"General Medicine\"\n\n        # Test password hash\n        assert doctor.password_hash is not None\n        assert doctor.password_hash != \"Password123!\"  # Password should be hashed\n        assert doctor.check_password(\"Password123!\") is True\n        assert doctor.check_password(\"WrongPassword\") is False\n\n        # Test to_dict method\n        doctor_dict = doctor.to_dict()\n        assert doctor_dict['id'] == doctor.id\n        assert doctor_dict['email'] == doctor.email\n        assert doctor_dict['first_name'] == doctor.first_name\n        assert doctor_dict['last_name'] == doctor.last_name\n        assert doctor_dict['specialty'] == doctor.specialty\n        assert 'password_hash' not in doctor_dict  # Password hash should not be exposed in serialized data\n\n        # Test timestamps\n        assert isinstance(doctor.created_at, datetime)\n        assert isinstance(doctor.updated_at, datetime)\n\n    def test_patient_model(self, patient_factory):\n        \"\"\"Test Patient model creation and methods.\n\n        Verifies that a Patient instance can be created with the correct attributes,\n        that the UUID is properly generated, and that the to_dict method returns\n        the expected representation. Also checks that health platform fields are\n        initialized as null.\n\n        Args:\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        # Test creation\n        dob = date(1985, 5, 15)\n        patient = patient_factory(\n            first_name=\"Test\",\n            last_name=\"Patient\",\n            date_of_birth=dob,\n            gender=\"Male\",\n            contact_number=\"+391234567890\",\n            email=\"test.patient@example.com\",\n            address=\"123 Test Street\"\n        )\n\n        # Verify patient was created correctly\n        assert patient.id is not None\n        assert isinstance(UUID(patient.uuid), UUID)  # Verify UUID is in valid format\n        assert patient.first_name == \"Test\"\n        assert patient.last_name == \"Patient\"\n        assert patient.date_of_birth == dob\n        assert patient.gender == \"Male\"\n        assert patient.contact_number == \"+391234567890\"\n        assert patient.email == \"test.patient@example.com\"\n        assert patient.address == \"123 Test Street\"\n\n        # Test to_dict method\n        patient_dict = patient.to_dict()\n        assert patient_dict['id'] == patient.id\n        assert patient_dict['uuid'] == patient.uuid\n        assert patient_dict['first_name'] == patient.first_name\n        assert patient_dict['last_name'] == patient.last_name\n        assert patient_dict['date_of_birth'] == dob.isoformat()\n        assert patient_dict['gender'] == patient.gender\n\n        # Test health platform fields\n        assert patient.connected_platform is None\n        assert patient.platform_access_token is None\n        assert patient.platform_refresh_token is None\n        assert patient.platform_token_expires_at is None\n\n    def test_doctor_patient_relationship(self, doctor_factory, patient_factory):\n        \"\"\"Test the many-to-many relationship between doctors and patients.\n\n        Verifies that doctors can be associated with multiple patients and\n        vice versa. Tests both sides of the relationship and confirms that \n        the relationship is properly established in the database.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        # Create doctors and patients\n        doctor1 = doctor_factory()\n        doctor2 = doctor_factory()\n        patient1 = patient_factory()\n        patient2 = patient_factory()\n\n        # Associate doctors with patients\n        doctor1.add_patient(patient1)\n        doctor1.add_patient(patient2)\n        doctor2.add_patient(patient1)\n\n        # Check relationships\n        assert patient1 in doctor1.get_patients()\n        assert patient2 in doctor1.get_patients()\n        assert patient1 in doctor2.get_patients()\n        assert patient2 not in doctor2.get_patients()\n\n        # Check reverse relationships through query\n        patient1_doctors = list(patient1.doctors)\n        patient2_doctors = list(patient2.doctors)\n\n        assert doctor1 in patient1_doctors\n        assert doctor2 in patient1_doctors\n        assert doctor1 in patient2_doctors\n        assert doctor2 not in patient2_doctors\n          # Test removing patients\n        doctor1.remove_patient(patient1)\n        assert patient1 not in doctor1.get_patients()\n        assert patient1 in doctor2.get_patients()  # Verify patient1 remains associated with doctor2\n\n    def test_note_model(self, doctor_factory, patient_factory):\n        \"\"\"Test Note model creation and relationships.\n\n        Verifies that a Note instance can be created with the correct attributes,\n        that it's properly associated with a doctor and patient, and that\n        timestamps are correctly set.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create a note\n        note = Note(\n            doctor_id=doctor.id,\n            patient_id=patient.id,\n            content=\"Test note content\"\n        )\n        db.session.add(note)\n        db.session.commit()\n\n        # Verify note was created correctly\n        assert note.id is not None\n        assert note.doctor_id == doctor.id\n        assert note.patient_id == patient.id\n        assert note.content == \"Test note content\"\n\n        # Test relationships\n        assert note.doctor.id == doctor.id\n        assert note.patient.id == patient.id\n\n        # Test timestamps\n        assert isinstance(note.created_at, datetime)\n        assert note.created_at is not None\n\n        # Test to_dict method\n        note_dict = note.to_dict()\n        assert note_dict['id'] == note.id\n        assert note_dict['content'] == note.content\n        assert isinstance(note_dict['created_at'], str)  # DateTime should be converted to string in serialized data\n        assert note_dict['doctor_id'] == doctor.id\n        assert note_dict['patient_id'] == patient.id\n\n    def test_vital_observation_model(self, doctor_factory, patient_factory):\n        \"\"\"Test VitalObservation model creation and relationships.\n\n        Verifies that a VitalObservation instance can be created with the correct attributes,\n        that it's properly associated with a doctor and patient, and that\n        vital signs can be filtered by type and date range.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n        start_date = datetime.utcnow() - timedelta(days=7)\n        end_date = datetime.utcnow()\n\n        # Create observation\n        observation = VitalObservation(\n            doctor_id=doctor.id,\n            patient_id=patient.id,\n            vital_type=VitalSignType.HEART_RATE,\n            content=\"Heart rate has been stable\",\n            start_date=start_date,\n            end_date=end_date\n        )\n        db.session.add(observation)\n        db.session.commit()\n\n        # Verify observation was created correctly\n        assert observation.id is not None\n        assert observation.doctor_id == doctor.id\n        assert observation.patient_id == patient.id\n        assert observation.vital_type == VitalSignType.HEART_RATE\n        assert observation.content == \"Heart rate has been stable\"\n        assert observation.start_date == start_date\n        assert observation.end_date == end_date\n\n        # Test relationships\n        assert observation in doctor.vital_observations.all()\n        assert observation in patient.vital_observations.all()\n\n        # Test filtering observations by vital type\n        filtered_observations = patient.get_vital_observations(\n            vital_type=VitalSignType.HEART_RATE\n        )\n        assert observation in filtered_observations\n\n        # Test filtering observations by date range\n        filtered_observations = patient.get_vital_observations(\n            start_date=start_date - timedelta(days=1),\n            end_date=end_date + timedelta(days=1)\n        )\n        assert observation in filtered_observations\n\n        # Test to_dict method\n        observation_dict = observation.to_dict()\n        assert observation_dict['id'] == observation.id\n        assert observation_dict['vital_type'] == observation.vital_type.value\n        assert observation_dict['content'] == observation.content\n        assert observation_dict['doctor_id'] == doctor.id\n        assert observation_dict['patient_id'] == patient.id\n\n    def test_health_platform_link_model(self, doctor_factory, patient_factory):\n        \"\"\"Test HealthPlatformLink model creation and methods.\n\n        Verifies that a HealthPlatformLink instance can be created with the correct attributes,\n        that UUIDs are properly generated, and that expiration functionality works correctly.\n        Also tests the relationships with doctors and patients.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create health platform link\n        link = HealthPlatformLink(\n            patient_id=patient.id,\n            doctor_id=doctor.id,\n            platform=HealthPlatform.FITBIT\n        )\n        db.session.add(link)\n        db.session.commit()\n\n        # Verify link was created correctly\n        assert link.id is not None\n        assert isinstance(UUID(link.uuid), UUID)  # Verify UUID is in valid format\n        assert link.patient_id == patient.id\n        assert link.doctor_id == doctor.id\n        assert link.platform == HealthPlatform.FITBIT\n        assert link.used is False\n        assert link.created_at is not None\n        assert link.expires_at &gt; datetime.utcnow()\n\n        # Test relationships\n        assert link in patient.health_platform_links.all()\n        assert link in doctor.health_platform_links.all()\n\n        # Test expiration method\n        assert link.is_expired() is False\n          # Simulate expired link\n        link.expires_at = datetime.utcnow() - timedelta(minutes=5)\n        db.session.add(link)\n        db.session.commit()\n        assert link.is_expired() is True\n\n        # Test updating the used flag directly\n        link.used = True\n        db.session.add(link)\n        db.session.commit()\n        assert link.used is True\n\n    def test_audit_log_model(self, doctor_factory, patient_factory):\n        \"\"\"Test AuditLog model creation and methods.\n\n        Verifies that an AuditLog instance can be created with the correct attributes,\n        that JSON details are properly stored and retrieved, and that the to_dict\n        method returns the expected representation.\n\n        Args:\n            doctor_factory: Factory fixture to create Doctor instances\n            patient_factory: Factory fixture to create Patient instances\n        \"\"\"\n        doctor = doctor_factory()\n        patient = patient_factory()\n\n        # Create audit log entry\n        details = {\"action\": \"test\", \"value\": 123}\n        audit_log = AuditLog(\n            doctor_id=doctor.id,\n            action_type=ActionType.CREATE,\n            entity_type=EntityType.PATIENT,\n            entity_id=patient.id,\n            details=details,\n            patient_id=patient.id,\n            ip_address=\"127.0.0.1\"\n        )\n        db.session.add(audit_log)\n        db.session.commit()\n\n        # Verify audit log was created correctly\n        assert audit_log.id is not None\n        assert audit_log.doctor_id == doctor.id\n        assert audit_log.action_type == ActionType.CREATE\n        assert audit_log.entity_type == EntityType.PATIENT\n        assert audit_log.entity_id == patient.id\n        assert audit_log.patient_id == patient.id\n        assert audit_log.ip_address == \"127.0.0.1\"\n        assert audit_log.timestamp is not None\n\n        # Test get_details method\n        log_details = audit_log.get_details()\n        assert log_details['action'] == \"test\"\n        assert log_details['value'] == 123\n\n        # Test to_dict method\n        audit_dict = audit_log.to_dict()\n        assert audit_dict['id'] == audit_log.id\n        assert audit_dict['action_type'] == ActionType.CREATE.value\n        assert audit_dict['entity_type'] == EntityType.PATIENT.value\n        assert audit_dict['entity_id'] == patient.id\n        assert 'timestamp' in audit_dict\n        assert 'doctor_id' in audit_dict\n        assert 'patient_id' in audit_dict\n\n    def test_vital_sign_type_enum(self):\n        \"\"\"Test VitalSignType enum values.\n\n        Verifies that the VitalSignType enum contains the correct string values\n        for each vital sign type category (vital parameters, physical activity metrics,\n        and other health metrics).\n        \"\"\"\n        # Test main vital parameters\n        assert VitalSignType.HEART_RATE.value == 'heart_rate'\n        assert VitalSignType.OXYGEN_SATURATION.value == 'oxygen_saturation'\n        assert VitalSignType.BREATHING_RATE.value == 'breathing_rate'\n        assert VitalSignType.WEIGHT.value == 'weight'\n        assert VitalSignType.TEMPERATURE_CORE.value == 'temperature_core'\n\n        # Test physical activity metrics\n        assert VitalSignType.STEPS.value == 'steps'\n        assert VitalSignType.CALORIES.value == 'calories'\n        assert VitalSignType.DISTANCE.value == 'distance'\n        assert VitalSignType.ACTIVE_MINUTES.value == 'active_minutes'\n\n        # Test other metrics\n        assert VitalSignType.SLEEP_DURATION.value == 'sleep_duration'\n        assert VitalSignType.WATER.value == 'water'\n\n    def test_action_type_enum(self):\n        \"\"\"Test ActionType enum values.\n\n        Verifies that the ActionType enum contains the correct string values\n        for all supported action types in the audit logging system.\n        \"\"\"\n        assert ActionType.CREATE.value == 'CREATE'\n        assert ActionType.UPDATE.value == 'UPDATE'\n        assert ActionType.DELETE.value == 'DELETE'\n        assert ActionType.VIEW.value == 'VIEW'\n        assert ActionType.EXPORT.value == 'EXPORT'\n        assert ActionType.GENERATE_LINK.value == 'GENERATE_LINK'\n        assert ActionType.CONNECT.value == 'CONNECT'\n        assert ActionType.DISCONNECT.value == 'DISCONNECT'\n        assert ActionType.SYNC.value == 'SYNC'\n        assert ActionType.IMPORT.value == 'IMPORT'\n\n    def test_entity_type_enum(self):\n        \"\"\"Test EntityType enum values.\n\n        Verifies that the EntityType enum contains the correct string values\n        for all supported entity types in the system that can be audited.\n        \"\"\"\n        assert EntityType.PATIENT.value == 'patient'\n        assert EntityType.VITAL_SIGN.value == 'vital_sign'\n        assert EntityType.NOTE.value == 'note'\n        assert EntityType.REPORT.value == 'report'\n        assert EntityType.HEALTH_PLATFORM.value == 'health_platform'\n        assert EntityType.HEALTH_LINK.value == 'health_link'\n        assert EntityType.OBSERVATION.value == 'observation'\n\n    def test_health_platform_enum(self):\n        \"\"\"Test HealthPlatform enum values.\n\n        Verifies that the HealthPlatform enum contains the correct string values\n        for all supported external health platforms that can be integrated with the system.\n        \"\"\"\n        assert HealthPlatform.FITBIT.value == 'fitbit'\n        assert HealthPlatform.GOOGLE_HEALTH_CONNECT.value == 'google_health_connect'\n        assert HealthPlatform.APPLE_HEALTH.value == 'apple_health'\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_doctor_model","title":"<code>test_doctor_model(doctor_factory)</code>","text":"<p>Test Doctor model creation and methods.</p> <p>Verifies that a Doctor instance can be created with the correct attributes, that passwords are properly hashed and can be verified, and that the to_dict method returns the expected representation.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_doctor_model(self, doctor_factory):\n    \"\"\"Test Doctor model creation and methods.\n\n    Verifies that a Doctor instance can be created with the correct attributes,\n    that passwords are properly hashed and can be verified, and that the to_dict\n    method returns the expected representation.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n    \"\"\"\n    # Test creation\n    doctor = doctor_factory(\n        email=\"test.doctor@example.com\",\n        first_name=\"Test\",\n        last_name=\"Doctor\",\n        specialty=\"General Medicine\"\n    )\n\n    # Verify doctor was created correctly\n    assert doctor.id is not None\n    assert doctor.email == \"test.doctor@example.com\"\n    assert doctor.first_name == \"Test\"\n    assert doctor.last_name == \"Doctor\"\n    assert doctor.specialty == \"General Medicine\"\n\n    # Test password hash\n    assert doctor.password_hash is not None\n    assert doctor.password_hash != \"Password123!\"  # Password should be hashed\n    assert doctor.check_password(\"Password123!\") is True\n    assert doctor.check_password(\"WrongPassword\") is False\n\n    # Test to_dict method\n    doctor_dict = doctor.to_dict()\n    assert doctor_dict['id'] == doctor.id\n    assert doctor_dict['email'] == doctor.email\n    assert doctor_dict['first_name'] == doctor.first_name\n    assert doctor_dict['last_name'] == doctor.last_name\n    assert doctor_dict['specialty'] == doctor.specialty\n    assert 'password_hash' not in doctor_dict  # Password hash should not be exposed in serialized data\n\n    # Test timestamps\n    assert isinstance(doctor.created_at, datetime)\n    assert isinstance(doctor.updated_at, datetime)\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_patient_model","title":"<code>test_patient_model(patient_factory)</code>","text":"<p>Test Patient model creation and methods.</p> <p>Verifies that a Patient instance can be created with the correct attributes, that the UUID is properly generated, and that the to_dict method returns the expected representation. Also checks that health platform fields are initialized as null.</p> <p>Parameters:</p> Name Type Description Default <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_patient_model(self, patient_factory):\n    \"\"\"Test Patient model creation and methods.\n\n    Verifies that a Patient instance can be created with the correct attributes,\n    that the UUID is properly generated, and that the to_dict method returns\n    the expected representation. Also checks that health platform fields are\n    initialized as null.\n\n    Args:\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    # Test creation\n    dob = date(1985, 5, 15)\n    patient = patient_factory(\n        first_name=\"Test\",\n        last_name=\"Patient\",\n        date_of_birth=dob,\n        gender=\"Male\",\n        contact_number=\"+391234567890\",\n        email=\"test.patient@example.com\",\n        address=\"123 Test Street\"\n    )\n\n    # Verify patient was created correctly\n    assert patient.id is not None\n    assert isinstance(UUID(patient.uuid), UUID)  # Verify UUID is in valid format\n    assert patient.first_name == \"Test\"\n    assert patient.last_name == \"Patient\"\n    assert patient.date_of_birth == dob\n    assert patient.gender == \"Male\"\n    assert patient.contact_number == \"+391234567890\"\n    assert patient.email == \"test.patient@example.com\"\n    assert patient.address == \"123 Test Street\"\n\n    # Test to_dict method\n    patient_dict = patient.to_dict()\n    assert patient_dict['id'] == patient.id\n    assert patient_dict['uuid'] == patient.uuid\n    assert patient_dict['first_name'] == patient.first_name\n    assert patient_dict['last_name'] == patient.last_name\n    assert patient_dict['date_of_birth'] == dob.isoformat()\n    assert patient_dict['gender'] == patient.gender\n\n    # Test health platform fields\n    assert patient.connected_platform is None\n    assert patient.platform_access_token is None\n    assert patient.platform_refresh_token is None\n    assert patient.platform_token_expires_at is None\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_doctor_patient_relationship","title":"<code>test_doctor_patient_relationship(doctor_factory, patient_factory)</code>","text":"<p>Test the many-to-many relationship between doctors and patients.</p> <p>Verifies that doctors can be associated with multiple patients and vice versa. Tests both sides of the relationship and confirms that  the relationship is properly established in the database.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_doctor_patient_relationship(self, doctor_factory, patient_factory):\n    \"\"\"Test the many-to-many relationship between doctors and patients.\n\n    Verifies that doctors can be associated with multiple patients and\n    vice versa. Tests both sides of the relationship and confirms that \n    the relationship is properly established in the database.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    # Create doctors and patients\n    doctor1 = doctor_factory()\n    doctor2 = doctor_factory()\n    patient1 = patient_factory()\n    patient2 = patient_factory()\n\n    # Associate doctors with patients\n    doctor1.add_patient(patient1)\n    doctor1.add_patient(patient2)\n    doctor2.add_patient(patient1)\n\n    # Check relationships\n    assert patient1 in doctor1.get_patients()\n    assert patient2 in doctor1.get_patients()\n    assert patient1 in doctor2.get_patients()\n    assert patient2 not in doctor2.get_patients()\n\n    # Check reverse relationships through query\n    patient1_doctors = list(patient1.doctors)\n    patient2_doctors = list(patient2.doctors)\n\n    assert doctor1 in patient1_doctors\n    assert doctor2 in patient1_doctors\n    assert doctor1 in patient2_doctors\n    assert doctor2 not in patient2_doctors\n      # Test removing patients\n    doctor1.remove_patient(patient1)\n    assert patient1 not in doctor1.get_patients()\n    assert patient1 in doctor2.get_patients()  # Verify patient1 remains associated with doctor2\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_note_model","title":"<code>test_note_model(doctor_factory, patient_factory)</code>","text":"<p>Test Note model creation and relationships.</p> <p>Verifies that a Note instance can be created with the correct attributes, that it's properly associated with a doctor and patient, and that timestamps are correctly set.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_note_model(self, doctor_factory, patient_factory):\n    \"\"\"Test Note model creation and relationships.\n\n    Verifies that a Note instance can be created with the correct attributes,\n    that it's properly associated with a doctor and patient, and that\n    timestamps are correctly set.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create a note\n    note = Note(\n        doctor_id=doctor.id,\n        patient_id=patient.id,\n        content=\"Test note content\"\n    )\n    db.session.add(note)\n    db.session.commit()\n\n    # Verify note was created correctly\n    assert note.id is not None\n    assert note.doctor_id == doctor.id\n    assert note.patient_id == patient.id\n    assert note.content == \"Test note content\"\n\n    # Test relationships\n    assert note.doctor.id == doctor.id\n    assert note.patient.id == patient.id\n\n    # Test timestamps\n    assert isinstance(note.created_at, datetime)\n    assert note.created_at is not None\n\n    # Test to_dict method\n    note_dict = note.to_dict()\n    assert note_dict['id'] == note.id\n    assert note_dict['content'] == note.content\n    assert isinstance(note_dict['created_at'], str)  # DateTime should be converted to string in serialized data\n    assert note_dict['doctor_id'] == doctor.id\n    assert note_dict['patient_id'] == patient.id\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_vital_observation_model","title":"<code>test_vital_observation_model(doctor_factory, patient_factory)</code>","text":"<p>Test VitalObservation model creation and relationships.</p> <p>Verifies that a VitalObservation instance can be created with the correct attributes, that it's properly associated with a doctor and patient, and that vital signs can be filtered by type and date range.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_vital_observation_model(self, doctor_factory, patient_factory):\n    \"\"\"Test VitalObservation model creation and relationships.\n\n    Verifies that a VitalObservation instance can be created with the correct attributes,\n    that it's properly associated with a doctor and patient, and that\n    vital signs can be filtered by type and date range.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n    start_date = datetime.utcnow() - timedelta(days=7)\n    end_date = datetime.utcnow()\n\n    # Create observation\n    observation = VitalObservation(\n        doctor_id=doctor.id,\n        patient_id=patient.id,\n        vital_type=VitalSignType.HEART_RATE,\n        content=\"Heart rate has been stable\",\n        start_date=start_date,\n        end_date=end_date\n    )\n    db.session.add(observation)\n    db.session.commit()\n\n    # Verify observation was created correctly\n    assert observation.id is not None\n    assert observation.doctor_id == doctor.id\n    assert observation.patient_id == patient.id\n    assert observation.vital_type == VitalSignType.HEART_RATE\n    assert observation.content == \"Heart rate has been stable\"\n    assert observation.start_date == start_date\n    assert observation.end_date == end_date\n\n    # Test relationships\n    assert observation in doctor.vital_observations.all()\n    assert observation in patient.vital_observations.all()\n\n    # Test filtering observations by vital type\n    filtered_observations = patient.get_vital_observations(\n        vital_type=VitalSignType.HEART_RATE\n    )\n    assert observation in filtered_observations\n\n    # Test filtering observations by date range\n    filtered_observations = patient.get_vital_observations(\n        start_date=start_date - timedelta(days=1),\n        end_date=end_date + timedelta(days=1)\n    )\n    assert observation in filtered_observations\n\n    # Test to_dict method\n    observation_dict = observation.to_dict()\n    assert observation_dict['id'] == observation.id\n    assert observation_dict['vital_type'] == observation.vital_type.value\n    assert observation_dict['content'] == observation.content\n    assert observation_dict['doctor_id'] == doctor.id\n    assert observation_dict['patient_id'] == patient.id\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_health_platform_link_model","title":"<code>test_health_platform_link_model(doctor_factory, patient_factory)</code>","text":"<p>Test HealthPlatformLink model creation and methods.</p> <p>Verifies that a HealthPlatformLink instance can be created with the correct attributes, that UUIDs are properly generated, and that expiration functionality works correctly. Also tests the relationships with doctors and patients.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_health_platform_link_model(self, doctor_factory, patient_factory):\n    \"\"\"Test HealthPlatformLink model creation and methods.\n\n    Verifies that a HealthPlatformLink instance can be created with the correct attributes,\n    that UUIDs are properly generated, and that expiration functionality works correctly.\n    Also tests the relationships with doctors and patients.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create health platform link\n    link = HealthPlatformLink(\n        patient_id=patient.id,\n        doctor_id=doctor.id,\n        platform=HealthPlatform.FITBIT\n    )\n    db.session.add(link)\n    db.session.commit()\n\n    # Verify link was created correctly\n    assert link.id is not None\n    assert isinstance(UUID(link.uuid), UUID)  # Verify UUID is in valid format\n    assert link.patient_id == patient.id\n    assert link.doctor_id == doctor.id\n    assert link.platform == HealthPlatform.FITBIT\n    assert link.used is False\n    assert link.created_at is not None\n    assert link.expires_at &gt; datetime.utcnow()\n\n    # Test relationships\n    assert link in patient.health_platform_links.all()\n    assert link in doctor.health_platform_links.all()\n\n    # Test expiration method\n    assert link.is_expired() is False\n      # Simulate expired link\n    link.expires_at = datetime.utcnow() - timedelta(minutes=5)\n    db.session.add(link)\n    db.session.commit()\n    assert link.is_expired() is True\n\n    # Test updating the used flag directly\n    link.used = True\n    db.session.add(link)\n    db.session.commit()\n    assert link.used is True\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_audit_log_model","title":"<code>test_audit_log_model(doctor_factory, patient_factory)</code>","text":"<p>Test AuditLog model creation and methods.</p> <p>Verifies that an AuditLog instance can be created with the correct attributes, that JSON details are properly stored and retrieved, and that the to_dict method returns the expected representation.</p> <p>Parameters:</p> Name Type Description Default <code>doctor_factory</code> <p>Factory fixture to create Doctor instances</p> required <code>patient_factory</code> <p>Factory fixture to create Patient instances</p> required Source code in <code>tests/test_models.py</code> <pre><code>def test_audit_log_model(self, doctor_factory, patient_factory):\n    \"\"\"Test AuditLog model creation and methods.\n\n    Verifies that an AuditLog instance can be created with the correct attributes,\n    that JSON details are properly stored and retrieved, and that the to_dict\n    method returns the expected representation.\n\n    Args:\n        doctor_factory: Factory fixture to create Doctor instances\n        patient_factory: Factory fixture to create Patient instances\n    \"\"\"\n    doctor = doctor_factory()\n    patient = patient_factory()\n\n    # Create audit log entry\n    details = {\"action\": \"test\", \"value\": 123}\n    audit_log = AuditLog(\n        doctor_id=doctor.id,\n        action_type=ActionType.CREATE,\n        entity_type=EntityType.PATIENT,\n        entity_id=patient.id,\n        details=details,\n        patient_id=patient.id,\n        ip_address=\"127.0.0.1\"\n    )\n    db.session.add(audit_log)\n    db.session.commit()\n\n    # Verify audit log was created correctly\n    assert audit_log.id is not None\n    assert audit_log.doctor_id == doctor.id\n    assert audit_log.action_type == ActionType.CREATE\n    assert audit_log.entity_type == EntityType.PATIENT\n    assert audit_log.entity_id == patient.id\n    assert audit_log.patient_id == patient.id\n    assert audit_log.ip_address == \"127.0.0.1\"\n    assert audit_log.timestamp is not None\n\n    # Test get_details method\n    log_details = audit_log.get_details()\n    assert log_details['action'] == \"test\"\n    assert log_details['value'] == 123\n\n    # Test to_dict method\n    audit_dict = audit_log.to_dict()\n    assert audit_dict['id'] == audit_log.id\n    assert audit_dict['action_type'] == ActionType.CREATE.value\n    assert audit_dict['entity_type'] == EntityType.PATIENT.value\n    assert audit_dict['entity_id'] == patient.id\n    assert 'timestamp' in audit_dict\n    assert 'doctor_id' in audit_dict\n    assert 'patient_id' in audit_dict\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_vital_sign_type_enum","title":"<code>test_vital_sign_type_enum()</code>","text":"<p>Test VitalSignType enum values.</p> <p>Verifies that the VitalSignType enum contains the correct string values for each vital sign type category (vital parameters, physical activity metrics, and other health metrics).</p> Source code in <code>tests/test_models.py</code> <pre><code>def test_vital_sign_type_enum(self):\n    \"\"\"Test VitalSignType enum values.\n\n    Verifies that the VitalSignType enum contains the correct string values\n    for each vital sign type category (vital parameters, physical activity metrics,\n    and other health metrics).\n    \"\"\"\n    # Test main vital parameters\n    assert VitalSignType.HEART_RATE.value == 'heart_rate'\n    assert VitalSignType.OXYGEN_SATURATION.value == 'oxygen_saturation'\n    assert VitalSignType.BREATHING_RATE.value == 'breathing_rate'\n    assert VitalSignType.WEIGHT.value == 'weight'\n    assert VitalSignType.TEMPERATURE_CORE.value == 'temperature_core'\n\n    # Test physical activity metrics\n    assert VitalSignType.STEPS.value == 'steps'\n    assert VitalSignType.CALORIES.value == 'calories'\n    assert VitalSignType.DISTANCE.value == 'distance'\n    assert VitalSignType.ACTIVE_MINUTES.value == 'active_minutes'\n\n    # Test other metrics\n    assert VitalSignType.SLEEP_DURATION.value == 'sleep_duration'\n    assert VitalSignType.WATER.value == 'water'\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_action_type_enum","title":"<code>test_action_type_enum()</code>","text":"<p>Test ActionType enum values.</p> <p>Verifies that the ActionType enum contains the correct string values for all supported action types in the audit logging system.</p> Source code in <code>tests/test_models.py</code> <pre><code>def test_action_type_enum(self):\n    \"\"\"Test ActionType enum values.\n\n    Verifies that the ActionType enum contains the correct string values\n    for all supported action types in the audit logging system.\n    \"\"\"\n    assert ActionType.CREATE.value == 'CREATE'\n    assert ActionType.UPDATE.value == 'UPDATE'\n    assert ActionType.DELETE.value == 'DELETE'\n    assert ActionType.VIEW.value == 'VIEW'\n    assert ActionType.EXPORT.value == 'EXPORT'\n    assert ActionType.GENERATE_LINK.value == 'GENERATE_LINK'\n    assert ActionType.CONNECT.value == 'CONNECT'\n    assert ActionType.DISCONNECT.value == 'DISCONNECT'\n    assert ActionType.SYNC.value == 'SYNC'\n    assert ActionType.IMPORT.value == 'IMPORT'\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_entity_type_enum","title":"<code>test_entity_type_enum()</code>","text":"<p>Test EntityType enum values.</p> <p>Verifies that the EntityType enum contains the correct string values for all supported entity types in the system that can be audited.</p> Source code in <code>tests/test_models.py</code> <pre><code>def test_entity_type_enum(self):\n    \"\"\"Test EntityType enum values.\n\n    Verifies that the EntityType enum contains the correct string values\n    for all supported entity types in the system that can be audited.\n    \"\"\"\n    assert EntityType.PATIENT.value == 'patient'\n    assert EntityType.VITAL_SIGN.value == 'vital_sign'\n    assert EntityType.NOTE.value == 'note'\n    assert EntityType.REPORT.value == 'report'\n    assert EntityType.HEALTH_PLATFORM.value == 'health_platform'\n    assert EntityType.HEALTH_LINK.value == 'health_link'\n    assert EntityType.OBSERVATION.value == 'observation'\n</code></pre>"},{"location":"tests/test_models.html#test_models.TestModels.test_health_platform_enum","title":"<code>test_health_platform_enum()</code>","text":"<p>Test HealthPlatform enum values.</p> <p>Verifies that the HealthPlatform enum contains the correct string values for all supported external health platforms that can be integrated with the system.</p> Source code in <code>tests/test_models.py</code> <pre><code>def test_health_platform_enum(self):\n    \"\"\"Test HealthPlatform enum values.\n\n    Verifies that the HealthPlatform enum contains the correct string values\n    for all supported external health platforms that can be integrated with the system.\n    \"\"\"\n    assert HealthPlatform.FITBIT.value == 'fitbit'\n    assert HealthPlatform.GOOGLE_HEALTH_CONNECT.value == 'google_health_connect'\n    assert HealthPlatform.APPLE_HEALTH.value == 'apple_health'\n</code></pre>"},{"location":"tests/test_observations.html","title":"Test Observations","text":"<p>Test module for observations functionality.</p> <p>This module tests the observations functionality including: - Creating new vital sign observations - Retrieving observations for patients - Updating existing observations - Deleting observations - Filtering observations by various criteria</p>"},{"location":"tests/test_observations.html#test_observations.TestObservations","title":"<code>TestObservations</code>","text":"<p>Test class for observations functionality.</p> Source code in <code>tests/test_observations.py</code> <pre><code>class TestObservations:\n    \"\"\"Test class for observations functionality.\"\"\"          \n    def test_get_web_observations(self, client, doctor_with_patient, observation_factory):\n        \"\"\"Test retrieving observations through the web interface.\n\n        Verifies that observations can be correctly retrieved through the web interface,\n        including filtering by vital sign type and date ranges.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            observation_factory: Factory fixture to create observation instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Make sure doctor and patient are attached to the session\n        from app import db\n        from flask_login import login_user\n\n        # Reattach entities to the current database session\n        doctor = db.session.merge(doctor)\n        patient = db.session.merge(patient)\n          # Make sure the user is properly authenticated\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Force login to ensure current_user is set\n        response = client.get('/dashboard')\n        assert response.status_code == 200, \"Authentication failed, check session setup\"\n          # If relationship doesn't exist, create it\n        if patient not in doctor.patients.all():\n            doctor.add_patient(patient)\n            db.session.commit()\n\n        # Force login to ensure current_user is correctly set\n        with client.application.test_request_context():\n            login_user(doctor)\n\n        # Verify that the patient is associated with the doctor\n        assert patient in doctor.patients.all(), \"Patient is not associated with doctor in the database\"            \n        # Verify authentication before proceeding\n        auth_check = client.get('/dashboard')\n        print(f\"Auth check status: {auth_check.status_code}\")\n        if auth_check.status_code != 200:\n            pytest.skip(\"Authentication setup failed, skipping test\")\n\n        # Create test observations\n        heart_rate_obs = observation_factory(\n            doctor=doctor,\n            patient=patient,\n            vital_type=VitalSignType.HEART_RATE,\n            content=\"Heart rate observation\",\n            start_date=datetime.utcnow() - timedelta(days=10),\n            end_date=datetime.utcnow() - timedelta(days=3)\n        )\n\n        steps_obs = observation_factory(\n            doctor=doctor,\n            patient=patient,\n            vital_type=VitalSignType.STEPS,\n            content=\"Steps observation\",\n            start_date=datetime.utcnow() - timedelta(days=7),\n            end_date=datetime.utcnow()\n        )\n          # Test getting all observations - use the correct endpoint format\n        response = client.get(\n            f'/web/observations/{patient.id}',\n            headers={\"Accept\": \"application/json\"}  # Ensure JSON is accepted\n        )\n\n        # Debug output\n        print(f\"Response status: {response.status_code}\")\n        print(f\"Response data: {response.data}\")\n\n        # Check response\n        assert response.status_code == 200\n        try:\n            data = json.loads(response.data)\n            assert len(data) == 2\n        except json.JSONDecodeError:\n            pytest.fail(\"Failed to decode JSON response\")\n\n        # Test filtering by vital type\n        vital_type_url = f'/web/observations/{patient.id}?vital_type=heart_rate'\n        print(f\"Vital type filter URL: {vital_type_url}\")\n\n        response = client.get(vital_type_url)\n\n        # Debug output\n        print(f\"Vital type filter response status: {response.status_code}\")\n        print(f\"Vital type filter response data: {response.data}\")\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert len(data) == 1\n        assert data[0]['vital_type'] == 'heart_rate'\n        assert data[0]['content'] == \"Heart rate observation\"        # The date filtering issue is due to the date format\n        # observations.py expects a complete datetime (ISO format), while we're only passing YYYY-MM-DD\n\n        # Set the correct format with time\n        start_date = (datetime.utcnow() - timedelta(days=8)).isoformat()\n        end_date = (datetime.utcnow() - timedelta(days=1)).isoformat()\n        date_filter_url = f'/web/observations/{patient.id}?start_date={start_date}&amp;end_date={end_date}'\n\n        print(f\"Date filter URL: {date_filter_url}\")\n        print(f\"Start date: {start_date}, End date: {end_date}\")\n\n        response = client.get(date_filter_url)\n\n        # Debug output\n        print(f\"Date filter response status: {response.status_code}\")\n        print(f\"Date filter response data: {response.data}\")\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n          # The test must be flexible because dates may or may not fall within the filter\n        # depending on the exact time\n        if len(data) &gt; 0:\n            observed_type = data[0]['vital_type']\n            # It doesn't matter which observation is filtered, but it should be one of those created\n            assert observed_type in ['steps', 'heart_rate']    \n    def test_add_web_observation(self, client, doctor_with_patient, patient_factory):\n        \"\"\"Test adding a new observation through the web interface.\n\n        Verifies that a doctor can add new vital sign observations for their patients,\n        validates data integrity in the database, and tests error handling for invalid inputs.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n          # Make sure doctor and patient are attached to the session\n        from app import db\n        doctor = db.session.merge(doctor)\n        patient = db.session.merge(patient)\n\n        # Make sure the doctor is associated with the patient\n        if patient not in doctor.patients.all():\n            doctor.add_patient(patient)\n            db.session.commit()            # Reject existing session and create a new one with explicit login\n        client.get('/logout')  # Logout to ensure there are no existing sessions\n\n        # Explicit login as doctor\n        login_response = client.post('/login', data={\n            'email': doctor.email,\n            'password': 'Password123!'  # Standard password from doctor_factory\n        }, follow_redirects=True)\n\n        assert login_response.status_code == 200, \"Login failed\"\n        assert b'Dashboard' in login_response.data, \"Login did not redirect to dashboard\"\n          # Reload doctor from database to have the most recent object\n        doctor = db.session.get(Doctor, doctor.id)\n        assert doctor is not None\n\n        # Make sure entities are linked to the current session\n        from app import db\n        doctor = db.session.merge(doctor)\n        patient = db.session.merge(patient)\n\n        # Verify that the patient is associated with the doctor\n        assert patient in doctor.patients.all(), \"Patient is not associated with doctor\"\n\n        # Prepare observation data\n        start_date = (datetime.utcnow() - timedelta(days=7)).strftime('%Y-%m-%d')\n        end_date = datetime.utcnow().strftime('%Y-%m-%d')\n\n        observation_data = {\n            \"patient_id\": patient.id,\n            \"vital_type\": \"heart_rate\",\n            \"content\": \"Heart rate has been stable within normal range\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n\n        # Set proper headers for JSON request\n        headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n\n        # Test adding observation\n        response = client.post(\n            '/web/observations', \n            json=observation_data,\n            headers=headers\n        )\n\n        # Check response\n        assert response.status_code == 201\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert 'observation' in data\n        assert data['observation']['vital_type'] == 'heart_rate'\n        assert data['observation']['content'] == observation_data['content']\n\n        # Verify observation was added to database\n        observation_id = data['observation']['id']\n        observation = VitalObservation.query.get(observation_id)\n        assert observation is not None\n        assert observation.vital_type == VitalSignType.HEART_RATE\n        assert observation.doctor_id == doctor.id\n        assert observation.patient_id == patient.id\n\n        # Test with missing required fields\n        invalid_data = {\n            \"patient_id\": patient.id,\n            \"content\": \"Missing vital type\"\n        }\n        response = client.post('/web/observations', json=invalid_data)\n        assert response.status_code == 400\n\n        # Test with invalid vital type\n        invalid_data = {\n            \"patient_id\": patient.id,\n            \"vital_type\": \"invalid_type\",\n            \"content\": \"Invalid vital type\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n        response = client.post('/web/observations', json=invalid_data)\n        assert response.status_code == 400\n          # Test with patient not associated with doctor\n        unassociated_patient = db.session.merge(patient_factory())\n        invalid_data = {\n            \"patient_id\": unassociated_patient.id,\n            \"vital_type\": \"heart_rate\",\n            \"content\": \"Patient not associated with doctor\",\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n        response = client.post('/web/observations', json=invalid_data)\n        assert response.status_code == 403      \n    def test_update_web_observation(self, client, doctor_with_patient, observation_factory, doctor_factory):\n        \"\"\"Test updating an observation through the web interface.\n\n        Verifies that a doctor can update their existing observations including\n        complete and partial updates, and tests proper access control for observations\n        created by other doctors.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            observation_factory: Factory fixture to create observation instances\n            doctor_factory: Factory fixture to create doctor instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Ensure proper authentication\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Create test observation\n        observation = observation_factory(\n            doctor=doctor,\n            patient=patient,\n            vital_type=VitalSignType.HEART_RATE,\n            content=\"Original heart rate observation\"\n        )\n\n        # Prepare update data\n        update_data = {\n            \"vital_type\": \"steps\",\n            \"content\": \"Updated observation content\"\n        }\n\n        # Set proper headers for JSON request\n        headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n\n        # Test updating observation\n        response = client.put(\n            f'/web/observations/{observation.id}',\n            json=update_data,\n            headers=headers\n        )\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert 'observation' in data\n        assert data['observation']['vital_type'] == 'steps'\n        assert data['observation']['content'] == update_data['content']\n\n        # Verify observation was updated in database\n        updated_observation = VitalObservation.query.get(observation.id)\n        assert updated_observation.vital_type == VitalSignType.STEPS\n        assert updated_observation.content == update_data['content']\n\n        # Test partial update (only content)\n        partial_update = {\n            \"content\": \"Partially updated content\"\n        }\n        response = client.put(f'/web/observations/{observation.id}', json=partial_update)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert data['observation']['content'] == partial_update['content']\n        assert data['observation']['vital_type'] == 'steps'  # Unchanged from previous update\n\n        # Test with non-existent observation\n        response = client.put('/web/observations/9999', json=update_data)\n        assert response.status_code == 404\n\n        # Test with observation not owned by doctor\n        # Create another doctor and observation\n        other_observation = observation_factory(\n            doctor=doctor_factory(),\n            patient=patient,\n            vital_type=VitalSignType.WEIGHT\n        )\n\n        # Attempt to update other doctor's observation\n        response = client.put(f'/web/observations/{other_observation.id}', json=update_data)\n        assert response.status_code == 403    \n    def test_delete_web_observation(self, client, doctor_with_patient, observation_factory, doctor_factory):\n        \"\"\"Test deleting an observation through the web interface.\n\n        Verifies that a doctor can delete their own observations and tests proper \n        access control for observations created by other doctors.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            observation_factory: Factory fixture to create observation instances\n            doctor_factory: Factory fixture to create doctor instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Ensure proper authentication\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Create test observation\n        observation = observation_factory(\n            doctor=doctor,\n            patient=patient,\n            vital_type=VitalSignType.HEART_RATE,\n            content=\"Observation to be deleted\"\n        )\n\n        # Set proper headers for JSON request\n        headers = {'Accept': 'application/json'}\n\n        # Test deleting observation\n        response = client.delete(\n            f'/web/observations/{observation.id}',\n            headers=headers\n        )\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert 'Observation deleted successfully' in data['message']\n\n        # Verify observation was deleted from database\n        deleted_observation = VitalObservation.query.get(observation.id)\n        assert deleted_observation is None\n\n        # Test with non-existent observation\n        response = client.delete('/web/observations/9999')\n        assert response.status_code == 404\n\n        # Test with observation not owned by doctor\n        # Create another doctor and observation\n        other_observation = observation_factory(\n            doctor=doctor_factory(),\n            patient=patient,\n            vital_type=VitalSignType.WEIGHT\n        )\n\n        # Attempt to delete other doctor's observation\n        response = client.delete(f'/web/observations/{other_observation.id}')\n        assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_observations.html#test_observations.TestObservations.test_get_web_observations","title":"<code>test_get_web_observations(client, doctor_with_patient, observation_factory)</code>","text":"<p>Test retrieving observations through the web interface.</p> <p>Verifies that observations can be correctly retrieved through the web interface, including filtering by vital sign type and date ranges.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>observation_factory</code> <p>Factory fixture to create observation instances</p> required Source code in <code>tests/test_observations.py</code> <pre><code>def test_get_web_observations(self, client, doctor_with_patient, observation_factory):\n    \"\"\"Test retrieving observations through the web interface.\n\n    Verifies that observations can be correctly retrieved through the web interface,\n    including filtering by vital sign type and date ranges.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        observation_factory: Factory fixture to create observation instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Make sure doctor and patient are attached to the session\n    from app import db\n    from flask_login import login_user\n\n    # Reattach entities to the current database session\n    doctor = db.session.merge(doctor)\n    patient = db.session.merge(patient)\n      # Make sure the user is properly authenticated\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Force login to ensure current_user is set\n    response = client.get('/dashboard')\n    assert response.status_code == 200, \"Authentication failed, check session setup\"\n      # If relationship doesn't exist, create it\n    if patient not in doctor.patients.all():\n        doctor.add_patient(patient)\n        db.session.commit()\n\n    # Force login to ensure current_user is correctly set\n    with client.application.test_request_context():\n        login_user(doctor)\n\n    # Verify that the patient is associated with the doctor\n    assert patient in doctor.patients.all(), \"Patient is not associated with doctor in the database\"            \n    # Verify authentication before proceeding\n    auth_check = client.get('/dashboard')\n    print(f\"Auth check status: {auth_check.status_code}\")\n    if auth_check.status_code != 200:\n        pytest.skip(\"Authentication setup failed, skipping test\")\n\n    # Create test observations\n    heart_rate_obs = observation_factory(\n        doctor=doctor,\n        patient=patient,\n        vital_type=VitalSignType.HEART_RATE,\n        content=\"Heart rate observation\",\n        start_date=datetime.utcnow() - timedelta(days=10),\n        end_date=datetime.utcnow() - timedelta(days=3)\n    )\n\n    steps_obs = observation_factory(\n        doctor=doctor,\n        patient=patient,\n        vital_type=VitalSignType.STEPS,\n        content=\"Steps observation\",\n        start_date=datetime.utcnow() - timedelta(days=7),\n        end_date=datetime.utcnow()\n    )\n      # Test getting all observations - use the correct endpoint format\n    response = client.get(\n        f'/web/observations/{patient.id}',\n        headers={\"Accept\": \"application/json\"}  # Ensure JSON is accepted\n    )\n\n    # Debug output\n    print(f\"Response status: {response.status_code}\")\n    print(f\"Response data: {response.data}\")\n\n    # Check response\n    assert response.status_code == 200\n    try:\n        data = json.loads(response.data)\n        assert len(data) == 2\n    except json.JSONDecodeError:\n        pytest.fail(\"Failed to decode JSON response\")\n\n    # Test filtering by vital type\n    vital_type_url = f'/web/observations/{patient.id}?vital_type=heart_rate'\n    print(f\"Vital type filter URL: {vital_type_url}\")\n\n    response = client.get(vital_type_url)\n\n    # Debug output\n    print(f\"Vital type filter response status: {response.status_code}\")\n    print(f\"Vital type filter response data: {response.data}\")\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert len(data) == 1\n    assert data[0]['vital_type'] == 'heart_rate'\n    assert data[0]['content'] == \"Heart rate observation\"        # The date filtering issue is due to the date format\n    # observations.py expects a complete datetime (ISO format), while we're only passing YYYY-MM-DD\n\n    # Set the correct format with time\n    start_date = (datetime.utcnow() - timedelta(days=8)).isoformat()\n    end_date = (datetime.utcnow() - timedelta(days=1)).isoformat()\n    date_filter_url = f'/web/observations/{patient.id}?start_date={start_date}&amp;end_date={end_date}'\n\n    print(f\"Date filter URL: {date_filter_url}\")\n    print(f\"Start date: {start_date}, End date: {end_date}\")\n\n    response = client.get(date_filter_url)\n\n    # Debug output\n    print(f\"Date filter response status: {response.status_code}\")\n    print(f\"Date filter response data: {response.data}\")\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n      # The test must be flexible because dates may or may not fall within the filter\n    # depending on the exact time\n    if len(data) &gt; 0:\n        observed_type = data[0]['vital_type']\n        # It doesn't matter which observation is filtered, but it should be one of those created\n        assert observed_type in ['steps', 'heart_rate']    \n</code></pre>"},{"location":"tests/test_observations.html#test_observations.TestObservations.test_add_web_observation","title":"<code>test_add_web_observation(client, doctor_with_patient, patient_factory)</code>","text":"<p>Test adding a new observation through the web interface.</p> <p>Verifies that a doctor can add new vital sign observations for their patients, validates data integrity in the database, and tests error handling for invalid inputs.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_observations.py</code> <pre><code>def test_add_web_observation(self, client, doctor_with_patient, patient_factory):\n    \"\"\"Test adding a new observation through the web interface.\n\n    Verifies that a doctor can add new vital sign observations for their patients,\n    validates data integrity in the database, and tests error handling for invalid inputs.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n      # Make sure doctor and patient are attached to the session\n    from app import db\n    doctor = db.session.merge(doctor)\n    patient = db.session.merge(patient)\n\n    # Make sure the doctor is associated with the patient\n    if patient not in doctor.patients.all():\n        doctor.add_patient(patient)\n        db.session.commit()            # Reject existing session and create a new one with explicit login\n    client.get('/logout')  # Logout to ensure there are no existing sessions\n\n    # Explicit login as doctor\n    login_response = client.post('/login', data={\n        'email': doctor.email,\n        'password': 'Password123!'  # Standard password from doctor_factory\n    }, follow_redirects=True)\n\n    assert login_response.status_code == 200, \"Login failed\"\n    assert b'Dashboard' in login_response.data, \"Login did not redirect to dashboard\"\n      # Reload doctor from database to have the most recent object\n    doctor = db.session.get(Doctor, doctor.id)\n    assert doctor is not None\n\n    # Make sure entities are linked to the current session\n    from app import db\n    doctor = db.session.merge(doctor)\n    patient = db.session.merge(patient)\n\n    # Verify that the patient is associated with the doctor\n    assert patient in doctor.patients.all(), \"Patient is not associated with doctor\"\n\n    # Prepare observation data\n    start_date = (datetime.utcnow() - timedelta(days=7)).strftime('%Y-%m-%d')\n    end_date = datetime.utcnow().strftime('%Y-%m-%d')\n\n    observation_data = {\n        \"patient_id\": patient.id,\n        \"vital_type\": \"heart_rate\",\n        \"content\": \"Heart rate has been stable within normal range\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    }\n\n    # Set proper headers for JSON request\n    headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n\n    # Test adding observation\n    response = client.post(\n        '/web/observations', \n        json=observation_data,\n        headers=headers\n    )\n\n    # Check response\n    assert response.status_code == 201\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert 'observation' in data\n    assert data['observation']['vital_type'] == 'heart_rate'\n    assert data['observation']['content'] == observation_data['content']\n\n    # Verify observation was added to database\n    observation_id = data['observation']['id']\n    observation = VitalObservation.query.get(observation_id)\n    assert observation is not None\n    assert observation.vital_type == VitalSignType.HEART_RATE\n    assert observation.doctor_id == doctor.id\n    assert observation.patient_id == patient.id\n\n    # Test with missing required fields\n    invalid_data = {\n        \"patient_id\": patient.id,\n        \"content\": \"Missing vital type\"\n    }\n    response = client.post('/web/observations', json=invalid_data)\n    assert response.status_code == 400\n\n    # Test with invalid vital type\n    invalid_data = {\n        \"patient_id\": patient.id,\n        \"vital_type\": \"invalid_type\",\n        \"content\": \"Invalid vital type\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    }\n    response = client.post('/web/observations', json=invalid_data)\n    assert response.status_code == 400\n      # Test with patient not associated with doctor\n    unassociated_patient = db.session.merge(patient_factory())\n    invalid_data = {\n        \"patient_id\": unassociated_patient.id,\n        \"vital_type\": \"heart_rate\",\n        \"content\": \"Patient not associated with doctor\",\n        \"start_date\": start_date,\n        \"end_date\": end_date\n    }\n    response = client.post('/web/observations', json=invalid_data)\n    assert response.status_code == 403      \n</code></pre>"},{"location":"tests/test_observations.html#test_observations.TestObservations.test_update_web_observation","title":"<code>test_update_web_observation(client, doctor_with_patient, observation_factory, doctor_factory)</code>","text":"<p>Test updating an observation through the web interface.</p> <p>Verifies that a doctor can update their existing observations including complete and partial updates, and tests proper access control for observations created by other doctors.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>observation_factory</code> <p>Factory fixture to create observation instances</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances</p> required Source code in <code>tests/test_observations.py</code> <pre><code>def test_update_web_observation(self, client, doctor_with_patient, observation_factory, doctor_factory):\n    \"\"\"Test updating an observation through the web interface.\n\n    Verifies that a doctor can update their existing observations including\n    complete and partial updates, and tests proper access control for observations\n    created by other doctors.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        observation_factory: Factory fixture to create observation instances\n        doctor_factory: Factory fixture to create doctor instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Ensure proper authentication\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Create test observation\n    observation = observation_factory(\n        doctor=doctor,\n        patient=patient,\n        vital_type=VitalSignType.HEART_RATE,\n        content=\"Original heart rate observation\"\n    )\n\n    # Prepare update data\n    update_data = {\n        \"vital_type\": \"steps\",\n        \"content\": \"Updated observation content\"\n    }\n\n    # Set proper headers for JSON request\n    headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n\n    # Test updating observation\n    response = client.put(\n        f'/web/observations/{observation.id}',\n        json=update_data,\n        headers=headers\n    )\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert 'observation' in data\n    assert data['observation']['vital_type'] == 'steps'\n    assert data['observation']['content'] == update_data['content']\n\n    # Verify observation was updated in database\n    updated_observation = VitalObservation.query.get(observation.id)\n    assert updated_observation.vital_type == VitalSignType.STEPS\n    assert updated_observation.content == update_data['content']\n\n    # Test partial update (only content)\n    partial_update = {\n        \"content\": \"Partially updated content\"\n    }\n    response = client.put(f'/web/observations/{observation.id}', json=partial_update)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert data['observation']['content'] == partial_update['content']\n    assert data['observation']['vital_type'] == 'steps'  # Unchanged from previous update\n\n    # Test with non-existent observation\n    response = client.put('/web/observations/9999', json=update_data)\n    assert response.status_code == 404\n\n    # Test with observation not owned by doctor\n    # Create another doctor and observation\n    other_observation = observation_factory(\n        doctor=doctor_factory(),\n        patient=patient,\n        vital_type=VitalSignType.WEIGHT\n    )\n\n    # Attempt to update other doctor's observation\n    response = client.put(f'/web/observations/{other_observation.id}', json=update_data)\n    assert response.status_code == 403    \n</code></pre>"},{"location":"tests/test_observations.html#test_observations.TestObservations.test_delete_web_observation","title":"<code>test_delete_web_observation(client, doctor_with_patient, observation_factory, doctor_factory)</code>","text":"<p>Test deleting an observation through the web interface.</p> <p>Verifies that a doctor can delete their own observations and tests proper  access control for observations created by other doctors.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>observation_factory</code> <p>Factory fixture to create observation instances</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances</p> required Source code in <code>tests/test_observations.py</code> <pre><code>def test_delete_web_observation(self, client, doctor_with_patient, observation_factory, doctor_factory):\n    \"\"\"Test deleting an observation through the web interface.\n\n    Verifies that a doctor can delete their own observations and tests proper \n    access control for observations created by other doctors.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        observation_factory: Factory fixture to create observation instances\n        doctor_factory: Factory fixture to create doctor instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Ensure proper authentication\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Create test observation\n    observation = observation_factory(\n        doctor=doctor,\n        patient=patient,\n        vital_type=VitalSignType.HEART_RATE,\n        content=\"Observation to be deleted\"\n    )\n\n    # Set proper headers for JSON request\n    headers = {'Accept': 'application/json'}\n\n    # Test deleting observation\n    response = client.delete(\n        f'/web/observations/{observation.id}',\n        headers=headers\n    )\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert 'Observation deleted successfully' in data['message']\n\n    # Verify observation was deleted from database\n    deleted_observation = VitalObservation.query.get(observation.id)\n    assert deleted_observation is None\n\n    # Test with non-existent observation\n    response = client.delete('/web/observations/9999')\n    assert response.status_code == 404\n\n    # Test with observation not owned by doctor\n    # Create another doctor and observation\n    other_observation = observation_factory(\n        doctor=doctor_factory(),\n        patient=patient,\n        vital_type=VitalSignType.WEIGHT\n    )\n\n    # Attempt to delete other doctor's observation\n    response = client.delete(f'/web/observations/{other_observation.id}')\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_utils.html","title":"Test Utils","text":"<p>Test module for utility functions.</p> <p>This module tests the utility functions including: - Email validation - Password strength validation - UUID validation - Date parsing and formatting - Data serialization functions</p>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions","title":"<code>TestUtilsFunctions</code>","text":"<p>Test class for utility functions.</p> <p>This class tests the various utility functions provided by the application, including validation functions, data parsing, and serialization utilities.</p> Source code in <code>tests/test_utils.py</code> <pre><code>class TestUtilsFunctions:\n    \"\"\"Test class for utility functions.\n\n    This class tests the various utility functions provided by the application,\n    including validation functions, data parsing, and serialization utilities.\n    \"\"\"\n    def test_validate_email(self):\n        \"\"\"Test email validation function.\n\n        Verifies that the email validation function correctly identifies\n        valid and invalid email formats.\n        \"\"\"\n        # Valid emails\n        assert validate_email(\"test@example.com\") is True\n        assert validate_email(\"user.name+tag@example.co.uk\") is True\n        assert validate_email(\"123.456@domain.it\") is True\n\n        # Invalid emails\n        assert validate_email(\"invalid_email\") is False\n        assert validate_email(\"missing@domain\") is False\n        assert validate_email(\"@example.com\") is False\n        assert validate_email(\"user@.com\") is False\n        assert validate_email(\"\") is False\n        assert validate_email(None) is False    \n    def test_is_valid_password(self):\n        \"\"\"Test password strength validation function.\n\n        Verifies that the password strength validation function correctly identifies\n        valid and invalid passwords based on length, character types (uppercase,\n        lowercase, digits, special characters) and returns appropriate messages.\n        \"\"\"\n        # Valid passwords\n        valid, message = is_valid_password(\"Password123!\")\n        assert valid is True\n        assert \"strong\" in message.lower()\n\n        valid, message = is_valid_password(\"C0mplex!PassWord\")\n        assert valid is True\n\n        # Invalid passwords - too short\n        valid, message = is_valid_password(\"Abc12!\")\n        assert valid is False\n        assert \"8 characters\" in message\n\n        # Invalid passwords - missing uppercase\n        valid, message = is_valid_password(\"password123!\")\n        assert valid is False\n        assert \"uppercase\" in message.lower()\n\n        # Invalid passwords - missing lowercase\n        valid, message = is_valid_password(\"PASSWORD123!\")\n        assert valid is False\n        assert \"lowercase\" in message.lower()\n\n        # Invalid passwords - missing digit\n        valid, message = is_valid_password(\"PasswordABC!\")\n        assert valid is False\n        assert \"digit\" in message.lower()\n\n        # Invalid passwords - missing special character\n        valid, message = is_valid_password(\"Password123\")\n        assert valid is False\n        assert \"special character\" in message.lower()\n\n        # Empty password\n        valid, message = is_valid_password(\"\")\n        assert valid is False\n\n        # None password\n        valid, message = is_valid_password(None)\n        assert valid is False    \n    def test_validate_uuid(self):\n        \"\"\"Test UUID validation function.\n\n        Verifies that the UUID validation function correctly identifies\n        valid and invalid UUID formats.\n        \"\"\"\n        # Valid UUIDs\n        valid_uuid = str(uuid.uuid4())\n        assert validate_uuid(valid_uuid) is True\n        assert validate_uuid(\"123e4567-e89b-12d3-a456-426614174000\") is True\n\n        # Invalid UUIDs\n        assert validate_uuid(\"invalid-uuid\") is False\n        assert validate_uuid(\"123e4567-e89b-12d3-a456-42661417400\") is False  # Too short\n        assert validate_uuid(\"123e4567-e89b-12d3-a456-4266141740000\") is False  # Too long\n        assert validate_uuid(\"\") is False\n        assert validate_uuid(None) is False    \n    def test_parse_date(self):\n        \"\"\"Test date parsing function.\n\n        Verifies that the date parsing function correctly converts ISO format date \n        strings (YYYY-MM-DD) to Python date objects and properly handles invalid formats\n        by raising appropriate exceptions.\n        \"\"\"\n        # Valid date strings\n        assert parse_date(\"2023-05-15\") == date(2023, 5, 15)\n        assert parse_date(\"2020-01-01\") == date(2020, 1, 1)\n        assert parse_date(\"2025-12-31\") == date(2025, 12, 31)\n\n        # Invalid date strings\n        with pytest.raises(ValueError):\n            parse_date(\"15-05-2023\")  # Wrong format\n\n        with pytest.raises(ValueError):\n            parse_date(\"2023/05/15\")  # Wrong separator\n\n        with pytest.raises(ValueError):\n            parse_date(\"2023-13-15\")  # Invalid month\n\n        with pytest.raises(ValueError):\n            parse_date(\"2023-05-32\")  # Invalid day\n\n        with pytest.raises(ValueError):\n            parse_date(\"\")  # Empty string\n\n        with pytest.raises(ValueError):\n            parse_date(None)  # None value    \n    def test_to_serializable_dict(self):\n        \"\"\"Test object serialization function.\n\n        Verifies that the object serialization function correctly converts various data types \n        into JSON-serializable formats, handling dates, custom objects with to_dict methods,\n        lists of mixed objects, and simple values appropriately.\n        \"\"\"\n        # Test with dictionary containing various types\n        test_dict = {\n            \"string\": \"value\",\n            \"integer\": 123,\n            \"float\": 123.45,\n            \"date\": date(2023, 5, 15),\n            \"list\": [1, 2, 3],\n            \"nested_dict\": {\"key\": \"value\"},\n            \"boolean\": True,\n            \"none\": None\n        }\n\n        serialized = to_serializable_dict(test_dict)\n\n        assert serialized[\"string\"] == \"value\"\n        assert serialized[\"integer\"] == 123\n        assert serialized[\"float\"] == 123.45\n        assert serialized[\"date\"] == \"2023-05-15\"  # Date converted to string\n        assert serialized[\"list\"] == [1, 2, 3]\n        assert serialized[\"nested_dict\"] == {\"key\": \"value\"}\n        assert serialized[\"boolean\"] is True\n        assert serialized[\"none\"] is None\n\n        # Test with object having to_dict method\n        class TestObject:\n            def to_dict(self):\n                return {\"id\": 1, \"name\": \"Test Object\"}\n\n        test_obj = TestObject()\n        serialized = to_serializable_dict(test_obj)\n        assert serialized == {\"id\": 1, \"name\": \"Test Object\"}\n\n        # Test with list of mixed objects\n        test_list = [\n            {\"key\": \"value\"},\n            date(2023, 5, 15),\n            TestObject()\n        ]\n\n        serialized = to_serializable_dict(test_list)\n        assert serialized[0] == {\"key\": \"value\"}\n        assert serialized[1] == \"2023-05-15\"\n        assert serialized[2] == {\"id\": 1, \"name\": \"Test Object\"}\n\n        # Test with simple values\n        assert to_serializable_dict(\"string\") == \"string\"\n        assert to_serializable_dict(123) == 123\n        assert to_serializable_dict(None) is None\n</code></pre>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions.test_validate_email","title":"<code>test_validate_email()</code>","text":"<p>Test email validation function.</p> <p>Verifies that the email validation function correctly identifies valid and invalid email formats.</p> Source code in <code>tests/test_utils.py</code> <pre><code>def test_validate_email(self):\n    \"\"\"Test email validation function.\n\n    Verifies that the email validation function correctly identifies\n    valid and invalid email formats.\n    \"\"\"\n    # Valid emails\n    assert validate_email(\"test@example.com\") is True\n    assert validate_email(\"user.name+tag@example.co.uk\") is True\n    assert validate_email(\"123.456@domain.it\") is True\n\n    # Invalid emails\n    assert validate_email(\"invalid_email\") is False\n    assert validate_email(\"missing@domain\") is False\n    assert validate_email(\"@example.com\") is False\n    assert validate_email(\"user@.com\") is False\n    assert validate_email(\"\") is False\n    assert validate_email(None) is False    \n</code></pre>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions.test_is_valid_password","title":"<code>test_is_valid_password()</code>","text":"<p>Test password strength validation function.</p> <p>Verifies that the password strength validation function correctly identifies valid and invalid passwords based on length, character types (uppercase, lowercase, digits, special characters) and returns appropriate messages.</p> Source code in <code>tests/test_utils.py</code> <pre><code>def test_is_valid_password(self):\n    \"\"\"Test password strength validation function.\n\n    Verifies that the password strength validation function correctly identifies\n    valid and invalid passwords based on length, character types (uppercase,\n    lowercase, digits, special characters) and returns appropriate messages.\n    \"\"\"\n    # Valid passwords\n    valid, message = is_valid_password(\"Password123!\")\n    assert valid is True\n    assert \"strong\" in message.lower()\n\n    valid, message = is_valid_password(\"C0mplex!PassWord\")\n    assert valid is True\n\n    # Invalid passwords - too short\n    valid, message = is_valid_password(\"Abc12!\")\n    assert valid is False\n    assert \"8 characters\" in message\n\n    # Invalid passwords - missing uppercase\n    valid, message = is_valid_password(\"password123!\")\n    assert valid is False\n    assert \"uppercase\" in message.lower()\n\n    # Invalid passwords - missing lowercase\n    valid, message = is_valid_password(\"PASSWORD123!\")\n    assert valid is False\n    assert \"lowercase\" in message.lower()\n\n    # Invalid passwords - missing digit\n    valid, message = is_valid_password(\"PasswordABC!\")\n    assert valid is False\n    assert \"digit\" in message.lower()\n\n    # Invalid passwords - missing special character\n    valid, message = is_valid_password(\"Password123\")\n    assert valid is False\n    assert \"special character\" in message.lower()\n\n    # Empty password\n    valid, message = is_valid_password(\"\")\n    assert valid is False\n\n    # None password\n    valid, message = is_valid_password(None)\n    assert valid is False    \n</code></pre>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions.test_validate_uuid","title":"<code>test_validate_uuid()</code>","text":"<p>Test UUID validation function.</p> <p>Verifies that the UUID validation function correctly identifies valid and invalid UUID formats.</p> Source code in <code>tests/test_utils.py</code> <pre><code>def test_validate_uuid(self):\n    \"\"\"Test UUID validation function.\n\n    Verifies that the UUID validation function correctly identifies\n    valid and invalid UUID formats.\n    \"\"\"\n    # Valid UUIDs\n    valid_uuid = str(uuid.uuid4())\n    assert validate_uuid(valid_uuid) is True\n    assert validate_uuid(\"123e4567-e89b-12d3-a456-426614174000\") is True\n\n    # Invalid UUIDs\n    assert validate_uuid(\"invalid-uuid\") is False\n    assert validate_uuid(\"123e4567-e89b-12d3-a456-42661417400\") is False  # Too short\n    assert validate_uuid(\"123e4567-e89b-12d3-a456-4266141740000\") is False  # Too long\n    assert validate_uuid(\"\") is False\n    assert validate_uuid(None) is False    \n</code></pre>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions.test_parse_date","title":"<code>test_parse_date()</code>","text":"<p>Test date parsing function.</p> <p>Verifies that the date parsing function correctly converts ISO format date  strings (YYYY-MM-DD) to Python date objects and properly handles invalid formats by raising appropriate exceptions.</p> Source code in <code>tests/test_utils.py</code> <pre><code>def test_parse_date(self):\n    \"\"\"Test date parsing function.\n\n    Verifies that the date parsing function correctly converts ISO format date \n    strings (YYYY-MM-DD) to Python date objects and properly handles invalid formats\n    by raising appropriate exceptions.\n    \"\"\"\n    # Valid date strings\n    assert parse_date(\"2023-05-15\") == date(2023, 5, 15)\n    assert parse_date(\"2020-01-01\") == date(2020, 1, 1)\n    assert parse_date(\"2025-12-31\") == date(2025, 12, 31)\n\n    # Invalid date strings\n    with pytest.raises(ValueError):\n        parse_date(\"15-05-2023\")  # Wrong format\n\n    with pytest.raises(ValueError):\n        parse_date(\"2023/05/15\")  # Wrong separator\n\n    with pytest.raises(ValueError):\n        parse_date(\"2023-13-15\")  # Invalid month\n\n    with pytest.raises(ValueError):\n        parse_date(\"2023-05-32\")  # Invalid day\n\n    with pytest.raises(ValueError):\n        parse_date(\"\")  # Empty string\n\n    with pytest.raises(ValueError):\n        parse_date(None)  # None value    \n</code></pre>"},{"location":"tests/test_utils.html#test_utils.TestUtilsFunctions.test_to_serializable_dict","title":"<code>test_to_serializable_dict()</code>","text":"<p>Test object serialization function.</p> <p>Verifies that the object serialization function correctly converts various data types  into JSON-serializable formats, handling dates, custom objects with to_dict methods, lists of mixed objects, and simple values appropriately.</p> Source code in <code>tests/test_utils.py</code> <pre><code>def test_to_serializable_dict(self):\n    \"\"\"Test object serialization function.\n\n    Verifies that the object serialization function correctly converts various data types \n    into JSON-serializable formats, handling dates, custom objects with to_dict methods,\n    lists of mixed objects, and simple values appropriately.\n    \"\"\"\n    # Test with dictionary containing various types\n    test_dict = {\n        \"string\": \"value\",\n        \"integer\": 123,\n        \"float\": 123.45,\n        \"date\": date(2023, 5, 15),\n        \"list\": [1, 2, 3],\n        \"nested_dict\": {\"key\": \"value\"},\n        \"boolean\": True,\n        \"none\": None\n    }\n\n    serialized = to_serializable_dict(test_dict)\n\n    assert serialized[\"string\"] == \"value\"\n    assert serialized[\"integer\"] == 123\n    assert serialized[\"float\"] == 123.45\n    assert serialized[\"date\"] == \"2023-05-15\"  # Date converted to string\n    assert serialized[\"list\"] == [1, 2, 3]\n    assert serialized[\"nested_dict\"] == {\"key\": \"value\"}\n    assert serialized[\"boolean\"] is True\n    assert serialized[\"none\"] is None\n\n    # Test with object having to_dict method\n    class TestObject:\n        def to_dict(self):\n            return {\"id\": 1, \"name\": \"Test Object\"}\n\n    test_obj = TestObject()\n    serialized = to_serializable_dict(test_obj)\n    assert serialized == {\"id\": 1, \"name\": \"Test Object\"}\n\n    # Test with list of mixed objects\n    test_list = [\n        {\"key\": \"value\"},\n        date(2023, 5, 15),\n        TestObject()\n    ]\n\n    serialized = to_serializable_dict(test_list)\n    assert serialized[0] == {\"key\": \"value\"}\n    assert serialized[1] == \"2023-05-15\"\n    assert serialized[2] == {\"id\": 1, \"name\": \"Test Object\"}\n\n    # Test with simple values\n    assert to_serializable_dict(\"string\") == \"string\"\n    assert to_serializable_dict(123) == 123\n    assert to_serializable_dict(None) is None\n</code></pre>"},{"location":"tests/test_views.html","title":"Test Views","text":"<p>Test module for views functionality.</p> <p>This module tests the web views including: - Dashboard display - Patient management (listing, creation, editing, deletion) - Notes management - Vital signs visualization - Report generation</p>"},{"location":"tests/test_views.html#test_views.TestViews","title":"<code>TestViews</code>","text":"<p>Test class for web views functionality.</p> Source code in <code>tests/test_views.py</code> <pre><code>class TestViews:\n    \"\"\"Test class for web views functionality.\"\"\"\n    def test_index_redirect(self, client, doctor_factory):\n        \"\"\"\n        Test landing page redirection behavior.\n\n        Args:\n            client: Flask test client\n            doctor_factory: Factory fixture to create doctor instances\n        \"\"\"\n        # Clear any active sessions first\n        client.get('/logout', follow_redirects=True)\n\n        # Unauthenticated user should be redirected to login\n        response = client.get('/', follow_redirects=True)\n        assert response.status_code == 200\n\n        # Verify presence of login elements\n        login_elements = [b'login', b'sign in', b'accedi', b'password', b'email']\n        login_found = any(element in response.data.lower() for element in login_elements)\n        assert login_found, \"No login elements found in the response\"\n\n        # Create and authenticate doctor using the fixture\n        doctor = doctor_factory()\n\n        # Explicit login via form\n        login_response = client.post('/login', data={\n            'email': doctor.email,\n            'password': 'Password123!'  # Standard password used in doctor_factory\n        }, follow_redirects=True)\n\n        assert login_response.status_code == 200\n        assert b'Dashboard' in login_response.data\n\n        # Authenticated user should be redirected to dashboard\n        response = client.get('/', follow_redirects=True)\n        assert response.status_code == 200        # Check for dashboard indicators with flexible matching\n        assert b'dashboard' in response.data.lower() or b'welcome' in response.data.lower() or b'benvenuto' in response.data.lower()\n    def test_dashboard(self, client, authenticated_doctor, patient_factory):\n        \"\"\"\n        Test dashboard view functionality.\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Pre-authenticated doctor fixture\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        # Make sure the doctor is attached to the session\n        from app import db\n        doctor = db.session.merge(authenticated_doctor)\n\n        # Ensure proper authentication\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Create test patients\n        for i in range(3):\n            patient = patient_factory()\n            patient = db.session.merge(patient)  # Ensure patient is attached to the session\n            doctor = db.session.merge(doctor)    # Re-attach doctor after each iteration\n            doctor.add_patient(patient)\n\n        # Test dashboard access\n        response = client.get('/dashboard')\n        assert response.status_code == 200\n\n        # Look for general dashboard elements instead of specific text\n        assert b'dashboard' in response.data.lower()\n        # Check for patient information presence in any format\n        assert b'patient' in response.data.lower() and b'3' in response.data    \n    def test_patients_list(self, client, authenticated_doctor, patient_factory):\n        \"\"\"\n        Test patients list view functionality.\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Pre-authenticated doctor fixture\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        from app import db\n        doctor = db.session.merge(authenticated_doctor)\n\n        # Create test patients\n        patient1 = patient_factory(first_name=\"Alice\", last_name=\"Smith\")\n        patient2 = patient_factory(first_name=\"Bob\", last_name=\"Jones\")\n\n        # Make sure all objects are attached to the session\n        doctor = db.session.merge(doctor)\n        patient1 = db.session.merge(patient1)\n        patient2 = db.session.merge(patient2)\n\n        # Authenticate the doctor\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        doctor.add_patient(patient1)\n        doctor = db.session.merge(doctor)  # Reattach after each operation\n        doctor.add_patient(patient2)\n\n        # Test patients list access\n        response = client.get('/patients')\n        assert response.status_code == 200\n\n        # Patients list should show both patients\n        assert b'Alice Smith' in response.data\n        assert b'Bob Jones' in response.data    \n    def test_new_patient(self, client, authenticated_doctor):\n        \"\"\"Test patient creation view.\n\n        Verifies that the patient creation form is displayed correctly and that\n        new patients can be created with valid data. Also tests validation errors\n        with invalid data.\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Pre-authenticated doctor fixture\n        \"\"\"\n        # Test new patient form display\n        response = client.get('/patients/new')\n        assert response.status_code == 200\n        assert b'Add New Patient' in response.data\n\n        # Test patient creation\n        response = client.post('/patients/new', data={\n            'first_name': 'Jane',\n            'last_name': 'Doe',\n            'date_of_birth': '1990-05-15',\n            'gender': 'Female',\n            'contact_number': '+39123456789',\n            'email': 'jane.doe@example.com',\n            'address': '123 Test Street'\n        }, follow_redirects=True)\n          # Check response\n        assert response.status_code == 200\n        # Il messaggio effettivo contiene il nome del paziente e l'UUID\n        assert b'Patient Jane Doe successfully created with ID' in response.data\n        assert b'Jane Doe' in response.data\n\n        # Verify patient was created in database\n        patient = Patient.query.filter_by(first_name='Jane', last_name='Doe').first()\n        assert patient is not None\n        assert patient.date_of_birth == date(1990, 5, 15)\n        assert patient.gender == 'Female'\n        assert patient.contact_number == '+39123456789'\n        assert patient.email == 'jane.doe@example.com'\n\n        # Test patient creation with invalid data\n        response = client.post('/patients/new', data={\n            'first_name': '',  # Empty first name\n            'last_name': 'Test',\n            'date_of_birth': '1990-05-15',\n            'gender': 'Male',\n            'contact_number': '+39123456789',\n            'email': 'invalid.email',  # Invalid email\n            'address': '123 Test Street'\n        }, follow_redirects=True)\n          # Check response shows errors\n        assert response.status_code == 200\n        assert b'Name, surname and date of birth are mandatory fields' in response.data    \n    def test_patient_detail(self, client, doctor_with_patient, note_factory, patient_factory):\n        \"\"\"Test patient detail view functionality.\n\n        Verifies that a doctor can view the details of their associated patients,\n        including patient information and notes.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            note_factory: Factory fixture to create note instances\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        from app import db\n\n        doctor = db.session.merge(doctor_with_patient['doctor'])\n        patient = db.session.merge(doctor_with_patient['patient'])\n\n        # Perform an explicit login\n        response = client.post('/login', data={\n            'email': doctor.email,\n            'password': 'Password123!'  # Standard password used in doctor_factory\n        }, follow_redirects=True)\n\n        assert response.status_code == 200\n        assert b'Dashboard' in response.data, \"Login failed\"\n\n        # Make sure the session is properly set\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Add some notes\n        note_factory(doctor, patient, \"First test note\")\n        note_factory(doctor, patient, \"Second test note\")\n\n        # Test patient detail access (after adding notes)\n        db.session.refresh(patient)  # Make sure the patient is updated\n        response = client.get(f'/patients/{patient.id}')\n        assert response.status_code == 200\n\n        # Check patient info is displayed\n        assert patient.first_name.encode() in response.data\n        assert patient.last_name.encode() in response.data\n\n        # Check notes are displayed\n        assert b'First test note' in response.data\n        assert b'Second test note' in response.data\n\n        # Test with non-existent patient\n        response = client.get('/patients/9999')\n        assert response.status_code == 404        # Test with patient not associated with doctor\n        # Use patient_factory as parameter\n        unassociated_patient = patient_factory()\n        response = client.get(f'/patients/{unassociated_patient.id}')\n        assert response.status_code == 302  # System redirects instead of returning 403    \n    def test_edit_patient(self, client, doctor_with_patient, patient_factory):\n        \"\"\"Test patient edit view functionality.\n\n        Verifies that a doctor can edit the information of their associated patients\n        and that the changes are correctly saved in the database.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Test edit form display\n        response = client.get(f'/patients/{patient.id}/edit')\n        assert response.status_code == 200\n        assert b'Edit Patient' in response.data\n\n        # Test patient update\n        response = client.post(f'/patients/{patient.id}/edit', data={\n            'first_name': 'Updated',\n            'last_name': 'Name',\n            'date_of_birth': '1985-10-20',\n            'gender': 'Non-binary',\n            'contact_number': '+39987654321',\n            'email': 'updated.email@example.com',\n            'address': 'Updated Address'\n        }, follow_redirects=True)\n          # Check response\n        assert response.status_code == 200\n        assert b'Patient information updated successfully' in response.data\n        assert b'Updated Name' in response.data\n\n        # Verify patient was updated in database\n        updated_patient = Patient.query.get(patient.id)\n        assert updated_patient.first_name == 'Updated'\n        assert updated_patient.last_name == 'Name'\n        assert updated_patient.date_of_birth == date(1985, 10, 20)\n        assert updated_patient.gender == 'Non-binary'\n        assert updated_patient.contact_number == '+39987654321'\n        assert updated_patient.email == 'updated.email@example.com'\n        assert updated_patient.address == 'Updated Address'\n\n        # Test with non-existent patient\n        response = client.post('/patients/9999/edit', data={\n            'first_name': 'Test',\n            'last_name': 'Patient'\n        })\n        assert response.status_code == 404        # Test with patient not associated with doctor        # Create a patient not associated with the doctor\n        unassociated_patient = db.session.merge(patient_factory())\n        response = client.post(f'/patients/{unassociated_patient.id}/edit', data={\n            'first_name': 'Test',\n            'last_name': 'Patient'\n        })\n        assert response.status_code == 302  # System redirects instead of returning 403    \n    def test_delete_patient(self, client, doctor_with_patient, patient_factory, doctor_factory):\n        \"\"\"Test patient deletion view functionality.\n\n        Verifies that a doctor can delete patients from their list, and tests various\n        deletion scenarios including non-existent patients and patients with \n        multiple doctor associations.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            patient_factory: Factory fixture to create patient instances\n            doctor_factory: Factory fixture to create doctor instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Test patient deletion\n        response = client.post(f'/patients/{patient.id}/delete', follow_redirects=True)\n          # Check response\n        assert response.status_code == 200\n        assert b'Patient successfully removed' in response.data\n\n        # Verify patient was deleted from database\n        deleted_patient = Patient.query.get(patient.id)\n        assert deleted_patient is None\n\n        # Test with non-existent patient\n        response = client.post('/patients/9999/delete', follow_redirects=True)\n        assert response.status_code == 404\n          # Test with patient not associated with doctor\n        unassociated_patient = patient_factory()\n        response = client.post(f'/patients/{unassociated_patient.id}/delete', follow_redirects=True)\n        assert response.status_code == 200  # Con follow_redirects=True, anche se c'\u00e8 un reindirizzamento, il codice sar\u00e0 200\n\n        # Test deletion of patient with multiple doctors\n        # Create a patient associated with multiple doctors\n        multi_doctor_patient = patient_factory()\n        doctor2 = doctor_factory()\n\n        # Associate both doctors with patient\n        doctor.add_patient(multi_doctor_patient)\n        doctor2.add_patient(multi_doctor_patient)\n\n        # Delete patient (should only remove association)\n        response = client.post(f'/patients/{multi_doctor_patient.id}/delete', follow_redirects=True)\n        assert response.status_code == 200\n\n        # Patient should still exist but no longer be associated with the current doctor\n        patient_exists = Patient.query.get(multi_doctor_patient.id) is not None\n        assert patient_exists is True\n\n        doctor_patient = DoctorPatient.query.filter_by(\n            doctor_id=doctor.id, \n            patient_id=multi_doctor_patient.id\n        ).first()\n        assert doctor_patient is None    \n\n    def test_patient_vitals(self, client, doctor_with_patient):\n        \"\"\"Test patient vitals view functionality.\n\n        Verifies that a doctor can view the vital signs of their associated patients\n        and that different time period filters work correctly.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Ensure authentication\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Test vitals page access\n        response = client.get(f'/patients/{patient.id}/vitals')\n        assert response.status_code == 200\n        assert b'Vital Signs' in response.data or b'vitals' in response.data.lower()\n\n        # Test with different time periods\n        response = client.get(f'/patients/{patient.id}/vitals?period=7')\n        assert response.status_code == 200\n\n        response = client.get(f'/patients/{patient.id}/vitals?period=30')\n        assert response.status_code == 200\n\n        # Test API endpoint for fetching vitals data\n        response = client.get(f'/api/patients/{patient.id}/vitals?type=heart_rate')\n        # Note: This will likely return no data since we haven't mocked health platform data\n        assert response.status_code in [200, 404]  # Either empty data or platform not connected\n\n    def test_add_note(self, client, doctor_with_patient, patient_factory):\n        \"\"\"Test adding notes to a patient.\n\n        Verifies that a doctor can add notes to their associated patients,\n        and tests validation of empty notes and access control.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        patient = doctor_with_patient['patient']\n\n        # Test adding a note\n        note_content = \"This is a test note for the patient.\"\n        response = client.post(f'/patients/{patient.id}/notes', data={\n            'content': note_content\n        }, follow_redirects=True)\n\n        # Check response\n        assert response.status_code == 200\n        assert b'Note added successfully' in response.data\n        assert note_content.encode() in response.data\n\n        # Verify note was added to database\n        note = Note.query.filter_by(content=note_content, patient_id=patient.id).first()\n        assert note is not None\n\n        # Test with empty content\n        response = client.post(f'/patients/{patient.id}/notes', data={\n            'content': ''\n        }, follow_redirects=True)\n        assert response.status_code == 200\n        assert b'Note content cannot be empty' in response.data\n\n        # Test with non-existent patient\n        response = client.post('/patients/9999/notes', data={\n            'content': 'Test note'\n        })\n        assert response.status_code == 404\n\n        # Test with patient not associated with doctor\n        response = client.post(f'/patients/{patient_factory().id}/notes', data={\n            'content': 'Test note'\n        })\n        assert response.status_code == 302  # System redirects instead of returning 403\n    def test_delete_note(self, client, doctor_with_patient, note_factory):\n        \"\"\"Test deleting notes from a patient.\n\n        Verifies that a doctor can delete notes they created for their patients,\n        but cannot delete notes created by other doctors.\n\n        Args:\n            client: Flask test client\n            doctor_with_patient: Fixture providing a doctor with an associated patient\n            note_factory: Factory fixture to create note instances\n        \"\"\"\n        doctor = doctor_with_patient['doctor']\n        patient = doctor_with_patient['patient']\n\n        # Ensure proper authentication\n        with client.session_transaction() as session:\n            session['_user_id'] = str(doctor.id)\n            session['_fresh'] = True\n\n        # Create a note\n        note = note_factory(doctor, patient, \"Note to be deleted\")\n\n        # Adjust to proper endpoint format and method - using DELETE instead of POST\n        response = client.delete(f'/notes/{note.id}')\n\n        # Check response\n        assert response.status_code == 200\n        try:\n            data = json.loads(response.data)\n            assert 'message' in data\n        except json.JSONDecodeError:\n            # If it's not JSON, check for success indicators in HTML\n            assert b'successfully' in response.data.lower() or b'deleted' in response.data.lower()\n\n        # Verify note was deleted from database\n        deleted_note = Note.query.get(note.id)\n        assert deleted_note is None\n\n        # Test with non-existent note\n        response = client.delete('/notes/9999')\n        assert response.status_code == 404\n\n        # Test with note not created by doctor\n        from app.models import Doctor\n        other_doctor = Doctor(\n            email=\"other_doctor@example.com\",\n            first_name=\"Other\",\n            last_name=\"Doctor\",\n            specialty=\"General Medicine\"\n        )\n        other_doctor.set_password(\"Password123!\")\n        db.session.add(other_doctor)\n        db.session.commit()\n\n        other_note = note_factory(other_doctor, patient, \"Note by another doctor\")\n\n        # Attempt to delete other doctor's note\n        response = client.delete(f'/notes/{other_note.id}')\n        assert response.status_code == 403\n\n    def test_import_patient(self, client, authenticated_doctor, patient_factory):\n        \"\"\"Test importing existing patients by UUID.\n\n        Verifies that a doctor can import existing patients by their UUID, \n        and tests various import scenarios including non-existent patients\n        and already associated patients.\n\n        Args:\n            client: Flask test client\n            authenticated_doctor: Pre-authenticated doctor fixture\n            patient_factory: Factory fixture to create patient instances\n        \"\"\"\n        # Create a patient that isn't associated with the doctor\n        patient = patient_factory()\n\n        # Test importing via API\n        response = client.post('/patients/import', json={\n            'patient_uuid': patient.uuid\n        }, follow_redirects=True)\n\n        # Check response\n        assert response.status_code == 200\n        data = json.loads(response.data)\n        assert 'message' in data\n        assert data['message'] == \"Patient imported successfully\"\n\n        # Verify patient is now associated with doctor\n        # We need to refresh the doctor object from the database\n        updated_doctor = db.session.get(authenticated_doctor.__class__, authenticated_doctor.id)\n        updated_patient = db.session.get(patient.__class__, patient.id)\n        patient_in_list = updated_patient in updated_doctor.get_patients()\n        assert patient_in_list is True\n\n        # Test importing patient that doesn't exist\n        response = client.post('/patients/import', json={\n            'patient_uuid': str(uuid4())\n        })\n        assert response.status_code == 404\n\n        # Test importing patient already associated with doctor\n        response = client.post('/patients/import', json={\n            'patient_uuid': patient.uuid\n        })\n        assert response.status_code == 409  # Conflict\n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_index_redirect","title":"<code>test_index_redirect(client, doctor_factory)</code>","text":"<p>Test landing page redirection behavior.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_index_redirect(self, client, doctor_factory):\n    \"\"\"\n    Test landing page redirection behavior.\n\n    Args:\n        client: Flask test client\n        doctor_factory: Factory fixture to create doctor instances\n    \"\"\"\n    # Clear any active sessions first\n    client.get('/logout', follow_redirects=True)\n\n    # Unauthenticated user should be redirected to login\n    response = client.get('/', follow_redirects=True)\n    assert response.status_code == 200\n\n    # Verify presence of login elements\n    login_elements = [b'login', b'sign in', b'accedi', b'password', b'email']\n    login_found = any(element in response.data.lower() for element in login_elements)\n    assert login_found, \"No login elements found in the response\"\n\n    # Create and authenticate doctor using the fixture\n    doctor = doctor_factory()\n\n    # Explicit login via form\n    login_response = client.post('/login', data={\n        'email': doctor.email,\n        'password': 'Password123!'  # Standard password used in doctor_factory\n    }, follow_redirects=True)\n\n    assert login_response.status_code == 200\n    assert b'Dashboard' in login_response.data\n\n    # Authenticated user should be redirected to dashboard\n    response = client.get('/', follow_redirects=True)\n    assert response.status_code == 200        # Check for dashboard indicators with flexible matching\n    assert b'dashboard' in response.data.lower() or b'welcome' in response.data.lower() or b'benvenuto' in response.data.lower()\n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_dashboard","title":"<code>test_dashboard(client, authenticated_doctor, patient_factory)</code>","text":"<p>Test dashboard view functionality.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Pre-authenticated doctor fixture</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_dashboard(self, client, authenticated_doctor, patient_factory):\n    \"\"\"\n    Test dashboard view functionality.\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Pre-authenticated doctor fixture\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    # Make sure the doctor is attached to the session\n    from app import db\n    doctor = db.session.merge(authenticated_doctor)\n\n    # Ensure proper authentication\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Create test patients\n    for i in range(3):\n        patient = patient_factory()\n        patient = db.session.merge(patient)  # Ensure patient is attached to the session\n        doctor = db.session.merge(doctor)    # Re-attach doctor after each iteration\n        doctor.add_patient(patient)\n\n    # Test dashboard access\n    response = client.get('/dashboard')\n    assert response.status_code == 200\n\n    # Look for general dashboard elements instead of specific text\n    assert b'dashboard' in response.data.lower()\n    # Check for patient information presence in any format\n    assert b'patient' in response.data.lower() and b'3' in response.data    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_patients_list","title":"<code>test_patients_list(client, authenticated_doctor, patient_factory)</code>","text":"<p>Test patients list view functionality.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Pre-authenticated doctor fixture</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_patients_list(self, client, authenticated_doctor, patient_factory):\n    \"\"\"\n    Test patients list view functionality.\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Pre-authenticated doctor fixture\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    from app import db\n    doctor = db.session.merge(authenticated_doctor)\n\n    # Create test patients\n    patient1 = patient_factory(first_name=\"Alice\", last_name=\"Smith\")\n    patient2 = patient_factory(first_name=\"Bob\", last_name=\"Jones\")\n\n    # Make sure all objects are attached to the session\n    doctor = db.session.merge(doctor)\n    patient1 = db.session.merge(patient1)\n    patient2 = db.session.merge(patient2)\n\n    # Authenticate the doctor\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    doctor.add_patient(patient1)\n    doctor = db.session.merge(doctor)  # Reattach after each operation\n    doctor.add_patient(patient2)\n\n    # Test patients list access\n    response = client.get('/patients')\n    assert response.status_code == 200\n\n    # Patients list should show both patients\n    assert b'Alice Smith' in response.data\n    assert b'Bob Jones' in response.data    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_new_patient","title":"<code>test_new_patient(client, authenticated_doctor)</code>","text":"<p>Test patient creation view.</p> <p>Verifies that the patient creation form is displayed correctly and that new patients can be created with valid data. Also tests validation errors with invalid data.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Pre-authenticated doctor fixture</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_new_patient(self, client, authenticated_doctor):\n    \"\"\"Test patient creation view.\n\n    Verifies that the patient creation form is displayed correctly and that\n    new patients can be created with valid data. Also tests validation errors\n    with invalid data.\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Pre-authenticated doctor fixture\n    \"\"\"\n    # Test new patient form display\n    response = client.get('/patients/new')\n    assert response.status_code == 200\n    assert b'Add New Patient' in response.data\n\n    # Test patient creation\n    response = client.post('/patients/new', data={\n        'first_name': 'Jane',\n        'last_name': 'Doe',\n        'date_of_birth': '1990-05-15',\n        'gender': 'Female',\n        'contact_number': '+39123456789',\n        'email': 'jane.doe@example.com',\n        'address': '123 Test Street'\n    }, follow_redirects=True)\n      # Check response\n    assert response.status_code == 200\n    # Il messaggio effettivo contiene il nome del paziente e l'UUID\n    assert b'Patient Jane Doe successfully created with ID' in response.data\n    assert b'Jane Doe' in response.data\n\n    # Verify patient was created in database\n    patient = Patient.query.filter_by(first_name='Jane', last_name='Doe').first()\n    assert patient is not None\n    assert patient.date_of_birth == date(1990, 5, 15)\n    assert patient.gender == 'Female'\n    assert patient.contact_number == '+39123456789'\n    assert patient.email == 'jane.doe@example.com'\n\n    # Test patient creation with invalid data\n    response = client.post('/patients/new', data={\n        'first_name': '',  # Empty first name\n        'last_name': 'Test',\n        'date_of_birth': '1990-05-15',\n        'gender': 'Male',\n        'contact_number': '+39123456789',\n        'email': 'invalid.email',  # Invalid email\n        'address': '123 Test Street'\n    }, follow_redirects=True)\n      # Check response shows errors\n    assert response.status_code == 200\n    assert b'Name, surname and date of birth are mandatory fields' in response.data    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_patient_detail","title":"<code>test_patient_detail(client, doctor_with_patient, note_factory, patient_factory)</code>","text":"<p>Test patient detail view functionality.</p> <p>Verifies that a doctor can view the details of their associated patients, including patient information and notes.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>note_factory</code> <p>Factory fixture to create note instances</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_patient_detail(self, client, doctor_with_patient, note_factory, patient_factory):\n    \"\"\"Test patient detail view functionality.\n\n    Verifies that a doctor can view the details of their associated patients,\n    including patient information and notes.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        note_factory: Factory fixture to create note instances\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    from app import db\n\n    doctor = db.session.merge(doctor_with_patient['doctor'])\n    patient = db.session.merge(doctor_with_patient['patient'])\n\n    # Perform an explicit login\n    response = client.post('/login', data={\n        'email': doctor.email,\n        'password': 'Password123!'  # Standard password used in doctor_factory\n    }, follow_redirects=True)\n\n    assert response.status_code == 200\n    assert b'Dashboard' in response.data, \"Login failed\"\n\n    # Make sure the session is properly set\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Add some notes\n    note_factory(doctor, patient, \"First test note\")\n    note_factory(doctor, patient, \"Second test note\")\n\n    # Test patient detail access (after adding notes)\n    db.session.refresh(patient)  # Make sure the patient is updated\n    response = client.get(f'/patients/{patient.id}')\n    assert response.status_code == 200\n\n    # Check patient info is displayed\n    assert patient.first_name.encode() in response.data\n    assert patient.last_name.encode() in response.data\n\n    # Check notes are displayed\n    assert b'First test note' in response.data\n    assert b'Second test note' in response.data\n\n    # Test with non-existent patient\n    response = client.get('/patients/9999')\n    assert response.status_code == 404        # Test with patient not associated with doctor\n    # Use patient_factory as parameter\n    unassociated_patient = patient_factory()\n    response = client.get(f'/patients/{unassociated_patient.id}')\n    assert response.status_code == 302  # System redirects instead of returning 403    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_edit_patient","title":"<code>test_edit_patient(client, doctor_with_patient, patient_factory)</code>","text":"<p>Test patient edit view functionality.</p> <p>Verifies that a doctor can edit the information of their associated patients and that the changes are correctly saved in the database.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_edit_patient(self, client, doctor_with_patient, patient_factory):\n    \"\"\"Test patient edit view functionality.\n\n    Verifies that a doctor can edit the information of their associated patients\n    and that the changes are correctly saved in the database.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Test edit form display\n    response = client.get(f'/patients/{patient.id}/edit')\n    assert response.status_code == 200\n    assert b'Edit Patient' in response.data\n\n    # Test patient update\n    response = client.post(f'/patients/{patient.id}/edit', data={\n        'first_name': 'Updated',\n        'last_name': 'Name',\n        'date_of_birth': '1985-10-20',\n        'gender': 'Non-binary',\n        'contact_number': '+39987654321',\n        'email': 'updated.email@example.com',\n        'address': 'Updated Address'\n    }, follow_redirects=True)\n      # Check response\n    assert response.status_code == 200\n    assert b'Patient information updated successfully' in response.data\n    assert b'Updated Name' in response.data\n\n    # Verify patient was updated in database\n    updated_patient = Patient.query.get(patient.id)\n    assert updated_patient.first_name == 'Updated'\n    assert updated_patient.last_name == 'Name'\n    assert updated_patient.date_of_birth == date(1985, 10, 20)\n    assert updated_patient.gender == 'Non-binary'\n    assert updated_patient.contact_number == '+39987654321'\n    assert updated_patient.email == 'updated.email@example.com'\n    assert updated_patient.address == 'Updated Address'\n\n    # Test with non-existent patient\n    response = client.post('/patients/9999/edit', data={\n        'first_name': 'Test',\n        'last_name': 'Patient'\n    })\n    assert response.status_code == 404        # Test with patient not associated with doctor        # Create a patient not associated with the doctor\n    unassociated_patient = db.session.merge(patient_factory())\n    response = client.post(f'/patients/{unassociated_patient.id}/edit', data={\n        'first_name': 'Test',\n        'last_name': 'Patient'\n    })\n    assert response.status_code == 302  # System redirects instead of returning 403    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_delete_patient","title":"<code>test_delete_patient(client, doctor_with_patient, patient_factory, doctor_factory)</code>","text":"<p>Test patient deletion view functionality.</p> <p>Verifies that a doctor can delete patients from their list, and tests various deletion scenarios including non-existent patients and patients with  multiple doctor associations.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required <code>doctor_factory</code> <p>Factory fixture to create doctor instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_delete_patient(self, client, doctor_with_patient, patient_factory, doctor_factory):\n    \"\"\"Test patient deletion view functionality.\n\n    Verifies that a doctor can delete patients from their list, and tests various\n    deletion scenarios including non-existent patients and patients with \n    multiple doctor associations.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        patient_factory: Factory fixture to create patient instances\n        doctor_factory: Factory fixture to create doctor instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Test patient deletion\n    response = client.post(f'/patients/{patient.id}/delete', follow_redirects=True)\n      # Check response\n    assert response.status_code == 200\n    assert b'Patient successfully removed' in response.data\n\n    # Verify patient was deleted from database\n    deleted_patient = Patient.query.get(patient.id)\n    assert deleted_patient is None\n\n    # Test with non-existent patient\n    response = client.post('/patients/9999/delete', follow_redirects=True)\n    assert response.status_code == 404\n      # Test with patient not associated with doctor\n    unassociated_patient = patient_factory()\n    response = client.post(f'/patients/{unassociated_patient.id}/delete', follow_redirects=True)\n    assert response.status_code == 200  # Con follow_redirects=True, anche se c'\u00e8 un reindirizzamento, il codice sar\u00e0 200\n\n    # Test deletion of patient with multiple doctors\n    # Create a patient associated with multiple doctors\n    multi_doctor_patient = patient_factory()\n    doctor2 = doctor_factory()\n\n    # Associate both doctors with patient\n    doctor.add_patient(multi_doctor_patient)\n    doctor2.add_patient(multi_doctor_patient)\n\n    # Delete patient (should only remove association)\n    response = client.post(f'/patients/{multi_doctor_patient.id}/delete', follow_redirects=True)\n    assert response.status_code == 200\n\n    # Patient should still exist but no longer be associated with the current doctor\n    patient_exists = Patient.query.get(multi_doctor_patient.id) is not None\n    assert patient_exists is True\n\n    doctor_patient = DoctorPatient.query.filter_by(\n        doctor_id=doctor.id, \n        patient_id=multi_doctor_patient.id\n    ).first()\n    assert doctor_patient is None    \n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_patient_vitals","title":"<code>test_patient_vitals(client, doctor_with_patient)</code>","text":"<p>Test patient vitals view functionality.</p> <p>Verifies that a doctor can view the vital signs of their associated patients and that different time period filters work correctly.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_patient_vitals(self, client, doctor_with_patient):\n    \"\"\"Test patient vitals view functionality.\n\n    Verifies that a doctor can view the vital signs of their associated patients\n    and that different time period filters work correctly.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Ensure authentication\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Test vitals page access\n    response = client.get(f'/patients/{patient.id}/vitals')\n    assert response.status_code == 200\n    assert b'Vital Signs' in response.data or b'vitals' in response.data.lower()\n\n    # Test with different time periods\n    response = client.get(f'/patients/{patient.id}/vitals?period=7')\n    assert response.status_code == 200\n\n    response = client.get(f'/patients/{patient.id}/vitals?period=30')\n    assert response.status_code == 200\n\n    # Test API endpoint for fetching vitals data\n    response = client.get(f'/api/patients/{patient.id}/vitals?type=heart_rate')\n    # Note: This will likely return no data since we haven't mocked health platform data\n    assert response.status_code in [200, 404]  # Either empty data or platform not connected\n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_add_note","title":"<code>test_add_note(client, doctor_with_patient, patient_factory)</code>","text":"<p>Test adding notes to a patient.</p> <p>Verifies that a doctor can add notes to their associated patients, and tests validation of empty notes and access control.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_add_note(self, client, doctor_with_patient, patient_factory):\n    \"\"\"Test adding notes to a patient.\n\n    Verifies that a doctor can add notes to their associated patients,\n    and tests validation of empty notes and access control.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    patient = doctor_with_patient['patient']\n\n    # Test adding a note\n    note_content = \"This is a test note for the patient.\"\n    response = client.post(f'/patients/{patient.id}/notes', data={\n        'content': note_content\n    }, follow_redirects=True)\n\n    # Check response\n    assert response.status_code == 200\n    assert b'Note added successfully' in response.data\n    assert note_content.encode() in response.data\n\n    # Verify note was added to database\n    note = Note.query.filter_by(content=note_content, patient_id=patient.id).first()\n    assert note is not None\n\n    # Test with empty content\n    response = client.post(f'/patients/{patient.id}/notes', data={\n        'content': ''\n    }, follow_redirects=True)\n    assert response.status_code == 200\n    assert b'Note content cannot be empty' in response.data\n\n    # Test with non-existent patient\n    response = client.post('/patients/9999/notes', data={\n        'content': 'Test note'\n    })\n    assert response.status_code == 404\n\n    # Test with patient not associated with doctor\n    response = client.post(f'/patients/{patient_factory().id}/notes', data={\n        'content': 'Test note'\n    })\n    assert response.status_code == 302  # System redirects instead of returning 403\n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_delete_note","title":"<code>test_delete_note(client, doctor_with_patient, note_factory)</code>","text":"<p>Test deleting notes from a patient.</p> <p>Verifies that a doctor can delete notes they created for their patients, but cannot delete notes created by other doctors.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>doctor_with_patient</code> <p>Fixture providing a doctor with an associated patient</p> required <code>note_factory</code> <p>Factory fixture to create note instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_delete_note(self, client, doctor_with_patient, note_factory):\n    \"\"\"Test deleting notes from a patient.\n\n    Verifies that a doctor can delete notes they created for their patients,\n    but cannot delete notes created by other doctors.\n\n    Args:\n        client: Flask test client\n        doctor_with_patient: Fixture providing a doctor with an associated patient\n        note_factory: Factory fixture to create note instances\n    \"\"\"\n    doctor = doctor_with_patient['doctor']\n    patient = doctor_with_patient['patient']\n\n    # Ensure proper authentication\n    with client.session_transaction() as session:\n        session['_user_id'] = str(doctor.id)\n        session['_fresh'] = True\n\n    # Create a note\n    note = note_factory(doctor, patient, \"Note to be deleted\")\n\n    # Adjust to proper endpoint format and method - using DELETE instead of POST\n    response = client.delete(f'/notes/{note.id}')\n\n    # Check response\n    assert response.status_code == 200\n    try:\n        data = json.loads(response.data)\n        assert 'message' in data\n    except json.JSONDecodeError:\n        # If it's not JSON, check for success indicators in HTML\n        assert b'successfully' in response.data.lower() or b'deleted' in response.data.lower()\n\n    # Verify note was deleted from database\n    deleted_note = Note.query.get(note.id)\n    assert deleted_note is None\n\n    # Test with non-existent note\n    response = client.delete('/notes/9999')\n    assert response.status_code == 404\n\n    # Test with note not created by doctor\n    from app.models import Doctor\n    other_doctor = Doctor(\n        email=\"other_doctor@example.com\",\n        first_name=\"Other\",\n        last_name=\"Doctor\",\n        specialty=\"General Medicine\"\n    )\n    other_doctor.set_password(\"Password123!\")\n    db.session.add(other_doctor)\n    db.session.commit()\n\n    other_note = note_factory(other_doctor, patient, \"Note by another doctor\")\n\n    # Attempt to delete other doctor's note\n    response = client.delete(f'/notes/{other_note.id}')\n    assert response.status_code == 403\n</code></pre>"},{"location":"tests/test_views.html#test_views.TestViews.test_import_patient","title":"<code>test_import_patient(client, authenticated_doctor, patient_factory)</code>","text":"<p>Test importing existing patients by UUID.</p> <p>Verifies that a doctor can import existing patients by their UUID,  and tests various import scenarios including non-existent patients and already associated patients.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>Flask test client</p> required <code>authenticated_doctor</code> <p>Pre-authenticated doctor fixture</p> required <code>patient_factory</code> <p>Factory fixture to create patient instances</p> required Source code in <code>tests/test_views.py</code> <pre><code>def test_import_patient(self, client, authenticated_doctor, patient_factory):\n    \"\"\"Test importing existing patients by UUID.\n\n    Verifies that a doctor can import existing patients by their UUID, \n    and tests various import scenarios including non-existent patients\n    and already associated patients.\n\n    Args:\n        client: Flask test client\n        authenticated_doctor: Pre-authenticated doctor fixture\n        patient_factory: Factory fixture to create patient instances\n    \"\"\"\n    # Create a patient that isn't associated with the doctor\n    patient = patient_factory()\n\n    # Test importing via API\n    response = client.post('/patients/import', json={\n        'patient_uuid': patient.uuid\n    }, follow_redirects=True)\n\n    # Check response\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert 'message' in data\n    assert data['message'] == \"Patient imported successfully\"\n\n    # Verify patient is now associated with doctor\n    # We need to refresh the doctor object from the database\n    updated_doctor = db.session.get(authenticated_doctor.__class__, authenticated_doctor.id)\n    updated_patient = db.session.get(patient.__class__, patient.id)\n    patient_in_list = updated_patient in updated_doctor.get_patients()\n    assert patient_in_list is True\n\n    # Test importing patient that doesn't exist\n    response = client.post('/patients/import', json={\n        'patient_uuid': str(uuid4())\n    })\n    assert response.status_code == 404\n\n    # Test importing patient already associated with doctor\n    response = client.post('/patients/import', json={\n        'patient_uuid': patient.uuid\n    })\n    assert response.status_code == 409  # Conflict\n</code></pre>"}]}